<page>
 <shortlink>tpl overview</shortlink>
 <topic>TransForm Programming Language Overview</topic>
 <description>
  Introduction to the TransForm Programming Language, TPL, along
  with explanations of the data model, expressions, statements, etc.
 </description>
 <sections>
  <section>
   <title>Overview</title>
   <description>
    <p>
     The TransForm Programming Language (TPL) is a means by which a form designer
     can specify the behavior of a TransForm form as the user fills it in.
    </p>
    <p>
     TPL is a traditional programming language turned to the needs of TransForm forms.
     While not identical to any other programming language, its syntax and
     semantics should be familiar and easily learned by developers familiar with languages
     such as Basic, JavaScript, Java, and C.
    </p>
    <p>
     TPL code is used in TransForm in two main ways: 
     *[Standalone expressions]* to calculate values for display or condition testing
     and *[multi-line functions]* to respond to events such as field value changes or to 
     be called in expressions or other functions.
    </p>
    <p>
     This documentation gives a simple introduction to TPL, followed by more
     detailed explanations of various aspects of the language.
     The different sections are:
    </p>
    <p>
     <list>
      <item>
       <name>Samples of Use</name>
       <description>
        Some simple examples of TPL programs.
       </description>
      </item>
      <item>
       <name>Data Types</name>
       <description>
        The types of data items and organization manipulated 
        by TPL code.
       </description>
      </item>
      <item>
       <name>Data Model</name>
       <description>
        The particular data structures available to TPL code, including
        form data and local variables, and how it is accessed.
       </description>
      </item>
      <item>
       <name>Expressions</name>
       <description>
        The operators and operands that are used for computation.
       </description>
      </item>
      <item>
       <name>Statements</name>
       <description>
        The types of statements, including 
        those for looping, testing conditionals, and flow-control.
       </description>
      </item>
      <item>
       <name>Functions</name>
       <description>
        Using built-in and user-defined functions in expressions.
       </description>
      </item>
      <item>
       <name>Execution</name>
       <description>
        The times when TPL code is executed 
        and the restrictions sometimes imposed.
       </description>
      </item>
      <item>
       <name>User-Defined Functions</name>
       <description>
        Defining and using functions written by the form designer.
       </description>
      </item>
      <item>
       <name>Built-in Functions</name>
       <description>
        An overview of the functions built-in to TPL.
       </description>
      </item>
      <item>
       <name>Why TPL?</name>
       <description>
        Why an application-specific language was used instead of a popular, existing one.
       </description>
      </item>
     </list>
    </p>
   </description>
  </section>
  <section>
   <title>Samples of Use</title>
   <description>
    <p>
     Here are some...
     
    </p>
   </description>
  </section>
  <section>
   <title>Data Types</title>
   <description>
    <p>
     There are a few different types of data that are handled by TPL code.
     These include individual values, such as strings of text, as well as groupings 
     of data, such as records with fields and datagroups with one or more items each 
     with their own group of fields and/or other datagroups.
     There is also the type of data returned from database queries and REST calls
     organized in JSON format. JSON format has values (strings, numbers, and true/false/null), 
     objects, and arrays. 
     Form data is stored as JSON, with datagroups being arrays of objects, and most 
     field values stored as strings.
     TPL provides means for working with these different data types.
    </p>
    <p>
     Most data used by TPL code is either *[text data]*, including text representations
     of numeric and date/time values, or *[JSON-style objects]* (including arrays).
     Operators and built-in functions are provided for working with this data.
     For example "+" is a binary operator that results in a text representation 
     of the numeric sum of
     two values that are, or can be converted to, numbers, and "<![CDATA[&]]>" is a 
     binary operator that results in a text value that is the concatenation 
     of two values that are accessed as text strings.
     JSON data that has other types of values (such as numeric, boolean, and null) are 
     interpreted in an appropriate way by operators.
    </p>
    <p>
     In expressions and statements, numeric constants are represented as 
     integers or decimal values.
     Text constants are enclosed in double-quote (") characters.
     Within the double-quotes, a double-quote may be represented by 
     a backslash ("\") followed by a double-quote. 
     Other escapes are "\n" for embedded newline, "\t" for a tab character,
     and "\\" for a backslash. 
    </p>
    <p>
     *[Date/time values]* in TransForm are usually represented by text
     in the form of "YYYY-MM-DD hh:mm:ss.s".
     This is a locale-independent "year/month/day hours:minutes:seconds" form 
     that when sorted alphabetically also sorts by chronological time. 
     The full-time, seconds, or fractional seconds values are optionally present.
     The time zone is assumed to be that where the device is running.
     Built-in functions are provided to facilitate conversion to and from other forms, 
     such as "seconds since a particular date".
    </p>
    <p>
     *[True/False values]* in TransForm calculations are usually represented by a blank value ("") 
     for false, and "1" or any other non-blank value for true.
     The IF statement, and the "!", "||" and "<![CDATA[&&]]>" operators, all
     treat "" as false and all other values as true.
     The expression "<![CDATA[4 < 5]]>" results in "1" and "<![CDATA[4 > 5]]>"
     results in "".
     Note that the values of some form fields may need to be interpreted differently
     and they may require
     explicit text value testing, such as checking for "Yes" for true and "No" for false,
     or setting to those values as appropriate for the results of a calculation.
    </p>
    <p>
     An example of some data is the following (expressed as JSON):
    </p>
    <p>
     <example><![CDATA[{
   "field1": "Value A",
   "field2": "Value B",
   "array1":
      [
         {
            "x": 10,
            "y": 20
         },
         {
            "x": 15,
            "y": 45
         }
      ],
   "obj1":
      {
         "a": "Some text"
      }
}]]></example>
    </p>
    <p>
     TPL code can access that data using the following syntaxes:
    </p>
    <p>
     <list>
      <item>
       <name code="true">name</name>
       <description>
          A name accesses that name/value pair at top level.
          For example, "field1" refers to the name value pair with 
          value "Value A" and "array1" refers to the name/value pair 
          with a value of the array with two elements.
          Names should generally start with an alphabetic character or "_".
       </description>
      </item>
      <item>
       <name code="true">objectValue.name</name>
       <description>
        <p>
         A "." between an object value (such as the name 
         of an object) and a name accesses the name/value pair 
         within the object. 
         For example, "obj1.a" would have a value of "Some text".
        </p>
        <p>
         The objectValue must evaluate to a reference to 
         an object.
         If the objectValue refers to an element in an array that is not
         already defined within an existing array, 
         then that element will be defined with an empty object as 
         its value when used with the "." syntax.
         If the objectValue refers to an object and the name refers to
         a name that is not already defined 
         within the object, then that name will act as if it is 
         undefined when used.
         If the objectValue refers to an undefined name/value pair 
         within a parent object, that name will be defined 
         in the parent object with an empty object.
         This means that intermediate objects and array items
         are automatically defined
         when part of the path to a name/value pair.
         For example: 
        </p>
        <p>
         <example><![CDATA[a = obj()  ' new, empty object
b = a.x    ' b gets "", a.x stays undefined
c = a.x.y  ' c get "", a.x is empty object
]]></example>
        </p>
       </description>
      </item>
      <item>
       <name code="true">arrayValue[index]</name>
       <description>
        <p>
        An integer value enclosed by brackets after an array value accesses
        the element of the array specified by the index (0-origined). If it is an 
        array of objects, the value is an object. If it is 
        an array of scalar values (strings, numbers), the value is 
        that scalar value.
        For example, "array1[1]" would access the element with and object with x=15 and 
        y=45.
        If the element does not exist (index is greater than the length of
        the array minus 1) then the value is "".
        </p>
        <p>
         If the index is negative, then it specifies an element of the array
         counting from the last element (-1 is the last element, -2 is the 
         second from the last, etc.). If the index specifies an element 
         before the first element of the array, then the value is the first element.
        </p>  
       </description>
      </item>
      <item>
       <name code="true">objectValue[nameAsString]</name>
       <description>
        <p>
         A text value enclosed by brackets after an object 
         value accesses the name/value pair within the object. 
         For example, "obj1["a"]" would have a value of "Some text".
        </p>
        <p>
         The "nameAsString" may be either a string constant (characters
         surrounded by double-quotes) or a value that results in text.
        </p>
       </description>
      </item>
      <item>
       <name code="true">stringValue[index]</name>
       <description>
        <p>
         An integer value enclosed by brackets after a string (text) value 
         results in the single character at that position in the string (0-origined). 
         For example, "field1[3]" would be the letter "u".
        </p>
        <p>
         If the index is negative, then it specifies the character in 
         a position counting from the end of the string, with -1 being the 
         last character. For example, "field1[-3]" would be the letter "e".
        </p>
        <p>
         Indexes specifying characters past either end of the string will return "".
        </p>
       </description>
      </item>
     </list>
    </p>
    <p>
     Other examples are:
    </p>
    <p>
     <cases>
      <case>
       <title>Example 1</title>
       <description>
        Description of Example 1 goes here above the example itself.
       </description>
       <example>a = b</example>
      </case>
      <case>
       <title>Example 2</title>
       <example>a = b.c</example>
      </case>
     </cases>
    </p>
   </description>
  </section>
  <section>
   <title>Data Model</title>
   <description>
    <p>
     There are several classes of data that a TPL program needs to access.
     These include the data fields of the form being edited, information
     about the form (such as its status), and temporary data to be used
     as part of computing various results. 
     TPL provides means for explicitly referring to each of the different classes of data.
    </p>
    <p>
     Each of the different classes of data are organized as JSON-style data.
     That is, they are an object, with name/value pairs. The values may be
     text, objects, or arrays of objects.
    </p>
    <p>
     To better understand the different classes, it helps to look at the "lifecycle" 
     of filling out or updating form data and the different times in that 
     lifecycle when TPL code is executed. 
     We'll call this the *[Form Editing Lifecycle]*.
    </p>
    <p>
     The Form Editing Lifecycle starts when a form (also known as a 
     "form instance") is chosen from the Existing 
     Forms List in the Form Filler and opened for editing by either double-tapping or using 
     the Edit command in the Main Control Bar above the list. 
     This will bring up the Form Details Screen which shows the contents 
     of that form instance. The Form Details Screen shows some 
     or all of the form's fields and their
     current values, optional descriptive and help information, and 
     buttons for displaying "pages" with additional fields and performing
     certain operations such as uploading and submitting the form to the server.
    </p>
    <p>
     Before the form is opened for editing, optional "*[ON *LOAD]*" TPL code 
     may be executed.
    </p>
    <p>
     Each time the Form Details Screen is displayed, as part of assembling that 
     display TPL code may be executed to fill in *[placeholders]* within 
     various blocks of text. A placeholder consist of a standalone TPL expression 
     enclosed within brace characters ("{" and "}") within the text. 
     For example, the text of a heading may include the placeholder "{field1}" 
     which would be replaced by "Value A", or it may include "{len(field1)}" which would be 
     replaced by "7".
    </p>
    <p>
     As part of assembling the Form Details Screen, there may be IF commands 
     as part of the form type definition to conditionally show and hide 
     parts of the form. (Note: These are form IF commands in the form type's 
     Commands List, not TPL IF statements in TPL code.)
     Those IF commands include a standalone *[IF TEST]* TPL expression that is evaluated 
     each time the screen is reassembled. 
     If that expression is True (any value other than "") then the 
     commands up until an ELSE or ENDIF are executed to display fields, etc.
     Otherwise, those intermediate commands are skipped.
    </p>
    <p>
     In addition to IF TEST expressions, some other form commands allow the use of 
     *[Form Display Expressions]* as part of rendering their display and operation.
     The type of value needed and the way in which that value is used depends upon 
     the command. 
     For example, a List field may optionally obtain the list of items to display 
     from a calculated array of objects instead of from a fixed list entered at the time 
     the command was created by the form designer.
    </p>
    <p>
     When certain editors are opened by the user to edit a field value, such as by tapping
     on a List Field, or by tapping the "Next" or "Previous" button in another
     editor to change to the editor, optional
     "*[ON *EDITOR]*" TPL code may be executed.
    </p>
    <p>
     When a field's value is changed by the user, such as by typing in a new value
     and tapping the Confirm, Next Field, or Previous Field button, optional
     "*[ON *CHANGED]*" TPL code may be executed.
    </p>
    <p>
     When certain buttons that are part of the form are tapped, 
     optional *[ON *Button Execution]* TPL code associated with that button is executed.
    </p>
    <p>
     Finally, when the form is finished being edited, and the display 
     is being changed back to the Existing Forms List, 
     optional "*[ON *FINISHED]*" TPL code may be executed.
    </p>
    <p>
     See the Functions section of this Help for more specifics of the "*[ON *Events]*".
    </p>
    <p>
     During the Form Editing Lifecycle, there are certain classes of 
     data that relate to the particular form instance being edited. 
     These classes of data are:
    </p>
    <p>
     <list>
      <item>
       <name>Form Data</name>
       <description>
          Form Data is the JSON object that contains the current values of 
          all of the form's fields.
          Within this object may also be arrays of objects for data groups 
          that are part of the form, such as information about multiple
          photos or line items.
       </description>
      </item>
      <item>
       <name>Group Data</name>
       <description>
          Group Data is a JSON object that contains the current values 
          of just a single item within a Data Group.
          Since there can be more than one item in a Data Group, 
          this provides a simple way to refer to related fields within that 
          item. The particular Data Group is the one that contains the field being 
          edited, the text placeholder associated with the heading being 
          evaluated, any IF commands being evaluated, etc.
          Group Data includes any sub-data groups within the item.
          For TPL code running for ON *LOAD and ON *FINISHED and when there 
          are no enclosing data groups associated with the TPL code,
          Group Data is the same as Form Data; that is, it refers to
          all of the form's fields and arrays of data.
       </description>
      </item>
      <item>
       <name>Metadata</name>
       <description>
          Metadata is made up of some of the metadata fields for the form instance
          plus some other values.
          This includes the current status value for the form,
          the date/time created, the user ID (an email address) of 
          the person assigned this form, and more.
       </description>
      </item>
     </list>
    </p>
    <p>
     In addition to the form instance data, there are other classes of data:
    </p>
    <p>
     <list>
      <item>
       <name>Local Data</name>
       <description>
          Local Data is an object that may be used to hold temporary values needed
          during execution of a single TPL function. 
          For example, the name/value pair named "i" could be used to hold the 
          counter in a FOR loop and one named "result" could be used to hold the result 
          object from an Ajax call (with "result.error" indicating any errors and 
          "result.responseText" containing the server response as text).
          A different instance of the Local Data object is created for each
          function invocation or standalone expression.
          So, for example, a recursive function would have
          a new instance for each call, with the previous instance restored on return.
       </description>
      </item>
      <item>
       <name>Global Data</name>
       <description>
          Global Data is an object that is persistent throughout Form Editing Lifecyle.
          A different instance is created each time the lifecycle starts.
          The object may be used to hold temporary values that need to be shared among different 
          TPL code functions and standalone expressions.
       </description>
      </item>
      <item>
       <name>System Data</name>
       <description>
          System Data is an object that exposes various values representing the current
          state of the Form Filler.
          This includes the current user ID and display name, account ID and display name,
          the "path" of data groups and objects starting at top-level Form Data and 
          ending in Group Data, and more. 
       </description>
      </item>
     </list>
    </p>
    <p>
     The first characters of a name specify which of the different classes of data 
     is being referred to in TPL code:
    </p>
    <p>
     <list>
      <item>
       <name code="true">LocalData</name>
       <description>
          References to *[plain names]* (starting with an alphabetic character or "_")
          are assumed to refer the current function's temporary Local Data.
          Local Data values may be scalar values, like text, or arrays or objects.
          Local Data is an empty object when a function starts executing.
          New name/value pairs may be created by assigning to the name.
          See the description of assignment statements in the section on Statements
          and the sample code examples.
       </description>
      </item>
      <item>
       <name code="true">^GlobalData</name>
       <description>
          References to names preceded by a single "*[^]*" character
          are assumed to refer the current Form Editing Lifecycle's Global Data.
          Global Data values may be scalar values, like text, or arrays or objects.
          Global Data is an empty object at the start of editing a form instance.
          New name/value pairs may be created by assigning to the name.
          See the description of assignment statements in the section on Statements
          and the sample code examples.
       </description>
      </item>
      <item>
       <name code="true">#FormData</name>
       <description>
          References to names preceded by a single "*[#]*" character (e.g., "#field1")
          are assumed to refer the current Form Data.
          The entire form data object is available, e.g., "#array[1].y" would 
          refer to the value of "y" in the second item in data group "array1".
       </description>
      </item>
      <item>
       <name code="true">##GroupData</name>
       <description>
          References to names preceded by two "*[##]*" characters (e.g., "##x")
          are assumed to refer the current Group Data.
       </description>
      </item>
      <item>
       <name code="true">$#Metadata</name>
       <description>
        <p>
          References to names preceded by the two characters "*[$#]*" (e.g., "$#status")
          are assumed to refer the current form Metadata.
          The metadata is presented as an object with name/value pairs
          representing copies of form instance data.
          (This means that assigning to them does not change the 
          actual value in the form.)
          The metadata items are:
        </p>
        <p>
         <list>
          <item>
           <name code="true">$#accountid</name>
           <description>
            The account ID associated with the form instance.
           </description>
          </item>
          <item>
           <name code="true">$#created</name>
           <description>
            The date/time the form instance was created.
           </description>
          </item>
          <item>
           <name code="true">$#comments</name>
           <description>
            The representation of the JSON for the comments associated with the form instance.
           </description>
          </item>
          <item>
           <name code="true">$#completed</name>
           <description>
            The date/time when the status was last changed.
           </description>
          </item>
          <item>
           <name code="true">$#formid</name>
           <description>
            The Form ID of the form type being applied to the form data.
           </description>
          </item>
          <item>
           <name code="true">$#forminstanceid</name>
           <description>
            The unique ID of the form instance.
           </description>
          </item>
          <item>
           <name code="true">$#formversion</name>
           <description>
            The not currently used. If form IDs have versions, the version
            used for the data will be here to allow for modified versions 
            to be handled.
           </description>
          </item>
          <item>
           <name code="true">$#haserrors</name>
           <description>
            The flag that indicates whether or not an "error" has be set 
            for the form instance. This is "Y" if true, "" if false.
           </description>
          </item>
          <item>
           <name code="true">$#missingrequired</name>
           <description>
            The flag that indicates whether or not a "required" field 
            has been detected that has no value. 
            This is "Y" if true, "" if false.
           </description>
          </item>
          <item>
           <name code="true">$#nofiller</name>
           <description>
            The value of the "no filler" setting for the form instance 
            (set, for example, using the Management Console). 
            The value is "Y" if true, and "N" or "" if false.
            This should usually be "N" or "" in the Form Filler.
           </description>
          </item>
          <item>
           <name code="true">$#person</name>
           <description>
            The User ID of the person assigned this form instance, usually 
            an email address and usually the logged in user.
            See the System Data $username and $userdisplayname values.
           </description>
          </item>
          <item>
           <name code="true">$#status</name>
           <description>
            The current status of the form instance.
           </description>
          </item>
          <item>
           <name code="true">$#timestamp</name>
           <description>
            The date/time of when this form instance was last inserted or updated
            in the server database. Blank if not yet saved.
           </description>
          </item>
         </list>
        </p>
       </description>
      </item>
      <item>
       <name code="true">$SystemData</name>
       <description>
        <p>
          References to names preceded a single "*[$]*" character (e.g., "$username")
          are assumed to refer the current form System Data.
          The data is presented as an object with name/value pairs
          representing copies of the various values.
          (This means that assigning to them does not change the 
          original value in the system.)
          The System Data items are:
        </p>
        <p>
         <list>
          <item>
           <name code="true">$accountdisplayname</name>
           <description>
            The display name for the account the user is currently logged into.
           </description>
          </item>
          <item>
           <name code="true">$accountid</name>
           <description>
            The account ID that the user is currently logged into.
           </description>
          </item>
          <item>
           <name code="true">$editfieldname</name>
           <description>
            The name of the field variable when running as "ON *editor" and "ON *changed".
            Otherwise, "".
           </description>
          </item>
          <item>
           <name code="true">$formdata</name>
           <description>
            The Form Data object. The same as what you get from "#" except
            that you can also use brackets after it to access top-level fields 
            using a text value in a variable. The values within the 
            object are read/write and changing them does change the 
            form's data.
           </description>
          </item>
          <item>
           <name code="true">$formdisplayname</name>
           <description>
            The display name for the current form's form type.
           </description>
          </item>
          <item>
           <name code="true">$formid</name>
           <description>
            The form ID for the current form's form type.
           </description>
          </item>
          <item>
           <name code="true">$groupcount</name>
           <description>
            The number of items in the current Group Data's parent
            array. See the related system data values $groupindex, $groupname, and $grouppath.
           </description>
          </item>
          <item>
           <name code="true">$groupdata</name>
           <description>
            The Group Data object. The same as what you get from "##" except
            that you can also use brackets after it to access top-level fields
            within the data group 
            using a text value in a variable. The values within the 
            object are read/write and changing them does change the 
            form's data.
           </description>
          </item>
          <item>
           <name code="true">$groupindex</name>
           <description>
            The index (0-origined) of the current Group Data within its parent
            array. See the related system data values $groupcount, $groupname, and $grouppath.
           </description>
          </item>
          <item>
           <name code="true">$groupname</name>
           <description>
            The Name command property of the data group containing the current Group Data in 
            Form Display Expressions. 
            The Array Name of the data group containing the current Group Data in most other
            cases.
           </description>
          </item>
          <item>
           <name code="true">$grouppath</name>
           <description>
            <p>
             A specification of the explicit "path" from Form Data to Group Data.
             This is an array of text and numeric values.
             The text values specify the names of the parent objects or arrays and the 
             numeric values specify the element indexes (0-origined) within arrays.
             For example: 
            </p>
            <p>
             <example><![CDATA[["array1",1]]]></example>
            </p>
            <p>
             would be the value of $grouppath if array1[1].x was being edited and array1[1] 
             was the Group Data.
            </p>
            <p>
             It is assumed that code using $grouppath is written knowing the 
             general structure of the fields, objects, and arrays in the path
             for that form type. The $grouppath value is useful, for example,
             to access fields in a Group Data's parent or to make use of the 
             index(es) of Group Data in its parent(s).
            </p>
            <p>
             Related system data values are $groupcount, $groupindex, and $groupname.
            </p>
           </description>
          </item>
          <item>
           <name code="true">$haserrors</name>
           <description>
            The flag that indicates whether or not an "error" has be set 
            for the form instance. This is "Y" if true, "" if false.
           </description>
          </item>
          <item>
           <name code="true">$language</name>
           <description>
            The selection of which language to use when multi-languague support
            is available for an account's forms.
           </description>
          </item>
          <item>
           <name code="true">$languages</name>
           <description>
            An object with information about the languages that may be supported by 
            form types for this account, with name/value pairs specifying 
            the short name and display name.
           </description>
          </item>
          <item>
           <name code="true">$lastdefsdownloadtime</name>
           <description>
            The date/time when form type definitions were last downloaded 
            from the server for this account. If none downloaded, this will
            be blank.
           </description>
          </item>
          <item>
           <name code="true">$lastrefresh</name>
           <description>
            The date/time when all form instances were last downloaded (or refreshed)
            from the server for this account. If downloading was not done, this 
            will be blank.
           </description>
          </item>
          <item>
           <name code="true">$lastsync</name>
           <description>
            The date/time when any forms modified or created since last login 
            were last uploaded to the server for this account.
            If no sync has occurred, this will be blank.
           </description>
          </item>
          <item>
           <name code="true">$missingrequired</name>
           <description>
            The flag that indicates whether or not a "required" field 
            has been detected that has no value. 
            This is "Y" if true, "" if false.
           </description>
          </item>
          <item>
           <name code="true">$nowait</name>
           <description>
            The flag that indicates whether execution show avoid 
            situations that will require waiting for completion. 
            This is "1" if true (do not wait), "" if false (waiting is permitted).
            See the description of "Execution" in this language documentation.
           </description>
          </item>
          <item>
           <name code="true">$userdisplayname</name>
           <description>
            The display name for the currently logged in user.
           </description>
          </item>
          <item>
           <name code="true">$username</name>
           <description>
            The user ID for the currently logged in user, usually an email address.
           </description>
          </item>
         </list>
        </p>
       </description>
      </item>
     </list>
    </p>
   </description>
  </section>
  <section>
   <title>Expressions</title>
   <description>
    <p>
     Expressions in TPL are similar to most computer languages.
     They are a combination of explicit constant values, references 
     to variable values, operators, and functions.
     An expression is evaluated by applying the operators and 
     functions to the values and any intermediate values, resulting in
     the value of the expression itself.
     The order of execution of the operators is determined by certain rules which 
     include the use of parenthesis to override the defaults.
    </p>
    <p>
     An expression may consist of a single value, such as just 
     the number "5" or a reference to a field like "field1", and not
     involve any operators or functions.
    </p>
    <p>
     The value of an expressions may be a simple, scalar value, such as text,
     or it may be a reference to an JSON-style object or array.
    </p>
    <p>
     Expressions are used in TransForm for a variety of purposes.
     They are used by IF commands in form type definitions to 
     control hiding and showing parts of the form.
     They are used in placeholders within various blocks of text 
     to, for example, provide text that varies depending upon 
     the value of a field.
     They are used in statements that make up programs executed 
     to respond to events such as field editing.
    </p>
    <p>
     The operators are (in decreasing order of precedence):
    </p>
    <p>
     <list>
      <item>
       <name code="true">+
-
!</name>
       <description>
        Unary plus, minus, and "not". 
        Plus and minus attempt to convert the value to
        a number, or else 0.
        Plus results in the number as text.
        Minus results is the negative of the number as text.
        (minus of 1 is -1, minus of -1 is 1).
        "Not" treats the value as text and returns the text value "1"
        (true) if the value is blank and "" (false) otherwise.
      </description>
      </item>
      <item>
       <name code="true">*
/</name>
       <description>
        <p>
         Multiply and divide. 
         Both attempt to convert the value to their left and 
         the value to their right to a number, or else 0.
         Multiply results in the product of the two.
         Divide results in the division of the left by the right.
         The results are text representations of the result values.
         For example: 
        </p>
        <p>
         <example><![CDATA[2.00 * 3.00]]></example>
        </p>
        <p>
         will result in the text value "6".
         To control precision or formatting, use functions like *[????]*.
        </p>
      </description>
      </item>
      <item>
       <name code="true">+
- 
<![CDATA[&]]></name>
       <description>
        <p>
         Add, subtract, and concatenate.
        </p>
        <p> 
         Add and subtract attempt to convert the value to their left and 
         the value to their right to a number, or else 0.
         Add results in the sum of the two.
         Subtract results in subtracting the right from the left.
         The results are text representations of the result values.
         For example: 
        </p>
        <p>
         <example><![CDATA[1.00 + 2.00]]></example>
        </p>
        <p>
         will result in the text value "3".
         To control precision or formatting, use functions like *[????]*.
        </p>
        <p>
         Concatenate converts the value to its left and right to text.
         The result is the left value followed by the right.
         For example: 
        </p>
        <p>
         <example><![CDATA["abc" & "def"]]></example>
        </p>
        <p>
         will result in the text value "abcdef".
        </p>
      </description>
      </item>
      <item>
       <name code="true"><![CDATA[<
<=
>=
>]]></name>
       <description>
        <p>
         Less than, less than or equal to, greater than or equal to, and greater than.
         These comparison operators attempt to convert the value to their left and 
         the value to their right to a number ("" is treated as zero), 
         or else they are left as text.
         If both values are numeric then the test is a numeric comparison.
         If either value is not convertible to a number then the test
         will be the text comparison of the two values converted to lower-case.
         The result is the text value "1" for true and "" for false.
         For example: 
        </p>
        <p>
         <example><![CDATA[15 > 7]]></example>
        </p>
        <p>
         will result in the text value "1" (true),
         and:
        </p>
        <p>
         <example><![CDATA["abc" > "ABC"]]></example>
        </p>
        <p>
         will result in the text value "" (false) because they are equal when
         converted to lowercase.
        </p>
      </description>
      </item>
      <item>
       <name code="true">==
!=
===
!==</name>
       <description>
        <p>
         Equal, not equal, text equal, and text not equal.
        </p>
        <p>
         The equal and not equal comparison operators attempt to convert 
         the value to their left and 
         the value to their right to a number ("" is treated as zero), 
         or else they are left as text.
         If both values are numeric then the test is a numeric comparison.
         If either value is not convertible to a number then the test
         will be the text comparison of the two values converted to lower-case.
         The result is the text value "1" for true and "" for false.
         For example: 
        </p>
        <p>
         <example><![CDATA[15 == "15.00"]]></example>
        </p>
        <p>
         will result in the text value "1" (true),
         and:
        </p>
        <p>
         <example><![CDATA["abc" != "ABC"]]></example>
        </p>
        <p>
         will result in the text value "" (false) because they are equal when
         converted to lowercase.
        </p>
        <p>
         Text equal and text not equal comparison operators treat both 
         values as text and are case-sensitive.
         The result is the text value "1" for true and "" for false.
         For example: 
        </p>
        <p>
         <example><![CDATA[15 === "15.00"]]></example>
        </p>
        <p>
         will result in the text value "" (false),
         and:
        </p>
        <p>
         <example><![CDATA["abc" !== "ABC"]]></example>
        </p>
        <p>
         will result in the text value "1" (true).
        </p>
      </description>
      </item>
      <item>
       <name code="true"><![CDATA[&&]]>
||</name>
       <description>
        <p>
         "And", and "or".
        </p>
        <p> 
         "And" and "or" attempt treat the values to their left and right 
         as false ("") or true (non-blank).
         The results are either "1" (true) or "" (false).
         "And" is true if both values are true.
         "Or" is true if either value is true.
         For example: 
        </p>
        <p>
         <example><![CDATA[2 < 3 && 4 < 3]]></example>
        </p>
        <p>
         will result in "" (false), while: 
        </p>
        <p>
         <example><![CDATA[2 < 3 || 4 < 3]]></example>
        </p>
        <p>
         will result "1" (true).
        </p>
      </description>
      </item>
     </list>
    </p>
   </description>
  </section>
  <section>
   <title>Statements</title>
   <description>
    <p>
     A function written in TPL is made up of one or more statements.
     Each statement goes on its own line.
    </p>
    <p>
     For example, this is an assignment statement followed by 
     an IF statement, another assignment statement, and an ENDIF statement: 
     </p>
    <p>
     <example><![CDATA[a = len(b)
IF a > 10
  c = "long"
ENDIF]]></example>
    </p>
    <p>
     To aid readability, statements may be extended to more than
     one line by ending a line with a "\" character.
     The newline character after the "\" (and the "\") will be ignored.
     Additionally, to provide for *[comments]*, any characters after an 
     apostrophe (') up until the end of the line will be ignored.
    </p>
    <p>
     This example uses both a continued line and a comment: 
     </p>
    <p>
     <example><![CDATA[IF a >= 10 && \
   a < 20 ' See if a is within range]]></example>
    </p>
    <p>
     There are three types of statements: *[Expression Statements]*, 
     *[Assignment Statements]*, and *[Keyword Statements]*.
    </p>
    <p>
     An *[Expression Statement]* is just a plain expression on a line by itself.
     Normally, when used as part of multi-line code, this type of statement
     would be a function call for the purpose of the side-effects of the call.
     (Since normal operators like "+" and "-" have no side-effects, and the value
     of expression statements are not used once executed,
     statements like "2 + 2" are relatively meaningless.)
    </p>
    <p>
     An example of an expression statement, which uses the 
     built-in function "showWarning", is:
    </p>
    <p>
     <example><![CDATA[showWarning("Value \"" & #field1 & "\" is out of range. Please try again.")]]></example>
    </p>
    <p>
     An *[Assignment Statement]* is similar to assignment statements in many
     other computer languages.
     It consists of a left-side reference which will receive 
     a value, as assignment operator, and a right-side expression.
     The right-side expression is evaluated and then the left-side reference
     is used by the assignment operator.
    </p>
    <p>
     Some examples of assignment statements are:
    </p>
    <p>
     <example><![CDATA[' Set value of local name v1 to "4":
v1 = 2 + 2

' Set field z of the 1st item in data group array1 to "red":
#array1[0].z = "red"
]]></example>
    </p>
    <p>
     The left-side must evaluate to a reference to a name in 
     a name/value pair of an object or an item in an array.
     It may not be a plain value, such as a text or numeric
     constant, or an expression with operators.
     If it refers to a name that is not already defined 
     within an object, then that name will be defined.
     If it refers to an element in an array that is not
     already defined within an existing array, that element will be defined.
    </p>
    <p>
     There are four different assignment operators:
    </p>
    <p>
     <list>
      <item>
       <name code="true">a = b</name>
       <description>
        <p>
         Assigns the value of the expression on the right to
         the reference on the left.
         Note that the expression on the right may be a scalar 
         value or a reference to an object or array.
         If it's a reference, the reference to the object is used.
        </p>
        <p>
         For example: 
        </p>
        <p>
         <example><![CDATA[a = 2 + 2      ' Sets local name a to "4"
b = array1[0]  ' Sets b to an object with x=10 and y=20
b.x = 5        ' array1[0].x is now "5"
c = array1     ' Sets c to an array
c[0].y = 6     ' array1[0].y is now "6"]]></example>
        </p>
       </description>
      </item>
      <item>
       <name code="true">a += b</name>
       <description>
        <p>
         Adds the value of the expression on the right to
         the current value referenced on the left
         and then assigns that sum to
         the reference on the left.
        </p>
        <p>
         For example: 
        </p>
        <p>
         <example><![CDATA[a = 1   ' Sets local name a to "1"
a += 3  ' Sets a to "4"]]></example>
        </p>
       </description>
      </item>
      <item>
       <name code="true">a -= b</name>
       <description>
        <p>
         Subtracts the value of the expression on the right from
         the current value referenced on the left
         and then assigns that difference to
         the reference on the left.
        </p>
        <p>
         For example: 
        </p>
        <p>
         <example><![CDATA[a = 10  ' Sets local name a to "10"
a -= 3  ' Sets a to "7"]]></example>
        </p>
       </description>
      </item>
      <item>
       <name code="true">a <![CDATA[&]]>= b</name>
       <description>
        <p>
         Concatenates the current text value referenced on the left 
         with the text value of the expression on the right 
         and then assigns that combination to
         the reference on the left.
        </p>
        <p>
         For example: 
        </p>
        <p>
         <example><![CDATA[a = "test"  ' Sets local name a to "test"
a &= "ing"  ' Sets a to "testing"]]></example>
        </p>
       </description>
      </item>
     </list>
    </p>
    <p>
     A *[Keyword Statement]* is a mixture of one or more keywords 
     and zero or more expressions.
     The keywords are case-insensitive text which are distinguished 
     from the same letters used as field, variable, and function names 
     by the syntax of the statement.
     Some keyword statements consist of a single, standalone keyword,
     such as "ENDIF" while others intersperse keywords and expressions, 
     such as "RETURN 15".
     The style of this documentation is to show the keywords in all 
     caps, but lower-case or mixed-case may be used if desired.
    </p>
    <p>
     The statements for use within multi-line user code are:
    </p>
    <p>
     <list>
      <item>
       <name code="true">IF condition
ELSE
ELSEIF condition
ENDIF</name>
       <description>
        <p>
         An IF statement is used to execute or skip other statements 
         depending upon the results of a conditional expression.
         It works in conjunction with an ENDIF statement and 
         optional ELSE and ELSEIF statements which follow it.
        </p>
        <p>
         The initial IF keyword is followed on the line by 
         an expression.
         If the expression is true (not "") then the statements 
         immediately following the IF statement are executed
         up until an ELSEIF or ELSE statement is encountered.
         Then all statements are skipped until an ENDIF is encountered.
        </p>
        <p>
         If the IF condition expression is false ("") then 
         the statements immediately following the IF statement are 
         skipped until either an ELSEIF or ELSE statement is encountered.
         If an ELSEIF is encountered, then the conditional expression 
         following that keyword on the line is executed and 
         the process starts again.
         If an ELSE is encountered, then all statements following 
         it are executed.
         If an ENDIF is encountered execution resumes.
        </p>
        <p>
         An IF statement may be followed by any number of 
         ELSEIF statements, but only one ELSE statement.
         All ELSEIF statements must precede the ELSE statement,
         if present.
         There must be a matching ENDIF statement at the end
         of the statements whose execution is controlled by the
         IF, ELSEIF, and ELSE statements.
        </p>
        <p>
         IF statements may be nested. That is, the 
         statements between an IF statement and the ENDIF
         may include additional IF/ENDIF sequences, with 
         each ENDIF corresponding to the closest open IF.
        </p>
        <p>
         For example: 
        </p>
        <p>
         <example><![CDATA[msg = "There "
IF count==0
  msg &= "are no items"
ELSEIF count==1
  msg &= "is one item"
ELSE
  msg &= "are " & count & " items"
ENDIF
]]></example>
        </p>
       </description>
      </item>
      <item>
       <name code="true">FOR v TO e
FOR v TO e STEP s
CONTINUE
EXITFOR
ENDFOR</name>
       <description>
        <p>
         The FOR and ENDFOR statements bracket a series of statements 
         and control the repeated execution of those statements.
         (This process is commonly known as "looping" through those statements.)
         In addition, FOR and ENDFOR control the repeated incrementing of 
         the value of a Looping Variable that may be used to differentiate 
         each pass through those statements and determine when 
         to stop executing the loop.
        </p>
        <p>
         The FOR statement includes the keyword FOR, Looping Value
         Expression "v", the keyword TO, Ending Value Expression "e",
         and the optional combination of keyword STEP with 
         Step Value Expression "s". 
        </p>
        <p>
         The Looping Value Expression is executed before the first
         time through the loop.
         A Looping Value Expression is either an assignment statement
         whose left side will then be used as the Looping Variable,
         or an expression that results in something that could be on 
         the left side of an assignment statement which will be 
         used as the Looping Variable and already has a value.
        </p>
        <p>
         The Ending Value Expression is executed before each loop 
         execution. It is compared numerically to the 
         Looping Variable's value. If the Looping Variable's value 
         is less than or equal to the Ending Value Expression 
         the statements between the FOR and ENDFOR statements 
         are executed.
         If the Looping Variable's value is greater than the 
         Ending Value Expression the statements up to and including 
         the matching ENDFOR statement are skipped and execution 
         will continue with the statement following the ENDFOR 
         statement.
        </p>
        <p>
         When the ENDFOR statement is encountered in execution, the Step Value 
         Expression is evaluated.
         That value, the Step Value, is used to increment the Looping Variable's value.
         (If there is no STEP keyword, or if the value is zero or
         non-numeric, the Step Value is assumed to be 1.)
         The Looping Value test is then performed to determine whether
         execution of the loop is to continue or be ended.
         If execution is to continue, it continues with the first statement 
         after the FOR statement. If execution of the loop is to be ended, 
         execution continues with the first statement after the ENDFOR statement.
        </p>
        <p>
         Note that if the Step Value is negative, the Looping Value is
         appropriately decremented and the ending test will
         be inverted so that Looping Values less than the Ending Value 
         will end looping and Looping Values greater than or equal to 
         the Ending Value will continuing looping.
        </p>
        <p>
         Executing a CONTINUE statement in a FOR loop will end that 
         trip through the loop and act as if an ENDFOR statement was 
         encountered, incrementing and testing the Looping Value. 
        </p>
        <p>
         Executing an EXITFOR statement in a FOR loop will end that 
         execution of the loop and skip to the statement following 
         the FOR loop's ENDFOR statement. 
        </p>
        <p>
         For example: 
        </p>
        <p>
         <example><![CDATA[
' Calculate the sum of array1's x values
sum = 0
FOR i=1 TO len(array1)
  sum += array1[i-1].x
ENDFOR

' Reverse characters in a text value
txt = "Testing"
reverse = ""
FOR i=len(txt)-1 TO 0 STEP -1
  reverse &= txt[i]
ENDFOR
' Result is reverse="gnitseT"]]>
</example>
        </p>
       </description>
      </item>
     </list>
    </p>
   </description>
  </section>
  <section>
   <title>Functions</title>
   <description>
    <p>
     Like most computer languages, TPL expressions may make use of functions.
     Functions are included within an expression in most places where a 
     value may appear.
     They consist of a name followed by zero or more expressions (called "arguments")
     within parenthesis,
     separated from each other by commas.
     The function returns a result that may be further used in an expression.   
    </p>
    <p>
     For example, here is an example using the math function "pow": 
    </p>
    <p>
     <example>a = 3
b = pow(2,1+a)+1 ' 2*2*2*2+1 = 17</example>
    </p>
    <p>
     The returned value may be an object or array.
     That value may be saved and the name/value pairs or elements may be used.   
    </p>
    <p>
     For example: 
    </p>
    <p>
     <example>' Assume this User-Defined Function:
FUNCTION @example1
  x = obj()     ' Set x to an empty object
  x.a = 1       ' Set name a in x to 1 
  x.b = 2       ' Set name b in x to 2
  return x
ENDFUNCTION

a = @example1() ' a gets an object
c = a.a + a.b   ' c gets "3"</example>
    </p>
    <p>
     There are two main classes of functions: *[Built-in Functions]* 
     and *[User-Defined Functions]*.
     Built-in Functions are part of the TPL implementation. 
     Their names always start with an alphabetic character.
     For example, "len" is the name of a function that returns 
     the number of elements in an array value or characters in a text value.
     User-defined functions are written by the user of TPL (the person 
     who defines form types and uses the TransForm Designer in TransForm Central)
     as a series of TPL statements bracketed by FUNCTION and 
     ENDFUNCTION statements.
     The names of user-defined functions always start with the "*[@]*" character.
     This way, there is no chance that a person will create a user-defined 
     function whose name will conflict with that of a built-in function that they do not
     know about or that is added to the system at a later point. 
    </p>
    <p>
     Some functions have side-effects that are specific to the TransForm system.
     For example, a function may set a value in system data, access a
     server on the Internet, or display a message on the screen.
     Sometimes functions like these may appear by themselves as an Expression Statement
     and only return a meaningless value, such as "". Other times they may
     return an object with information (including any error information) which
     would then need to be assigned to a variable for further processing.
    </p>
    <p>
     The value of arguments may be text or other simple values, or they may be 
     JSON-style objects including arrays.
     The invoked function may read the value of all arguments.
     The invoked function may also reference and set name/value pairs within 
     object arguments and elements within array arguments.
    </p>
    <p>
     User Functions may access their arguments using the "args()" function.
     The value of "args(1)" is the first argument (if present), "args(2)" the second, etc.
     The "argslen()" function returns the number of arguments for a particular call.
     The value of "args(0)" is the name of the function that was invoked.
    </p>
    <p>
     For example: 
    </p>
    <p>
     <example>' Assume this User-Defined Function:
FUNCTION @example2
  x = args(1) ' First argument
  y = args(2) ' Second argument (an object)
  return x + y.x
ENDFUNCTION

a = @example2(array1[0].x, array1[1]) ' a gets "25"</example>
    </p>
    <p>
     References that may appear on the left side of an 
     assignment statement, sometimes called "*[L-Values]*" in Computer Science 
     (with the "L" standing for "Left"), may be used as arguments.
     Some functions may set new values for those passed as L-Values as needed.
    </p>
    <p>
     For example: 
    </p>
    <p>
     <example>' Assume this User-Defined Function:
FUNCTION @example3
  a1 = args(1)          ' Copy original value
  args(1) = "New value" ' Assign new value
  return a1             ' Return original
ENDFUNCTION

a = "Old value"
b = @example3(a) ' b gets "Old value", a is "New value"</example>
    </p>
    <p>
     A special class of functions are those that handle the different "*[ON *Events]*": the *[ON Functions]*.
     Unlike regular User-Defined Functions, which are bracketed by 
     FUNCTION and ENDFUNCTION statements,
     the ON Functions are bracketed by ON and ENDON statements.
     The names all start with the "*[*]*" character to prevent naming conflicts.
    </p>
    <p>
     There are several classes of ON *Events, each with their own naming convention for
     ON Functions and their own arguments:
    </p>
    <p>
     <list>
      <item>
       <name code="true">ON *LOAD</name>
       <description>
        <p>
         When a form is opened for editing, the ON *LOAD function, if there is one in the code, is 
         invoked. The only argument is arg(0), the name. 
         Any changes made to the form data by the ON *LOAD function will affect 
         the displayed form.
        </p>
        <p>
         One use of an ON *LOAD function is to load global data that is used elsewhere 
         in the form.
         For example, loading data for use in List Expressions 
         for List fields.
         List Expressions use No Wait Execution, so may not access databases or perform 
         Ajax requests.
         ON *LOAD does not require No Wait Execution, so may access those forms of data and 
         then store the results as a global data value.         
        </p>
        <p>
         In this example, the ^lastLoaded global data item is given a new value each time 
         a form instance is opened for edit: 
        </p>
        <p>
         <example><![CDATA[ON *LOADED
  ^lastLoaded = now()
ENDON]]></example>
        </p>
        <p>
         The ^lastLoaded could then, for example, be used in a TPL Template
         in the title of a field, or used to initialize a value in an ON *editor handler.
        </p>
      </description>
      </item>
      <item>
       <name code="true">ON *FINISHED</name>
       <description>
        <p>
         When the user switches from edit a form back to the list of forms, 
         the ON *FINISHED function, if there is one in the code, is 
         invoked. The only argument is arg(0), the name. 
         Any changes made to the form data by the ON *FINISHED function will affect 
         the saved form.
        </p>
        <p>
         In this example, the #lastDone field is given a new value each time 
         a form instance is finished: 
        </p>
        <p>
         <example><![CDATA[ON *FINISHED
  #lastDone = now()
ENDON]]></example>
        </p>
        <p>
         In addition to when the DONE button above the Form Details is tapped, 
         the ON *FINISHED event happens when the user duplicates a form  
         and when a Change Status button is pressed or the Change Status menu 
         item on the Form Details Menu is used.
        </p>
        <p>
         The ON *FINISHED event is not guaranteed to be invoked in all situations.
         For example, a user could not use the DONE button, terminated the app 
         from running, and then restart, starting with the Forms List.
         The form data would probably be intact but the *FINISHED would not have 
         been invoked.
        </p>
      </description>
      </item>
      <item>
       <name code="true">ON *editor</name>
       <description>
        <p>
         When the user brings up a Form Editor to enter or modify field data, 
         an ON *editor event occurs. 
         This happens in both the case of switching from the Form Details as well 
         as when switching from one editor to another.
        </p>
        <p>
         To handle an ON *editor event, the code is searched for a matching ON Function.
         There are three types of ON Function names that will match. 
        </p>
        <p>
         First, a search is performed for an ON Function with a name in the form 
         of "*[*editor_fieldpath]*". "fieldpath" consists of the Data Group array names 
         of containing Data Groups, if any, followed by the field name,
         all separated by "," characters. 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *editor_field1
ENDON

ON *editor_array1,x
ENDON]]></example>
        </p>
        <p>
         If no ON Function is found with that name, a search is performed for an ON Function 
         with a name in the form of "*[*editor_fieldname]*", where fieldname is 
         the name of the field. 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *editor_field1
ENDON

ON *editor_x
ENDON]]></example>
        </p>
        <p>
         Finally, if no ON Function is found with that name, a search is performed for an ON Function 
         with a name in the form of "*[*editorCatchAll]*". 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *editorCatchAll
ENDON]]></example>
        </p>
        <p>
         If an appropriate ON Function is found, it is invoked.
        </p>
        <p>
         The args(0) value will be the first name searched (the one 
         with the fieldpath). 
         This lets a single On Function handle a variety of fields 
         and distinguish among them when needed.
        </p>
        <p>
         The args(1) value is an object whose name/value pairs depend upon the type of field.
         For most fields there is a "valueToEdit" value that provides the 
         value of the field at the start of editing. 
         That value may be changed, which will change what appears in the editor.
         For a List field, there is a "qList" value which is an array of 
         objects that make up the list choices, each object with both "value" and 
         "text" name/value pairs.  
        </p>
        <p>
         In this example, the #commatest Text field takes the displayed value 
         and removes comma characters before displaying for edit (there is a 
         companion ON *changed example below): 
        </p>
        <p>
         <example><![CDATA[ON *editor_commatest
  s = args(1)
  v = s.valueToEdit
  v = replaceMatch(v, ",", "")
  s.valueToEdit = v
ENDON]]></example>
        </p>
        <p>
         In this example, the #requestName list takes the list choices in the 
         form type definition and appends the contents of the #custID and #custName 
         fields to the value and text, respectively: 
        </p>
        <p>
         <example><![CDATA[ON *editor_requestName
  s = args(1)
  for i=0 to len(s.qList)-1
    q = s.qList[i]
    name = q.value
    name = #custName & " (" & #custID & ") " & name
    q.text = name
    q.value = name
  endfor
ENDON]]></example>
        </p>
        <p>
         In this case, if #custID was "456" and #custName was "Acme Inc.", and 
         the field definition had text/values of both "Red", "Green",
         and "Blue",
         the displayed list would use "Acme Inc. (456) Red", 
         "Acme Inc. (456) Green", "Acme Inc. (456) Blue".
        </p>
        <p>
         (Note that List fields may use the "List Expression" Form Display Expression 
         to set the text/value pairs used for displaying the value on the Form Details,
         but that expression uses No Wait Execution and, unlike ON *editor, 
         may not access databases nor do Ajax requests. The ON *edit may do those things.
         The results may be saved in global data for use by the List Expression.)
        </p>
      </description>
      </item>
      <item>
       <name code="true">ON *changed</name>
       <description>
        <p>
         When the user finishes using a Form Editor to enter or modify field data,
         and the value has changed, 
         an ON *changed event occurs. 
         This happens in both the case of switching back to the Form Details as well 
         as when switching from one editor to another.
        </p>
        <p>
         To handle an ON *changed event, the code is searched for a matching ON Function.
         There are three types of ON Function names that will match. 
        </p>
        <p>
         First, a search is performed for an ON Function with a name in the form 
         of "*[*changed_fieldpath]*". "fieldpath" consists of the Data Group array names 
         of containing Data Groups, if any, followed by the field name,
         all separated by "," characters. 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *changed_field1
ENDON

ON *changed_array1,x
ENDON]]></example>
        </p>
        <p>
         If no ON Function is found with that name, a search is performed for an ON Function 
         with a name in the form of "*[*changed_fieldname]*", where fieldname is 
         the name of the field. 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *changed_field1
ENDON

ON *changed_x
ENDON]]></example>
        </p>
        <p>
         Finally, if no ON Function is found with that name, a search is performed for an ON Function 
         with a name in the form of "*[*changedCatchAll]*". 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *changedCatchAll
ENDON]]></example>
        </p>
        <p>
         If an appropriate ON Function is found, it is invoked.
        </p>
        <p>
         The args(0) value will be the first name searched (the one 
         with the fieldpath). 
         This lets a single On Function handle a variety of fields 
         and distinguish among them when needed.
        </p>
        <p>
         The new value of the field may be accessed from the field data itself,
         and updated by setting the field data.
        </p>
        <p>
         In this example, the #commatest Text field takes the edited value, 
         rounds to an integer, and adds comma characters (there is a 
         companion ON *editor example above): 
        </p>
        <p>
         <example><![CDATA[ON *changed_commatest
  v = #commatest
  v = formatNumber(v, "#,##0]")
  #commatest = v
ENDON]]></example>
        </p>
      </description>
      </item>
      <item>
       <name code="true">ON *button</name>
       <description>
        <p>
         When the user taps a button on the form, 
         an ON *button event occurs. 
         This happens in both the Form Details as well 
         as a button shown as an editor when switching from one editor to another.
        </p>
        <p>
         To handle an ON *button event, the code is searched for a matching ON Function.
         There are three types of ON Function names that will match. 
        </p>
        <p>
         First, if the button is contained within a Data Group, 
         a search is performed for an ON Function with a name in the form 
         of "*[*button_actionname_fieldpath]*". 
         The "actionname" is the button Action Name, and 
         "fieldpath" consists of the Data Group array names 
         of containing Data Groups separated by "," characters. 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *button_doValidate_array1
ENDON

ON *button_computeSubTotal_array1,subarray
ENDON]]></example>
        </p>
        <p>
         If no ON Function is found with that name, or if the button is not within 
         a Data Group, a search is performed for an ON Function 
         with a name in the form of "*[*button_actionname]*", where actionname is 
         the button's Action Name. 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *button_doValidate
ENDON]]></example>
        </p>
        <p>
         Finally, if no ON Function is found with that name, a search is performed for an ON Function 
         with a name in the form of "*[*buttonCatchAll]*". 
         For example:
        </p>
        <p>
         <example><![CDATA[ON *buttonCatchAll
ENDON]]></example>
        </p>
        <p>
         If an appropriate ON Function is found, it is invoked.
        </p>
        <p>
         The args(0) value will be the first name searched (the one 
         with the fieldpath). 
         This lets a single On Function handle a variety of buttons 
         and distinguish among them when needed.
        </p>
        <p>
         In this example, the button will check that #partID is in the 
         correct form (two digits, a "-", and another digit), and 
         then display the appropriate message: 
        </p>
        <p>
         <example><![CDATA[ON *button_checkPartID
  r = matchOne(#partID, "^\\d\\d-\\d$")
  if r
    msgShowBasic("Validation Succeeded","")
  else
    msgShowWarning(\
      "Validation Error", 
      #partID & " is not valid.")
  endif
ENDON]]></example>
        </p>
      </description>
      </item>
     </list>
    </p>
   </description>
  </section>
  <section>
   <title>Execution</title>
   <description>
    <p>
     TransForm executes various TPL expressions and sequences of statements 
     throughout the Form Editing Lifecycle.
     TPL code is executed synchronously. 
     That is, statements and expressions are executed one at a time, 
     one after another.
     A function executes from start to finish, relinquishing execution 
     to other code only when it calls that code explicitly as a function.
     During the time that the code is executing the user interface 
     does not respond to any user input.
     There is no response to button taps until execution completes.
    </p>
    <p>
     TPL code execution is usually quite quick so the delay in response 
     is not perceptible to the user.
     However, there are two cases where the user may notice a delay.
    </p>
    <p>
     The first case is when the code executes a large number of statements.
     While normal execution on common devices can run at hundreds of thousands 
     of statements per second, with typical placeholder, IF TEST, ON *changed, and 
     other code finishing in milliseconds or less, the form designer 
     may specify code that takes a longer time (perhaps inadvertently).
     Care should be taken to avoid such situations if possible, such as by
     performing long calculations in advance at a time when a delay is more 
     acceptable, such as ON *LOAD.
    </p>
    <p>
     The other case where the user may notice a delay is when a built-in function 
     accesses services that have an inherent delay.
     For example, programmatic interactions over the Internet have 
     communications and server delays due to latency, bandwidth, and load.
     On-device databases may have delays because of complex queries on large 
     data sets.
    </p>
    <p>
     In this second case, TransForm makes the delay visible to the user 
     through a simple "Please wait..." display, such as covering the 
     display with a transparent overlay and showing an animation.
    </p>
    <p>
     In many situations, having a potential long inherent delay is not 
     acceptable.
     Execution at these times is considered "*[No Wait Execution]*" and 
     there is a read-only System Data value ("$nowait") that is true at those times.
     Built-in functions that may have such delays check before execution to 
     see if delays are allowed. 
     If delays are not allowed, the functions return immediately with 
     an appropriate value reflecting that situation, such as an empty 
     value or a specific error indication.
     User-defined functions can check the $nowait value and behave differently,
     such as using a default value instead of checking a database.
    </p>
    <p>
     During the Form Editing Lifecycle, No Wait Execution is required when 
     evaluating placeholders, IF TESTs, and List Expressions and other Form Display Expressions. 
     Waits are allowed when executing ON *LOAD, ON *editor, ON *changed, Button Execution, 
     and ON *FINISHED code.
    </p>
   </description>
  </section>
  <section>
   <title>User-Defined Functions</title>
   <description>
    <p>
     The form designer... (not available yet)
     
    </p>
   </description>
  </section>
  <section>
   <title>Built-in Functions</title>
   <description>
    <p>
     Here is an interim list of the built-in functions:
    </p>
    <p>
     <list>
      <item>
       <name code="true" group="math">abs(number)</name>
       <description>Returns the absolute value of argument.</description>
      </item>
      <item>
       <name code="true" group="math">acos(number)</name>
       <description>Returns the arc cosine value of argument.</description>
      </item>
      <item>
       <name code="true" group="ajax">ajaxGET(url, timeout)</name>
       <description>
        <p>
         Does an Ajax request to "url". Optional timeout of "timeout" milliseconds.
         Returns an object with attribute "error" set to text if an error or "" otherwise.
         If no error, then also includes XMLHttpRequest attributes: status, statusText, 
         timeout, responseType, and responseText.
        </p>
        <p>
         This function is not available during No Wait Execution.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="ajax">ajaxSendRequest(type, url, timeout, body, headers)</name>
       <description>
        <p>The type must be one of "GET", "POST", "PUT", "DELETE", or "HEAD".
        Does an Ajax request of that type to "url".
        Optional timeout of "timeout" milliseconds (defaults to 10 seconds).
        Optional body is the text to use as the body of the request.
        Optional headers is a string made up of one or more lines.
        There are two parts to each line: a header field name and a header value,
        separated by a colon (":").
        The parts are trimmed of space before and after.
        For example:
        </p>
        <p>
          <example>Content-Type: application/x-www-form-urlencoded</example>
        </p>
        <p>
        Returns an object with attribute "error" set to text if an error or "" otherwise.
        If no error, then also includes XMLHttpRequest attributes: status, statusText, 
        timeout, responseType, and responseText.
        </p>
        <p>
         This function is not available during No Wait Execution.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="execution">args(argnum)</name>
       <description>Returns argument number "argnum" to the current function.</description>
      </item>
      <item>
       <name code="true" group="execution">argslen()</name>
       <description>Returns the number of arguments to the current function.</description>
      </item>
      <item>
       <name code="true" group="array">array()</name>
       <description>Returns a new empty array object.</description>
      </item>
      <item>
       <name code="true" group="array">array(val1, val2, ...)</name>
       <description>Returns a new array object with all of the arguments as successive elements.</description>
      </item>
      <item>
       <name code="true" group="array">arrayConcat(array1, value1, value2, ...)</name>
       <description>
        <p>
         Returns a new array, consisting of the elements in array1, followed by
         value1, value2, etc. If any of those values are an array, then the elements
         of that array are each added individually instead of the array itself.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayCopy(array)</name>
       <description>
        <p>
         Returns a new array, consisting of the elements in the argument, which must be an array.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayCopyMap(array, name1in, name1out, name2in,...)</name>
       <description>
        <p>
         Returns a new array of objects, consisting of one object 
         for each object in the array argument.
         The name1in/name1out, name2in/name2out, etc., arguments are pairs of text values that
         specify the name of a name/value pair in the input object and what the name 
         should be for the corresponding output object.
         If the array is viewed as records in a table, this has the effect of
         letting you subset and rename the fields.
        </p>
        <p>
         Here is an example:
        </p>
        <p>
          <example>arrayFilter(#products, "author", "name", "id", "ISBN")</example>
        </p>
        <p>
         Instead of multiple values, a single text argument of input/output pairs 
         separated by commas may be used (the names are trimmed of leading/trailing whitespace):
        </p>
        <p>
          <example>arrayFilter(#products, "author/name,id/ISBN")</example>
        </p>
        <p>
         A single array argument with pairs of elements representing input/output pairs
         may also be used:
        </p>
        <p>
          <example>arrayFilter(#products, array("author", "name", "id", "ISBN"))</example>
        </p>
        <p>
         If the name-in is blank, then the name-out value will be the index of 
         the element in the array (0-origin):
        </p>
        <p>
          <example>arrayFilter(#products, "author", "name", "", "position")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayFilter(array, tests)</name>
       <description>
        <p>
         Tests all of the elements in array, each of which must be an object, returning 
         a new array with all of those objects that met the tests.
         If there are no matches, it returns an array with zero elements.
         It uses the same testing and following arguments as the objTest() function.
         For example:
        </p>
        <p>
          <example>arrayFilter(#products, "price &gt; 30")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayFilterIndex(array, tests)</name>
       <description>
        <p>
         Tests all of the elements in array, each of which must be an object, returning 
         a new array of the indexes (a zero-origined number) of all
         of the elements in the array that met the tests.
         If there are no matches, it returns an array with zero elements.
         It uses the same testing and following arguments as the objTest() function.
         For example:
        </p>
        <p>
          <example>arrayFilterIndex(#products, "price &gt; 30")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayFirst(array, tests)</name>
       <description>
        <p>
         Tests all of the elements in array, each of which must be an object, returning 
         the first of those objects that meets the tests.
         If there are no matches, returns "".
         It uses the same testing and following arguments as the objTest() function.
         For example:
        </p>
        <p>
          <example>arrayFirst(#products, "price &gt; 30")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayFirstIndex(array, tests)</name>
       <description>
        <p>
         Tests all of the elements in array, each of which must be an object, returning 
         the index (a zero-origined number) of the first of those objects that meets the tests.
         If there are no matches, returns -1.
         It uses the same testing and following arguments as the objTest() function.
         For example:
        </p>
        <p>
          <example>arrayFirstIndex(#products, "price &gt; 30")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayIndexOf(array, text, start)</name>
       <description>
        <p>
         Searches the elements of the array argument for the first occurrence
         of an element with the value of text (case-insensitive).
         Returns index within the array (0-origined)
         or "-1" if there is no occurrence.
         If text is "", looks for a blank value.
         Optional start is a number that specifies the index within array
         to start the search. If it is negative, then the start is calculated
         from the end of the array, with -1 being the last element.
        </p>
        <p>
         For example, this would set pos to 1:
        </p>
        <p>
          <example>colors = array("red","orange","yellow")
pos = arrayIndexOf(colors, "orange")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayInsert(array, start, val1, val2,...)</name>
       <description>
        <p>
          Modifies the array by inserting as elements val1, val2, etc., at
          the position indicated by the numeric value start.
          If start is 0, the elements will be inserted at the very beginning of
          the array, if start is 1, they will be inserted right after the first.
          If start is negative, then it refers to a position counting back from 
          the current end of the array's extent, with -1 being to insert as 
          the new last item(s).
        </p>
        <p>
         In addition to modifying the array itself, the function returns 
         a reference to the updated array.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayJoin(array, separator)</name>
       <description>
        <p>
         Returns a text value created by concatenating the text of each 
         element in array, separated by the text of separator.
        </p>
        <p>
         For example, this would set str to "a, b, c, d, e":
        </p>
        <p>
          <example>a = split("abcde", "")
str = arrayJoin(a, ", ")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayObjValue(array, name)</name>
       <description>
        <p>
         The array argument must be an array of objects and name must be a text value.
         Returns a new array with elements that are the values of 
         the name/value pairs with that name in those objects.
        </p>
        <p>
         If the array is viewed as records in a table, this has the effect of
         letting you get an array with the values of one field in all of the records.
         Unlike the arrayCopyMap() function, which returns an array of objects,
         this function returns an array of values.
         Note: The values may be any value in the name/value pairs, so are not
         restricted to text and may be objects or arrays themselves.
        </p>
        <p>
         For example, this would assign a new array to aov,
         with aov[0] set to "x" and aov[1] to "y":
        </p>
        <p>
          <example>a = array()
a[0] = obj("one", "x", "two", "xx")
a[1] = obj("one", "y", "two", "yy")
aov = arrayObjValue(a, "one")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayPop(array)</name>
       <description>
        <p>
          Modifies the array by removing the last element of the array.
        </p>
        <p>
         In addition to modifying the array itself, the function returns 
         the popped value.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayPush(array, val1, val2, ...)</name>
       <description>
        <p>
          Modifies the array by appending the values as additional elements
          to the end of the array.
        </p>
        <p>
         In addition to modifying the array itself, the function returns 
         the resulting length of the array.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayRemove(array, start, count)</name>
       <description>
        <p>
          Modifies the array by removing elements starting with the element position
          specified by start. If start is less than 0, then it specifies a position 
          counting back from the last element of the array, with -1 being the last element.
          The optional count value specifies how many elements to remove.
          If not specified, then just one element will be removed.
        </p>
        <p>
         In addition to modifying the array itself, the function returns 
         a new array containing the deleted elements.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayShift(array)</name>
       <description>
        <p>
          Modifies the array by removing the first element of the array.
        </p>
        <p>
         In addition to modifying the array itself, the function returns 
         the shifted value.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arraySlice(array, start, end)</name>
       <description>
        <p>
          Returns a new array consisting of elements of the array starting with
          the element position specified by start. If start is less than 0, 
          then it specifies a position counting back from the last element of the array, 
          with -1 being the last element.
          The optional end value specifies the element *[one past the elements to return]*.
          That is, the end value element will not be in the returned array.
          If not specified, all elements from start up to and including the end of the array 
          will be returned.
          If end is less than 0, it specifies a position counting back from the 
          last element of the array, with -1 being the last element.
          This means that a value of -1 will return all elements up to but not
          including the last element.
        </p>
        <p>
         This function does not modify array, it just returns copies of elements 
         as a new array.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arraySort(array, direction)</name>
       <description>
        <p>
         Sorts array, modifying array. The direction may be one of: 
         "up", "down", "upnumeric", or "downnumeric".
         For the upnumeric and downnumeric, if two values convert to
         a number then a numeric comparison is done. Otherwise, and 
         for up and down, a locale-specific, non-case-sensitive text 
         comparison is performed.
         Returns a reference to the newly modified array.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>arraySort(#countries, "up")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arraySortObjValue(array, sortspec)</name>
       <description>
        <p>
         Sorts an array of objects, modifying array.
         The sortspec consists of one or more pairs of name/direction.
         The pairs may be sequential pairs of arguments, 
         sequential pairs of elements in an array, 
         or a single text value in the form of "name1/dir1,name2/dir2,...".
         The name specifies a name/value pair in the object that is the 
         value of an element in the array.
         The direction may be one of: 
         "up", "down", "upnumeric", or "downnumeric".
         For the upnumeric and downnumeric, if two values convert to
         a number then a numeric comparison is done. Otherwise, and 
         for up and down, a locale-specific, non-case-sensitive text 
         comparison is performed.
         Returns a reference to the newly modified array.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>arraySortObjValue(#products, "price/upnumeric,name/up")
arraySortObjValue(#products, "price","upnumeric","name","up")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="array">arrayUnshift(array, val1, val2, ...)</name>
       <description>
        <p>
          Modifies the array by inserting the values as additional elements
          at the start of the array. The first val becomes the first element
          of the array, etc.
        </p>
        <p>
         In addition to modifying the array itself, the function returns 
         the resulting length of the array.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="math">asin(number)</name>
       <description>Returns the arc sine value of argument.</description>
      </item>
      <item>
       <name code="true" group="math">atan(number)</name>
       <description>Returns the arc tangent value of argument.</description>
      </item>
      <item>
       <name code="true" group="math">atan2(x, y)</name>
       <description>Returns a value between -PI and PI radians of the angle
        represented by the two values.</description>
      </item>
      <item>
       <name code="true" group="math">ceil(number)</name>
       <description>Returns the closest integer value greater than or equal to the argument.</description>
      </item>
      <item>
       <name code="true" group="math">cos(number)</name>
       <description>Returns the cosine value of argument.</description>
      </item>
      <item>
       <name code="true" group="date">dateDifference(scope, date1, date2)</name>
       <description>
        <p>
         Compares two dates (date1 and date2) and returns an object with information about 
         the difference between the two. The date2 is optional, defaulting to the current 
         date/time.
         The scope specifies which units of time are used. 
         The allowed values are "years", "months", "weeks", "days", "hours", 
         "minutes", and/or "seconds".
         If an array is passed in, the returned object will divide the difference between 
         the scope units. A string with a "-" separating two units will output all units 
         between and including the two specified, for example "weeks-hours" would output "weeks", 
         "days" and "hours".
        </p>
        <p>
         The returned object has name/value pairs for each of the units (years, months, etc.),
         as well as an array named "units" with the units used in the difference, and 
         a value named "before" that is "1" if the first date value is before the second 
         or "" if not.
        </p>
        <p>
         For example, this would result in an object with before set to "1", days 
         set to 2, weeks set to 4, and units an array with the two elements "weeks" and "days":
        </p>
        <p>
          <example>d = dateDifference("weeks-days", "2018-11-01", "2018-12-01")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateGMTOffset()</name>
       <description>
        <p>
         Returns the difference between GMT and the device local timezone, in minutes.
         
        </p>
        <p>
         Note that this is usually the negative of the offset used in text representation 
         of dates.
         For example, executing dateGMTOffset() in the Eastern Standard Time timezone 
         will result in 300 minutes (5 hours), while the difference usually displayed
         in text when including the timezone offset would be "-05:00".
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateFromFormat(text1, format1)</name>
       <description>
        <p>
         Parses text1 as date and time using format1 as a guide. 
         Returns the date value as a plain date value (e.g., "2018-11-01 14:22:08").         
        </p>
        <p>
         The following text in format1 may be used to specify the format:
        </p>
        <p>
         "y" or "yy" for a two-digit year (e.g., 99 for 1999 and 03 for 2003).
         "yyyy" is a full year specification. 
        </p>
        <p>
         "M" is the month as a single digit. 
         "MM" is the month as two digits
         (for instance "01" instead of "1" for January). 
         "MON" is the month as a short name in upper-case. 
         "mon" is the short month name in lower-case. 
         "Mon" is the short month name in title-case. 
         "MONTH" is the month as the full name in upper-case. 
         "month" is the full month name in lower-case. 
         "Month" is the full month name in title-case. 
        </p>
        <p>
         "d" is the day of the month in a single digit. 
         "dd" is the day of the month in two digits. 
         "x" is the day with "st", "rd" or "th". 
         "X" is the day with "ST", "RD" or "TH". 
        </p>
        <p>
         "W" or "WD" is the weekday as a short name in upper-case. 
         "w" or "wd" is the short weekday name in lower-case. 
         "Wd" is the short weekday name in title-case. 
         "WEEKDAY" is the weekday in the full name in upper-case. 
         "weekday" is the full weekday name in lower-case. 
         "Weekday" is the full weekday name in title-case. 
        </p>
        <p>
         "h" is the date time hours. 
         "m" is the date time minutes. 
         "s" is the date time seconds. 
         "0" when placed before a "h", "m" or "s" is padding the value with zeros. 
         "1" is the date time milliseconds to a tenth of a second. 
         "2" is the date time milliseconds to a hundredth of a second. 
         "3" is the date time milliseconds to a thousandth of a second. 
         "hh", "mm" and "ss" can also be used when padding hours, minutes and seconds with zeros. 
         "a" will convert the hours from 12 to 24 based on the 
         meridian as a single character in lower-case. 
         "A" will convert the hours from 12 to 24 based on the 
         meridian as a single character in upper-case. 
         "am" will convert the hours from 12 to 24 based on the 
         meridian as two characters in lower-case. 
         "AM" will convert the hours from 12 to 24 based on the 
         meridian as two characters in upper-case. 
        </p>
        <p>
         "\" (represented by "\\" between double-quotes in text values)
         can be used in front of any of the above placeholders to escape them.
        </p>
        <p>
         The conversion will use the format as a guide, so components 
         expecting one character will often also work with two (e.g., a date
         of 12 with a format of just "d"), case may be ignored, etc.
        </p>
        <p>
         Here are some examples with results (executed in 2018):
        </p>
        <p>
          <example>dateFromFormat("2018-11-01", "yyyy-MM-dd") ' 2018-11-01 00:00:00
dateFromFormat("Feb 15, 2018 6pm", "Mon d, yyyy ham") ' 2018-02-15 18:00:00
dateFromFormat("5/22/18 1:15:22", "M/d/yy h:m:s") '2018-05-22 01:15:22
dateFromFormat("5/22", "M/d") ' 2018-05-22 00:00:00</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateMilliseconds(date1)</name>
       <description>
        <p>
         Returns date1 as the number of milliseconds since midnight January 1, 1970 GMT.
         If the argument is missing the current date/time will be used.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateParts(date1)</name>
       <description>
        <p>
         Returns an object with values for various parts of date1.
         If the argument is missing the current date/time will be used.
        </p>
        <p>
         The name/value pairs will be for: *[dateMilliseconds]* (same as dateMilliseconds()),
         year (e.g., 2018), 
         *[month]* (0-origined, so January is 0, February is 1, etc.),
         *[dayOfMonth]* (1-origined, so the 1st of February is 1), 
         *[dayOfWeek]* (0-origined, so Sunday is 0, Monday is 1, etc.),
         *[dayOfYear]* (1-origined, so January 1 is 1),
         *[daysInMonth]* (so November is 30, February for "2016-02-15" is 29),
         *[weekOfYear]* (1-origined, starting on Mondays, based on the ISO 8601 specification,
         so January 1st is often 1, 
         but sometimes 0 if in week 52 or 53 of the year before),
         *[hours]* (0-23),
         *[minutes]* (0-59),
         *[seconds]* (0-59),
         *[milliseconds]* (0-999),
         *[timeZoneOffset]* (same as dateGMTOffset() of local time).
        </p>
        <p>
         dateMilliseconds is relative to GMT. All of the other values are relative 
         to the local timezone.
        </p>
        <p>
         For example, this will set p.year to 2018, p.month to 10, p.dayOfWeek to 4, 
         p.hours to 0, etc.:
        </p>
        <p>
          <example>p = dateParts("2018-11-01")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">datePlain(date1)</name>
       <description>
        <p>
         Returns date1 in the format "yyyy-MM-dd hh:mm:ss", the way it is normally 
         stored in TPL.
         If the argument is missing the current date/time will be used.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateSame(scope, date1, date2)</name>
       <description>
        <p>
         Checks whether one date is the same as another in a given time scope.
         For example, it can check whether or not two dates are in the same year or month.
         The result is "1" if they are the same within the scope or "" if not.
        </p>
        <p>
         The scope may be one of:  "year", "quarter", "month", "week", 
         "day" (or "date"), "hour", "minute" or "second".
        </p>
        <p>
         If the second date is not provided the current date/time will be used.
         Week is as returned by dateParts().
        </p>
        <p>
         For example, the first results in "1" and the second in "":
        </p>
        <p>
          <example>a = dateSame("month", "2018-11-01", "2018-11-08")
b = dateSame("day", "2018-11-01", "2018-11-08")</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateToFriendly(date1, type, whenShowTime)</name>
       <description>
        <p>
         Returns a text representation of a date/time that is relative to the current 
         date/time and more appropriate for many people in some contexts. 
         This could be, for example, using day names for close dates, and only including 
         parts of the date that are needed when further into the future or past and different 
         than the current date and time.         
        </p>
        <p>
         There are three types of result: *[abbreviated]*, *[standard]*, and *[extended]*.
         (If the type is not present, then "standard" is assumed.)
         An "abbreviated" date is meant to be used to show the date in the 
         shortest friendly format, such as "1st June". 
         A "standard" date is meant to be used to show the date in a slightly more 
         verbose format, such as "Mon 1st June".
         The "extended" date is meant to be used to show the date in a long format, 
         such as "Monday the 1st of June".
        </p>
        <p>
         The whenShowTime argument controls when the time is displayed. 
         A value of *[day]* (the default value if the argument is missing) 
         means that any calendar date that is 
         within the range of relative days will show the time, 
         such as "next Wednesday at 2:00pm" but not "1st Jun". 
         A whenShowTime value of *[month]* will show the time for all dates within the month, 
         a value of *[year]* will show the time for all dates within the year, 
         and a value of *[always]* will always show the time.
         A value of *[never]* will never show the time.
         For all of these, only the first letter is checked, so "never" and "n" are the same.
        </p>
        <p>
         In this example, assume that the current date/time is 
         1:15pm, November 14, 2018:
        </p>
        <p>
          <example>d = dateToFriendly("2018-12-01") ' Sat the 1st of Dec
d = dateToFriendly("2018-11-12 15:20:00", "e", "d") ' last Monday at 3:20pm
d = dateToFriendly("2018-10-12 15:20:00", "s", "d") ' Fri the 12th of Oct
d = dateToFriendly("2018-10-12 15:20:00", "a", "y") ' 12th of Oct at 3:20p</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateToFriendlyDifference(date1, detail, scope)</name>
       <description>
        <p>
         Returns a text representation of the amount of time date1 is compared to the current 
         date/time that is more appropriate for many people than just showing the date/time 
         itself.
         This could be, for example, using something like "3 days ago", and only including 
         more detailed parts of that difference that are significant, such as "3 days ago"
         or "2 months ago" 
         instead of "3 days 2 hours 5 minutes ago".         
        </p>
        <p>
         The detail argument is a number that specifies the level of detail, that is
         the maximum number of units of time shown. 
         For example, a value of 1 would return "3 days ago" or "in 1 hour", 
         while a value of 2 might show "3 days 2 hours ago" or "in 1 hour 5 minutes". 
         If the argument is missing the value 1 will be used.
        </p>
        <p>
         The scope argument is used to set the granularity of the units of time provided.
         For instance, setting it to a value of "years-days" will only show the difference 
         in days, week, months, and years if needed, but never in hours, minutes or seconds. 
         If the given scope results in a relative date that is the same, 
         then the corresponding "same" text for the smallest unit is used. 
         This means that if the smallest unit of comparison is "weeks", 
         and the date is within a week of the current date, then the text returned 
         would be "this week". 
        </p>
        <p>
         In this example, assume that the current date/time is 
         1:15pm, November 14, 2018:
        </p>
        <p>
          <example>d = dateToFriendlyDifference("2018-10-01") ' 1 month ago
d = dateToFriendlyDifference("2018-11-01") ' 1 week ago
d = dateToFriendlyDifference("2018-10-01", 2) ' 1 week 6 days ago
d = dateToFriendlyDifference("2018-11-01", 2, "year-month") ' this month
d = dateToFriendlyDifference("2018-12-16 09:00", 5, "days-hours") ' in 31 days 19 hours</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateToFormat(date1, format1)</name>
       <description>
        <p>
         Returns a text representation of date1 using format1 as a guide. 
        </p>
        <p>
         The following text in format1 may be used to specify the format 
         (it is analogous to dateFromFormat()):
        </p>
        <p>
         "y" or "yy" for a two-digit year (e.g., 99 for 1999 and 03 for 2003).
         "yyyy" is a full year specification. 
        </p>
        <p>
         "M" is the month as a single digit if possible. 
         "MM" is the month as two digits 
         (for instance "01" instead of "1" for January). 
         "MON" is the month as a short name in upper-case. 
         "mon" is the short month name in lower-case. 
         "Mon" is the short month name in title-case. 
         "MONTH" is the month as the full name in upper-case. 
         "month" is the full month name in lower-case. 
         "Month" is the full month name in title-case. 
        </p>
        <p>
         "d" is the day of the month in a single digit if possible. 
         "dd" is the day of the month in two digits. 
         "x" is the day with "st", "rd" or "th". 
         "X" is the day with "ST", "RD" or "TH". 
        </p>
        <p>
         "W" or "WD" is the weekday as a short name in upper-case. 
         "w" or "wd" is the short weekday name in lower-case. 
         "Wd" is the short weekday name in title-case. 
         "WEEKDAY" is the weekday in the full name in upper-case. 
         "weekday" is the full weekday name in lower-case. 
         "Weekday" is the full weekday name in title-case. 
        </p>
        <p>
         "h" is the date time hours. 
         "m" is the date time minutes. 
         "s" is the date time seconds. 
         "0" when placed before a "h", "m" or "s" is padding the value with zeros. 
         "1" is the date time milliseconds to a tenth of a second. 
         "2" is the date time milliseconds to a hundredth of a second. 
         "3" is the date time milliseconds to a thousandth of a second. 
         "hh", "mm" and "ss" can also be used when padding hours, minutes and seconds with zeros. 
         "a" will convert the hours from 24 to 12 based on the 
         meridian and result in a single character in lower-case. 
         "A" will convert the hours from 24 to 12 based on the 
         meridian and result in a single character in upper-case. 
         "am" will convert the hours from 24 to 12 based on the 
         meridian and result in two characters in lower-case. 
         "AM" will convert the hours from 24 to 12 based on the 
         meridian and result in two characters in upper-case. 
        </p>
        <p>
         "\" (represented by "\\" between double-quotes in text values)
         can be used in front of any of the above placeholders to escape them.
        </p>
        <p>
         Here are some examples with results (executed in 2018):
        </p>
        <p>
          <example>dateFromFormat("2018-11-01", "yyyy-MM-dd") ' 2018-11-01 00:00:00
dateFromFormat("Feb 15, 2018 6pm", "Mon d, yyyy ham") ' 2018-02-15 18:00:00
dateFromFormat("5/22/18 1:15:22", "M/d/yy h:m:s") '2018-05-22 01:15:22
dateFromFormat("5/22", "M/d") ' 2018-05-22 00:00:00</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="date">dateTZ(date1)</name>
       <description>
        <p>
         Returns date1 in the format "yyyy-MM-ddThh:mm:ss-hh:mm", which is 
         a format specified by ISO 8601 for a date/time that includes 
         timezone offset.
         The "-hh:mm" part is replaced by the offset (with sign "+" or "-")
         from GMT for local time.
         If the argument is missing the current date/time will be used.
        </p>
        <p>
         For example (if executed in a device set to Eastern Standard Time):
        </p>
        <p>
          <example>dateTZ("2018-11-01 10:00") ' 2018-11-01T10:00:00-0:500</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="string">decodeURI(text)</name>
       <description>
        Turns URI-encoded text back into the pre-encoded text.
        This is the companion to the encoding done by encodeURI().
        Returns the decoded value.
       </description>
      </item>
      <item>
       <name code="true" group="string">decodeURIComponent(text)</name>
       <description>
        Turns URI Component-encoded text back into the pre-encoded text.
        This is the companion to the encoding done by encodeURIComponent().
        Returns the decoded value.
       </description>
      </item>
      <item>
       <name code="true" group="math">degrees(number)</name>
       <description>
        Takes a number in radians and returns a value in degrees.
       </description>
      </item>
      <item>
       <name code="true" group="math">E()</name>
       <description>Returns the value of e (2.718...).</description>
      </item>
      <item>
       <name code="true" group="string">encodeURI(text)</name>
       <description>
        <p>
         Encodes text by replacing certain characters with escape sequences
         that are part of the specification (RFC2396) for a URI (Uniform Resource Identifier).
         (URIs include URLs for Internet addresses as well as identifiers for
         access to files and other resources.)
         Returns the encoded value.
         Decoding the result may be done by decodeURI().
        </p>
        <p>
         This function is useful, for example, for creating the URL for HTML or Ajax requests.
        </p>
        <p>
         Certain characters needed to be unescaped for URIs (such as ":", "?", and "&amp;")
         are not escaped.
        </p>
        <p>
         To encode just a component of a URI, such as a query parameter value, the
         encodeURIComponent() function may be used which encodes a wider range of characters.
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="string">encodeURIComponent(text)</name>
       <description>
        <p>
         Encodes text by replacing certain characters with escape sequences
         that are part of the specification (RFC2396) for a URI (Uniform Resource Identifier).
         (URIs include URLs for Internet addresses as well as identifiers for
         access to files and other resources.)
         Returns the encoded value.
         Decoding the result may be done by decodeURIComponent().
        </p>
        <p>
         This function is useful, for example, for assembling the body of Ajax POST requests.
        </p>
        <p>
         Note that certain characters that need to be unescaped for URIs 
         (such as ":", "?", and "&amp;") are escaped by this function.
         To encode a URI without encoding those characters, use encodeURI().
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="math">exp(number)</name>
       <description>Returns e raised to the power of the value of argument.</description>
      </item>
      <item>
       <name code="true" group="math">floor(number)</name>
       <description>Returns the closest integer value less than or equal to the argument.</description>
      </item>
      <item>
       <name code="true" group="number,string">formatNumber(value1, format1)</name>
       <description>
        <p>
         Returns a text representation of numeric value1 using format1 as a guide.
        </p>
        <p>
         The formatting is specified by characters in format1. 
         Certain characters have special 
         meaning and relate to the digits that make up the number. 
         Other characters before and after those special characters are included in the results 
         verbatim.
        </p>
        <p>
         For example, this results in "$12.30":
        </p>
        <p>
          <example>formatNumber(12.3, "$#,##0.00")</example>
        </p>
        <p>
         The numeric value being formatted is assumed to be composed of two parts: The integer part and the fractional part 
         (the part after a decimal).
         Likewise, the format specification for a value has two parts, one for the integer and one for the fraction.
         Each format part is made up characters ("#", "0", "_", and/or "*") that represent digits.
         Between the format for the integer part and the fraction there is a character that separates them 
         and is put in the result as a decimal separator.
         It can be any character, but the decimal point character of the locale is usually used (e.g., "." in 
         the USA, "," in some other countries).
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1234.56, "#.##") ' 1234.56
formatNumber(1234.56, "#,##") ' 1234,56</example>
        </p>
        <p>
         The character "]" specifies the end of the integer portion and that the fraction should not be shown.
         The value will be rounded to an integer, and characters after the "]" will appear as themselves.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1234.56, "#]") ' 1235
formatNumber(1234.56, "#]##") ' 1235##</example>
        </p>
        <p>
         The character "[" in position to the left of the "]" specifies 
         rounding the integer portion to end with that many zeroes.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1357.9, "#[##]") ' 1400</example>
        </p>
        <p>
         In the specification for the integer portion,
         the characters "#", "0", and "_" represent one digit of the value, starting from the 
         decimal position and going left.
         If a "#" is present in the format and a digit is present in the corresponding position 
         in the value, then the digit is put in the result. Otherwise that position is skipped.
         For example, the value "12" and a format of "####" would result in "12".
         If a "0" is present in the format and a digit is present in the corresponding position
         in the value, then the digit is put in the result. Unlike the "#", though, if there 
         isn't a digit in that position then a zero is used. For example, "12" and "0000" 
         would result in "0012".
         The "_" is similar to "0" except a space will be output if there isn't a 
         digit in that position.
        </p>
        <p>
         If there are more integer digits in the value than present in the format specification, 
         the additional digits will be put in the result.
        </p>
        <p>
         A character within the specification for the integer portion is treated as the grouping character.
         The number of digit position characters (2 or more) to the right of the grouping character determines 
         the size of a "group". 
         The number of digit positions to the left of the grouping character (of which there must be at least one)
         is not used to determine the size of the group.
         The grouping is repeated when producing the result if needed.
         This is usually used as the thousands separator.
         (Note: There must be a character specifying the end of the integer portion (e.g., "." or "]") 
         for there to be a grouping character, otherwise the character would be treated as the decimal separator.)
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1234.56, "#,###.##") ' 1,234.56
formatNumber(1234567.89, "#/##]") ' 1/23/45/68</example>
        </p>
        <p>
         The specification for the fraction portion is similar to the integer portion.
         The characters "#", "0", and "_" represent one digit of the value, starting from the 
         decimal position, but going right instead of left.
         If a "#" is present in the format and a significant digit is present in the corresponding position 
         in the value, then the digit is put in the result. Otherwise that position is skipped.
         (Trailing zeroes are assumed to not be significant.)
         For example, the value "1.2" and a format of "#.###" would result in "1.2".
         If a "0" is present in the format and a digit is present in the corresponding position
         in the value, then the digit is put in the result. Unlike the "#", though, if there 
         isn't a digit in that position then a zero is used. For example, "1.2" and "#.000" 
         would result in "1.200".
         The "_" is similar to "0" except a space will be output if there isn't a significant
         digit in that position.
        </p>
        <p>
         If there are more significant fraction digits in the value than present in the format specification, 
         the value will be rounded.
         To show all of the significant fraction digits and not round, use "*" as the fraction part.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1.2345, "#.##") ' 1.23
formatNumber(1.2345, "#.###") ' 1.235
formatNumber(1.2345, "#.*") ' 1.2345</example>
        </p>
        <p>
         The "&lt;" character at the end of the fraction part will round the decimal up (like ceil()).
         The "&lt;" character before the "]" in the integer part will round the integer up.
         The "&gt;" character acts just like the "&lt;" character, but rounds down (like floor()).
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(12.31, "#.#&lt;") ' 12.4
formatNumber(12.39, "#.#&gt;") ' 12.3
formatNumber(12341, "#&lt;#]") ' 12350
formatNumber(12349, "#&gt;#]") ' 12340</example>
        </p>
        <p>
         The characters "-/-" represent the fraction part and display it as a fraction.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1.4, "# -/-") ' 1 2/5
formatNumber(1.35, "# -/-") ' 1 7/20
formatNumber(1.35, "#.# -/-") ' 1 2/5</example>
        </p>
        <p>
         The ";" character separates multiple format specifications.
         If there are two parts, the second specifies how to display a negative value.
         (If there is only one part, negative values display a "-" at the beginning.)
         If there are three parts, the third specified how to display a zero value (original 
         value must be zero, not a rounded one in the other formats).
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(-1.4, "$#.00;($#.00);- -") ' ($4.00)
formatNumber(1.4, "$#.00;($#.00);- -") ' $4.00
formatNumber(0, "$#.00;($#.00);- -") ' - -</example>
        </p>
        <p>
         The "\" character can be used to escape the following character and 
         treat it as a normal format specification character.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatNumber(1234, "Part\#00000") ' Part#01234</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="string">formatText(text1, format1, filler)</name>
       <description>
        <p>
         Returns the characters in text1 using format1 as a guide.
         Useful for adding extra characters and/or padding.
        </p>
        <p>
         Starting with the first character, each character in format1 is
         in turn added to the result.
         Each "_" character in format1 is replaced by successive characters
         from text1.
         The "\" character before another character in format1 causes that 
         character to be added to the result, even if it is "_" or "\".
         If all the characters in text1 are added to the result and format1 
         has additional "_" characters, the optional "filler" text is added
         instead of adding no characters in those positions.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>formatText("6175551212", "(___)___-____") ' (617)555-1212
formatText("157", "Part A\\_______", "*") ' Part A_157***</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="string">indexOf(text1, text2, start)</name>
       <description>
        Searches for the first occurrence of text2 within text1.
        Returns the position within text1 where text2 starts (0-origined)
        or "-1" if there is no occurrence.
        If text2 is "", returns "0".
        Optional start is a number that specifies where in text1 to start
        the search. If it is negative, then the start is calculated from the end of
        the text, with -1 being the last character.
       </description>
      </item>
      <item>
       <name code="true" group="execution">isArray(value)</name>
       <description>Returns the "1" if the argument is an array, "" otherwise.</description>
      </item>
      <item>
       <name code="true" group="execution">isDefined(value)</name>
       <description>
        Returns the "1" if the argument is defined, "" otherwise.
        Values like text and numbers are defined, as well as objects and arrays.
        Array elements that have not been assigned a value are undefined, 
        as are object name/value pairs with undefined values or names that are
        not present.
        In many other functions, undefined values are treated like "" or result in 
        values of "" or zero.
       </description>
      </item>
      <item>
       <name code="true" group="execution">isNumber(value)</name>
       <description>
        Returns the "1" if the argument can be viewed as a number, "" otherwise.
        In some other functions, "" is treated as a number (0), but not in this function.
       </description>
      </item>
      <item>
       <name code="true" group="execution">isObj(value)</name>
       <description>
        Returns the "1" if the argument is an an object, "" otherwise.
        Undefined, values like numbers and text, and arrays are not objects.
       </description>
      </item>
      <item>
       <name code="true" group="json,string">JSONparse(text)</name>
       <description>
        Parses the text argument, looking for a JSON value.
        If the result is a plain text, a quoted string, or a numeric value, 
        the result is that type of value.
        If the result is an object or array, then it will be a reference 
        to a new instance of that type of value.
        Note that in the text representation of JSON, the names 
        of name/value pairs must be quoted strings, and 
        values of the plain text true, false, and null are accepted.
        (Most functions and operators treat the value of null similarly to "" or undefined.) 
       </description>
      </item>
      <item>
       <name code="true" group="json,string">JSONstringify(obj, space)</name>
       <description>
        Converts an object, array, or value to a JSON value and returns it as text.
        The optional space text value can be used to insert indenting white-space 
        into the result. Space should be a string of no more than 10 blanks (e.g., " &#160; ")
        or tabs (e.g., "\t").
       </description>
      </item>
      <item>
       <name code="true" group="array">len(array)</name>
       <description>Returns the number of the highest numbered element in an
        array.</description>
      </item>
      <item>
       <name code="true" group="string">len(text)</name>
       <description>Returns the number of characters in a text value.</description>
      </item>
      <item>
       <name code="true" group="math">ln(number)</name>
       <description>Returns the natural log value of argument.</description>
      </item>
      <item>
       <name code="true" group="math">LN10()</name>
       <description>Returns the natural log of 10.</description>
      </item>
      <item>
       <name code="true" group="math">LOG10E()</name>
       <description>Returns the common log of e.</description>
      </item>
      <item>
       <name code="true" group="math">LOG2E()</name>
       <description>Returns the log base 2 of e.</description>
      </item>
      <item>
       <name code="true" group="string,regex">matchAll(text, regex, options)</name>
       <description>
        Repeatedly applies regular expression regex to the text.
        Options is optional, and may be text with the letters "i" (case-insensitive test)
        and/or "m" (regex "^" and "$" match on newline; use "[\\s\\S]" to match
         any character including newline instead of ".").
        If no match, returns "".
        If any matches, returns a new array with each element being
        successive matches in text.
       </description>
      </item>
      <item>
       <name code="true" group="string,regex">matchOne(text, regex, options)</name>
       <description>
        Applies regular expression regex to the text.
        Options is optional, and may be text with the letters "i" (case-insensitive test)
        and/or "m" (regex "^" and "$" match on newline; use "[\\s\\S]" to match
         any character including newline instead of ".").
        If no match, returns "".
        If any matches, returns a new array with the first element (0-origin) being
        the entire matched text, and each additional element being
        successive parenthetical matches in text.
       </description>
      </item>
      <item>
       <name code="true" group="math">max(number1, number2, ...)</name>
       <description>Returns the value of the largest argument.</description>
      </item>
      <item>
       <name code="true" group="math">min(number1, number2, ...)</name>
       <description>Returns the value of the smallest argument. (-2 is less than -1.)</description>
      </item>
      <item>
       <name code="true" group="math">mod(a, b)</name>
       <description>Rounds both values to integers, and then returns the integer remainder of the first divided by the second.</description>
      </item>
      <item>
       <name code="true" group="msg">msgHideProgress()</name>
       <description>Removes modal message box shown by msgShowProgress(), if any.
        Execution continues immediately. Returns "1".
       </description>
      </item>
      <item>
       <name code="true" group="msg">msgShowBasic(title, body, confirm)</name>
       <description>Displays a modal message box with a title and 
        a body. The button to dismiss will be labeled "OK" if the optional confirm is missing.
        Execution pauses until the user responds.
        Returns "1". This function is not available during No Wait Execution.
       </description>
      </item>
      <item>
       <name code="true" group="msg">msgShowConfirm(title, body, confirm, cancel)</name>
       <description>Displays a modal message box with a title and 
        a body. The button to proceed will be labeled "OK" if the optional confirm is missing
        and the button to cancel will be labeled "Cancel" if the optional cancel is missing.
        Execution pauses until the user responds. Returns "1" for confirm and "" for cancel.
        This function is not available during No Wait Execution.
       </description>
      </item>
      <item>
       <name code="true" group="msg">msgShowConfirmWarning(title, body, confirm, cancel)</name>
       <description>Displays a modal message box with a red title and 
        a body. The button to proceed will be labeled "OK" if the optional confirm is missing
        and the button to cancel will be labeled "Cancel" if the optional cancel is missing.
        Execution pauses until the user responds. Returns "1" for confirm and "" for cancel.
        This function is not available during No Wait Execution.
       </description>
      </item>
      <item>
       <name code="true" group="msg">msgShowProgress(title, body)</name>
       <description>Displays a modal message box with a title, 
        a body, and a spinning icon. There is no button to dismiss.
        Execution continues immediately. Returns "1".
        Use msgHideProgress() to remove the modal message box.
        This function is not available during No Wait Execution.
       </description>
      </item>
      <item>
       <name code="true" group="msg">msgShowThreeButton(title, body, one, two, three)</name>
       <description>Displays a modal message box with a title and a body. 
        The first button to dismiss will be labeled "1" if the optional one is missing.
        The second button to dismiss will be labeled "2" if the optional two is missing.
        The third button to dismiss will be labeled "3" if the optional three is missing.
        Execution pauses until the user responds. Returns the label of the chosen button.
        This function is not available during No Wait Execution.
       </description>
      </item>
      <item>
       <name code="true" group="msg">msgShowWarning(title, body, confirm)</name>
       <description>Displays a modal message box with a red title and 
        a body. The button to dismiss will be labeled "OK" if the optional confirm is missing.
        Execution pauses until the user responds. Returns "1".
        This function is not available during No Wait Execution.
       </description>
      </item>
      <item>
       <name code="true" group="execution">nargs()</name>
       <description>(Deprecated: Use argslen().) Returns the number of arguments to the current function.</description>
      </item>
      <item>
       <name code="true" group="time">now()</name>
       <description>Returns the current date/time as yyyy-mm-dd hh:mm:ss.</description>
      </item>
      <item>
       <name code="true" group="time">nowMilliseconds()</name>
       <description>
        Returns the current date/time as the number of milliseconds since 
        midnight January 1, 1970 GMT.
       </description>
      </item>
      <item>
       <name code="true" group="object">obj()</name>
       <description>Returns a new empty object.</description>
      </item>
      <item>
       <name code="true" group="object">obj(name1, value1, name2, value2, ...)</name>
       <description>
        <p>
         Returns a new object with name/value pairs specified by successive pairs
         of values. The keys are treated as strings and the values are simple values, arrays, 
         or objects. The values may be references to values, objects, or arrays.
        </p>
        <p>
         For example, an object with a "person" value of "Joe", age coming from 
         #age, and children as an array of names, could be created by:
        </p>
        <p>
          <example>obj("person", "Joe", "children", "age", #age, array("Jane", "Nancy"))</example>
        </p>
      </description>
      </item>
      <item>
       <name code="true" group="object">objAssign(value1, value2)</name>
       <description>
        <p>
         Modifies the object referenced by the *[first]* argument, setting the 
         name/value pairs in that first object to values from 
         name/value pairs in the object referenced by the *[second]* argument. 
         If the names are new, they are added; if they already had values, 
         new values will be assigned from the second argument. 
         If the values being assigned are arrays or objects, references are 
         *[not]* assigned. Instead, copies are made and assigned, recursively.
         This is different than many other functions, such as arrayCopy() and 
         arrayCopyMap(), which assign references.
        </p>
        <p>
         Returns a reference to the updated value1.
        </p>
        <p>
         For example, this would end up with o1 being an object with a "person" value of "Joe", 
         age of 42, jobs set to 1, and children as a new array of names not changing c1:
        </p>
        <p>
          <example>c1 = array("Jane", "Nancy")
o1 = obj("person", "Joe", "age", 40, "children",  c1)
c2 = array("Maryjane", "Nancy", "Bob")
o2 = obj("age", 42, "jobs", 1, "children", c2)
objAssign(o1, o2)</example>
        </p>
      </description>
      </item>
      <item>
       <name code="true" group="object">objAssignNew(value1, value2)</name>
       <description>
        <p>
         Modifies the object referenced by the *[first]* argument, adding new 
         name/value pairs to that first object from 
         name/value pairs in the object referenced by the *[second]* argument. 
         That is, if the names are new, they are added; if they already existed, 
         new values will *[not]* be assigned from the second argument. 
         (Contrast with the objAssign() function.)
         If the values being assigned are arrays or objects, references are 
         *[not]* assigned. Instead, copies are made and assigned, recursively.
         This is different than many other functions, such as arrayCopy() and 
         arrayCopyMap(), which assign references.
        </p>
        <p>
         Returns a reference to the updated value1.
        </p>
        <p>
         For example, this would end up with o1 being an object with a "person" value of "Joe", 
         age of 40 (not 42), jobs set to 1, and children as a new array with only two 
         names (Jane and Nancy) that does not change if c1's elements are changed:
        </p>
        <p>
          <example>c1 = array("Jane", "Nancy")
o1 = obj("person", "Joe", "age", 40, "children",  c1)
c2 = array("Maryjane", "Nancy", "Bob")
o2 = obj("age", 42, "jobs", 1, "children", c2)
objAssign(o1, o2)</example>
        </p>
      </description>
      </item>
      <item>
       <name code="true" group="object">objTest(obj, tests)</name>
       <description>
        <p>
         Returns true ("1") or false ("") depending upon whether or not 
         the name/values in object obj pass the tests specified by the other
         argument(s).
         The tests are similar to those used to match records in a table in a
         SQL statement WHERE clause, with some minor but important differences.
        </p>
        <p>
         The tests may be specified by separate successive arguments, each 
         providing an additional component of the test specification, such as 
         as names, operators, and values.
         They may also be specified by elements in a single array, with each 
         successive element corresponding to an additional component of the 
         test specification.
         They may also be specified by a single text value which is then 
         broken up into the components similar to a normal program language 
         expression with normal treatment of spacing.
        </p>
        <p>
         The names (corresponding to field names in SQL) are case-sensitive. 
         The operator names (such as AND, OR, and BETWEEN) that are text are 
         not case-sensitive. 
         The "NOT" operator is not the text word "NOT" but rather the single 
         character "!".
        </p>
        <p>
         These are examples of three different ways to specify the same tests
         on an object with name/value pairs "First", "Second", and "Third":
        </p>
        <p>
          <example>objTest(obj1, "First==\"a\" AND Second BETWEEN 1 AND 5")</example>
        </p>
        <p>
 <example>objTest(obj1, "First", "==", "a", "AND", "Second", "between", "1", "and", "5")</example>
        </p>
        <p>
 <example>tests = array("First", "==", "a", "AND", "Second", "between", "1", "and", "5");
objTest(obj1, tests)</example>
        </p>
        <p>
         The operators are: *[&lt;]*, *[&lt;=]*, *[==]*, *[===]*, *[!==]*, *[!=]*, *[&gt;=]*, *[&gt;]*,
         *[starts]*, *[ends]*, *[notStarts]*, *[notEnds]*, *[contains]*, *[notContains]*,
         *[matches]*, *[matchesCase]*, *[isDefined]*, *[isNotDefined]*, *[isNumber]*, *[isNotNumber]*,
         *[isObj]*, *[isNotObj]*, *[isArray]*, *[isNotArray]*,
         *[between]*, and *[in]*.
        </p>
        <p>
         The non-alphabetic operators are very much like those operators in TPL 
         expressions, with numeric comparisons if both values convert to numbers
         and are case-insensitive for text.
         The === and !== operators are case-sensitive and convert everything to text 
         before comparison. 
        </p>
        <p>
         The STARTS, ENDS, and CONTAINS operators look for a case-insensitive 
         exact match for the first characters in the value, the last characters in 
         the value, and any place within the value. There are corresponding 
         "NOT" versions of each.
        </p>
        <p>
         The MATCHES operator uses a Regular Expression to test the value.
         It is case-insensitive (the "i" modifier), and assumes the "m" modifier.
         The MATCHESCASE operator is case-sensitive, assuming just the "m" modifier.
        </p>
        <p>
         For example, to match values for "line" that start with "the" and 
         have either of the words "fox" or "wolf" within the line, you could use:
        </p>
        <p>
          <example>objTest(obj2, "line", "MATCHES", "^The.*?\\s(fox|wolf)\\s")</example>
        </p>
        <p>
         The BETWEEN operator works like a combination of &gt;= and &lt;= and 
         looks like this (the "and" word is required):
        </p>
        <p>
          <example>objTest(obj3, "quantity BETWEEN 1 AND 10")</example>
        </p>
        <p>
         The IN operator works like multiple "==" tests, separated by OR.
         The second part (after the IN) must be an array of text values:
        </p>
        <p>
          <example>objTest(obj4, "size", "IN", array("medium", "large", "x-large"))</example>
        </p>
        <p>
         The ISDEFINED operator tests whether or not a name/value pair with that 
         name is present. The ISNUMBER operator tests whether the value looks like 
         a numeric value. The ISOBJ and ISARRAY operators test 
         whether or not the value is one of those types. All four of these have 
         no second part, and have "isNot" variants.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>objTest(obj5, "status isNotDefined OR status == \"completed\"")</example>
        </p>
        <p>
         For order of execution, the "!" has the highest precedence, 
         the "AND" next, and "OR" least. 
         Parentheses and the "!" operator may also be used:
        </p>
        <p>
          <example>objTest(obj5, "First==1 AND !(Second==2 OR Third==3)")</example>
        </p>
      </description>
      </item>
      <item>
       <name code="true" group="math">PI()</name>
       <description>Returns the value of pi (3.14159...).</description>
      </item>
      <item>
       <name code="true" group="math">pow(x, y)</name>
       <description>Returns the x to the power of y.</description>
      </item>
      <item>
       <name code="true" group="math">radians(number)</name>
       <description>
        Takes a number in degrees and returns a value in radians.
       </description>
      </item>
      <item>
       <name code="true" group="math">random()</name>
       <description>Returns a random number greater than or equal to 0 and less than 1 as text.</description>
      </item>
      <item>
       <name code="true" group="string">replace(text, match, replacement)</name>
       <description>
        <p>
         Returns a copy of text with all occurrences of match replaced with replacement.
         The searches are case-insensitive.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>a = replace("This IS a test", "is", "x") ' Thxx xx a test</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="string">replaceCase(text, match, replacement)</name>
       <description>
        <p>
         Returns a copy of text with all occurrences of match replaced with replacement.
         The searches are case-sensitive.
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>a = replace("This IS a test", "is", "x") ' Thxx IS a test</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="string,regex">replaceMatch(text, regex, replacement, options)</name>
       <description>
        <p>
         Searches text for matches to regular expression regex.
         Returns a copy of text with all matches replaced with replacement.
         Options is optional, and may be text with the letters "i" (case-insensitive test)
         and/or "m" (regex "^" and "$" match on newline; use "[\\s\\S]" to match
         any character including newline instead of ".").
        </p>
        <p>
         In replacement, the following patterns insert special text: *[$1]*, *[$2]*, etc., 
         insert text that matched the 1st, 2nd, etc., parenthesized subexpression in 
         regex, *[$&amp;]* inserts the entire match to the regex, *[$`]* and *[$']* are 
         the text before and after the entire match (and are probably rarely of use), 
         and *[$$]* inserts a "$".
        </p>
        <p>
         For example:
        </p>
        <p>
          <example>a = replaceMatch("This is a test", "(.)i", "[$1]I") ' T[h]Is[ ]Is a test</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="math">round(number, places)</name>
       <description>
        If the optional places argument is missing, 
        returns the integer closest to the value of argument.
        If the numeric value places is provided, rounds to that number 
        of decimal places. Negative places values specify rounding 
        to the left of the decimal.
        <p>
         For example, the first line sets a to 15, the second to 15.35, and 
         the third to 20:
        </p>
        <p>
          <example>a = round(15.345)
a = round(15.345, 2)
a = round(15.345, -1)</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="math">sin(number)</name>
       <description>Returns the sine value of argument.</description>
      </item>
      <item>
       <name code="true" group="string">split(text, separator)</name>
       <description>Returns an array of "text" broken on character(s) "separator".</description>
      </item>
      <item>
       <name code="true" group="math">sqrt(number)</name>
       <description>Returns the square root value of argument.</description>
      </item>
      <item>
       <name code="true" group="math">SQRT1_2()</name>
       <description>Returns the reciprocal of the square root of 2.</description>
      </item>
      <item>
       <name code="true" group="math">SQRT2()</name>
       <description>Returns the value of square root of 2.</description>
      </item>
      <item>
       <name code="true" group="string">substr(text, start, length)</name>
       <description>
        Returns the length number of characters in text starting at character start (0-origin).
        If length is missing, then all of the rest of the characters in text will be returned.
        If start is negative, then the start is calculated from the end of text, with
        "-1" being the last character, "-2" the next to last, etc.
       </description>
      </item>
      <item>
       <name code="true" group="string">substring(text, start, end)</name>
       <description>
        Returns the characters in text starting at character start (0-origin) up to
        but not including character end (0-origin).
        If end is missing, then all of the rest of the characters in text will be returned.
        If start or end is negative, then the respective values are calculated from the end of text,
        with "-1" being the last character, "-2" the next to last, etc.
       </description>
      </item>
      <item>
       <name code="true" group="math">tan(number)</name>
       <description>Returns the tangent value of argument.</description>
      </item>
      <item>
       <name code="true" group="string">toLowerCase(text)</name>
       <description>
        Returns the the text with all uppercase characters switched 
        to lowercase.
        </description>
      </item>
      <item>
       <name code="true" group="string">toUpperCase(text)</name>
       <description>
        Returns the the text with all lowercase characters switched 
        to uppercase.
        </description>
      </item>
      <item>
       <name code="true" group="interim">updateCSS(additionalRules)</name>
       <description>
        <p>
         *[bold:Note: This is an interim function that will stop working
         in a future release when the functionality is replaced
         with different means.]*
         Ensures that there is an "additionalCSS" style sheet 
         and then replaces the items there with those in additionalRules.
         Each rule is a separate line in additionalRules including the 
         selector(s), braces, and the rest of the style declaration.
        </p><p>
         For example:
        </p>
        <p>
          <example>.formitemtitle {font-size:120%;color:red;}</example>
        </p>
       </description>
      </item>
      <item>
       <name code="true" group="execution">wait(duration)</name>
       <description>
        Pauses execution for duration seconds.
        The value of duration should be a number between 1 and 60.
        It will be adjusted to conform to that range.
        Returns the adjusted value of duration.
        This function is not available during No Wait Execution, when it will return "0".
       </description>
      </item>
     </list>
    </p>
    <p>
    </p>
   </description>
  </section>
  <section>
   <title>Why TPL?</title>
   <description>
    <p>
     A variety of factors went into the decision to create and use an application-specific 
     language system for use in TransForm. 
     This is both the language itself and the implementation of the language system.   
    </p>
    <p>
     Choosing an existing language opens the possibility of making use of an existing
     implementation, such as using the JavaScript engine built into mobile OS environments.
     A problem with an existing implementation is that most are not available in 
     a language supported by the runtime environment of TransForm.
     If an existing implementation is not used, then there is the difficult challenge of
     creating and maintaining a compatible implementation that provides all of the 
     features and behaviors (documented or not, needed for use working with forms 
     or not) of other implementations.
     Without compatibility and full implementation, much of the advantages of an 
     existing language are lost and the promise of "being standard" is not fulfilled. 
     Hope that learning the language for use in TransForm will provide a strong basis
     for claiming skill for direct use elsewhere would then be suspect.
    </p>
    <p>
     Another important factor was the need to have complete control of the implementation 
     in order to help enforce security.
     The writers of the programs need to be able to be normal, line-of-business 
     people, unvetted and perhaps unsupervised by an IT department.
     The language system needed to be able to be limited in functionality that 
     could be abused, such as to leak data or operate maliciously while using the credentials of
     another user logged in with different roles.
    </p>
    <p>
     Most common languages, including using JavaScript already part of the TransForm
     system, are designed to provide as much functionality as possible and would need
     to be cut back from their normal state.
     At that point, they would no longer be the same and would require special training
     to learn which features were changed or missing.
     Documentation elsewhere would be misleading.
     Code developed elsewhere could have anomalies when run in the restricted implementation. 
     The promise of "write once, run elsewhere" would not apply without careful,
     knowledgeable checking in each case.
    </p>
    <p>
     Another issue was the need to integrate the program execution with the form editing 
     of TransForm. The normal execution engines of a language implementation would to need
     to be modified to meet those needs.
     The semantics of certain operations, and the definition of popular functions,
     would need to be changed.
    </p>
    <p>
     An advantage of using a language system designed specifically for TransForm 
     is that it can be tuned to the common operations performed when filling out 
     forms. The library of functions can also be tuned to the data types being
     operated on. 
     Features not required to meet the needs of TransForm users need not be implemented.
    </p>
    <p>
     A desirable trait of a language used for TransForm is that it be easy for 
     experienced programmers, familiar with other computer languages, to read 
     and learn to use. 
     That drove the use of explicit, word-based constructs such as "IF/ENDIF" and 
     "FOR-TO-STEP/ENDFOR", and common expression and function-calling syntax.
    </p>
    <p>
     Many of the form designers will not be directly using the language in any case.
     They will be using dialog-driven user interfaces to specify the operations to 
     be performed, such as the construction of a conditional expression used to 
     show or hide items on a form.
     For these users, the choice of language is not relevant at all, and hidden.
     However, if they do want to switch to using the language directly in a particular
     instance, the auto-generated code can be examined to provide a working baseline from 
     which to start.
    </p>
    <p>
     For all these reasons, and more, the decision to use TPL was made.
    </p>
   </description>
  </section>
 </sections>
</page>