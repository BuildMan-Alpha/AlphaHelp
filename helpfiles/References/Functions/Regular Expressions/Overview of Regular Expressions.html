	<!DOCTYPE html>
	<html>
	<head>
	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\" />
	<link rel="stylesheet" type="text/css" href="theme.css" />
	</head>
	<body>
	<div id="tiki-clean">
			<div id="tiki-mid">
	
 



 

	<div class="wikitopline clearfix" style="clear: both;">
	<div class="content">
				<div class="wikiinfo" style="float: left">



<span id="description"></span>

		</div>

	 
 
	</div> 
</div> 




<article id="top" class="wikitext clearfix nopagetitle">
			
		
		
		
		
			 

	
			<p class=A3Topic>Overview of Regular Expressions</p>
<p>Copyright (c) 1998-2001, Dr John Maddock</p>
<p>For a comprehensive review of Regular Expressions see <a href="http://www.cs.utah.edu/dept/old/texinfo/regex/regex_toc.html">http://www.cs.utah.edu/dept/old/texinfo/regex/regex_toc.html</a>.</p>
<p><b>Note: Portions of this page are obsolete.</b></p>
<p class=A5>Literals</p>
<p>All characters are literals except: <span class=Code1>.</span>, <span 
 class=Code1>|, *, ?, +, (, ), {, }, [,&nbsp;], ^, $</span> and <span class=Code1>\</span>. 
 These characters are literals when preceded by a "\". A literal 
 is a character that matches itself, or matches the result of <span class=Code1>traits_type::translate()</span>, 
 where <span class=Code1>traits_type</span> is the traits template parameter 
 to class <span class=Code1>reg_expression</span>.</p>
<p class=A5>Wildcard</p>
<p>The dot character "." matches any single character except 
 when:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>match_not_dot_NULL</span> 
 is passed to the matching algorithms, the dot does not match a <span class=Bolded>NULL</span> 
 character;</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>match_not_dot_newline</span> 
 is passed to the matching algorithms, then the dot does not match a <span 
 class=Bolded>newline</span> character.</p>
</li>
</ul>
<p class=A5>Repeats</p>
<p>A repeat is an expression that is repeated an arbitrary number of times.</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1>An expression followed 
 by <span class=Code1>*</span> can be repeated any number of times including 
 zero.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1>An expression followed 
 by <span class=Code1>+</span> can be repeated any number of times, but 
 at least once, if the expression is compiled with the flag <span class=Code1>regbase::bk_plus_qm</span> 
 then <span class=Code1>+</span> is an ordinary character and <span class=Code1>\+</span> 
 represents a repeat of once or more.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1>An expression followed 
 by <span class=Code1>?</span> may be repeated zero or one times only, 
 if the expression is compiled with the flag <span class=Code1>regbase::bk_plus_qm</span> 
 then "?" is an ordinary character and <span class=Code1>\?</span> 
 represents the repeat zero or once operator.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1>When it is necessary to 
 specify the minimum and maximum number of repeats explicitly, the bounds 
 operator <span class=Code1>{}</span> may be used, thus <span class=Code1>a{2}</span> 
 is the letter <span class=Code1>a</span> repeated exactly twice, <span 
 class=Code1>a{2,4}</span> represents the letter <span class=Code1>a</span> 
 repeated between 2 and 4 times, and <span class=Code1>a{2,}</span> represents 
 the letter <span class=Code1>a</span> repeated at least twice with no 
 upper limit. Note that there must be no white-space inside the <span class=Code1>{}</span>, 
 and there is no upper limit on the values of the lower and upper bounds. 
 When the expression is compiled with the flag <span class=Code1>regbase::bk_braces</span> 
 then <span class=Code1>{</span> and <span class=Code1>}</span> are ordinary 
 characters and <span class=Code1>\{</span> and <span class=Code1>\}</span> 
 are used to delimit bounds instead. All repeat expressions refer to the 
 shortest possible previous sub-ex<x>pression: a single character; a character 
 set, or a sub-expression grouped with <span class=Code1>()</span> for 
 example.</p>
</li>
</ul>
<p class=A5>Examples</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>ba</span> 
 * will match all of <span class=Code1>b</span>, <span class=Code1>ba</span>, 
 <span class=Code1>baaa</span> etc.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>ba+</span> 
 will match <span class=Code1>ba</span> or <span class=Code1>baaaa</span> 
 for example but not <span class=Code1>b.</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>ba?</span> 
 will match <span class=Code1>b</span> or <span class=Code1>ba.</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>ba{2,4}</span> 
 will match <span class=Code1>baa</span>, <span class=Code1>baaa</span> 
 and <span class=Code1>baaaa.</span></p>
</li>
</ul>
<p class=A5>Non-greedy repeats</p>
<p>Whenever the "extended" regular expression syntax (the default) 
 is in use then non-greedy repeats are possible by appending a '?' after 
 the repeat; a non-greedy repeat is one which will match the shortest possible 
 string.</p>
<p>For example to match html tag pairs one could use something like: <span 
 class=Code1><\s*tagname[^>]*>(.*?)<\s*/tagname\s*></span></p>
<p>In this case <span class=Code1>$1</span> will contain the text between 
 the tag pairs, and will be the shortest possible matching string.</p>
<p class=A5>Parenthesis</p>
<p>Parentheses serve two purposes, to group items together into a sub-ex<x>pression, 
 and to mark what generated the match. For example the expression <span 
 class=Code1>(ab)*</span> would match all of the string <span class=Code1>ababab</span>.</p>
<p class=A5>Non-Marking Parenthesis</p>
<p>Sometimes you need to group sub-expressions with parenthesis, but do 
 not want the parenthesis to spit out another marked sub-ex<x>pression, in 
 this case a non-marking parenthesis <span class=Code1>(?:ex<x>pression)</span> 
 can be used. For example the following expression creates no sub-expressions: 
 ( <span class=Code1>?:abc)</span> *</p>
<p class=A5>Forward Lookahead Asserts</p>
<p>There are two forms of these; one for positive forward look-ahead asserts, 
 and one for negative look-ahead asserts:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>(?=abc)</span> 
 matches zero characters only if they are followed by the expression <span 
 class=Code1>abc</span>.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>(?!abc)</span> 
 matches zero characters only if they are not followed by the expression 
 <span class=Code1>abc</span>.</p>
</li>
</ul>
<p class=A5>Alternatives</p>
<p>Alternatives occur when the expression can match either one sub-expression 
 or another, each alternative is separated by a "|", or a "\|" 
 if the flag <span class=Code1>regbase::bk_vbar</span> is set, or by a 
 <span class=Bolded>newline</span> character if the <span class=Code1>flag 
 regbase::newline_alt</span> is set. Each alternative is the largest possible 
 previous sub-ex<x>pression; this is the opposite behaviour from repetition 
 operators.</p>
<p class=A5>Examples</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>a(b|c)</span> 
 could match <span class=Code1>ab</span> or <span class=Code1>ac</span>.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>abc|def</span> 
 could match <span class=Code1>abc</span> or <span class=Code1>def</span>.</p>
</li>
</ul>
<p class=A5>Sets</p>
<p>A set is a set of characters that can match any single character that 
 is a member of the set. Sets are delimited by "[" and "]" 
 and can contain literals, character ranges, character classes, collating 
 elements and equivalence classes. Set declarations that start with "^" 
 contain the compliment of the elements that follow.</p>
<p class=A5>Examples</p>
<p>Character literals:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>[abc]</span> 
 will match either of <span class=Code1>a</span>, <span class=Code1>b</span>, 
 or <span class=Code1>c</span>.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>[^abc]</span> 
 will match any character other than <span class=Code1>a</span>, <span 
 class=Code1>b</span>, or <span class=Code1>c</span>.</p>
</li>
</ul>
<p>Character ranges:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>[a-z]</span> 
 will match any character in the range <span class=Code1>a</span> to <span 
 class=Code1>z</span>.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>[^A-Z]</span> 
 will match any character other than those in the range <span class=Code1>A</span> 
 to <span class=Code1>Z</span>.</p>
</li>
</ul>
<p>Character classes are denoted using the syntax <span class=Code1>[:classname:]</span> 
 within a set declaration, for example <span class=Code1>[:space:]]</span> 
 is the set of all white-space characters. Character classes are only available 
 if the flag <span class=Code1>regbase::char_classes</span> is set. The 
 available character classes are:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>alnum</span> 
 : Any alpha numeric character.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>alpha</span> 
 : Any alphabetical character a-z and A-Z. Other characters may also be 
 included depending upon the locale.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>blank</span> 
 : Any blank character, either a space or a tab.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>cntrl</span> 
 : Any control character.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>digit</span> 
 : Any digit 0-9.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>graph</span> 
 : Any graphical character.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>lower</span> 
 : Any lower case character a-z. Other characters may also be included 
 depending upon the locale.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>print</span> 
 : Any printable character.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>punct</span> 
 : Any punctuation character.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>space</span> 
 : Any white space character.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>upper</span> 
 : Any upper case character A-Z. Other characters may also be included 
 depending upon the locale.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>xdigit</span> 
 : Any hexadecimal digit character, 0-9, a-f and A-F.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>word</span> 
 : Any word character - all alphanumeric characters plus the underscore.</p>
</li>
</ul>
<p>There are some shortcuts that can be used in place of the character 
 classes, provided the flag <span class=Code1>regbase::escape_in_lists</span> 
 is set then you can use:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\w</span> 
 in place of <span class=Code1>[:word:]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\s</span> 
 in place of <span class=Code1>[:space:]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\d</span> 
 in place of <span class=Code1>[:digit:]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\l</span> 
 in place of <span class=Code1>[:lower:]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\u</span> 
 in place of <span class=Code1>[:upper:]</span></p>
</li>
</ul>
<p>Collating elements take the general form <span class=Code1>[.tagname.]</span> 
 inside a set declaration, where <span class=Code1>tagname</span> is either 
 a single character, or a name of a collating element, for example <span 
 class=Code1>[.a.]]</span> is equivalent to <span class=Code1>[a]</span>, 
 and <span class=Code1>[.comma.]]</span> is equivalent to <span class=Code1>[,]</span>. 
 The library supports all the standard <span class=Screen>POSIX</span> 
 collating element names, and in addition the following digraphs: "ae", 
 "ch", "ll", "ss", "nj", "dz", 
 "lj", each in lower, upper and title case variations. Multi-character 
 collating elements can result in the set matching more than one character, 
 for example <span class=Code1>[.ae.]]</span> would match two characters, 
 but note that <span class=Code1>[^[.ae.]]</span> would only match one 
 character.</p>
<p>Equivalence classes take the general form <span class=Code1>[=tagname=]</span> 
 inside a set declaration, where <span class=Code1>tagname</span> is either 
 a single character, or a name of a collating element, and matches any 
 character that is a member of the same primary equivalence class&nbsp;as&nbsp;the 
 collating element <span class=Code1>[.tagname.]</span>. An equivalence 
 class is a set of characters that collate the same, a primary equivalence 
 class is a set of characters whose primary sort key are all the same (for 
 example strings are typically collated by character, then by accent, and 
 then by case; the primary sort key then relates to the character, the 
 secondary to the accentation, and the tertiary to the case). If there 
 is no equivalence class corresponding to <span class=Code1>tagname</span>, 
 then <span class=Code1>[=tagname=]</span> is exactly the same&nbsp;as&nbsp; 
 <span class=Code1>[.tagname.]</span>. Unfortunately there is no locale 
 independent method of obtaining the primary sort key for a character, 
 except under Win32. For other operating systems the library will "guess" 
 the primary sort key from the full sort key (obtained from <span class=Code1>strxfrm</span> 
 ), so equivalence classes are probably best considered broken under any 
 operating system other than <span class=Screen>Win32</span>.</p>
<p>To include a literal "-" in a set declaration then: make it 
 the first character after the opening "[" or "[^", 
 the endpoint of a range, a collating element, or if the flag <span class=Code1>regbase::escape_in_lists</span> 
 is set then precede with an escape character&nbsp;as&nbsp;in "[\-]". 
 To include a literal "[" or "]" or "^" in 
 a set then make them the endpoint of a range, a collating element, or 
 precede with an escape character if the flag <span class=Code1>regbase::escape_in_lists</span> 
 is set.</p>
<p class=A5>Line anchors</p>
<p>An anchor is something that matches the NULL string at the start or 
 end of a line: "^" matches the NULL string at the start of a 
 line, "$" matches the NULL string at the end of a line.</p>
<p class=A5>Back references</p>
<p>A back reference is a reference to a previous sub-expression that has 
 already been matched, the reference is to what the sub-expression matched, 
 not to the expression itself. A back reference consists of the escape 
 character "\" followed by a digit "1" to "9", 
 "\1" refers to the first sub-ex<x>pression, "\2" to the 
 second etc. For example the expression <span class=Code1>(.*)\1</span> 
 matches any string that is repeated about its mid-point for example <span 
 class=Code1>abcabc</span> or <span class=Code1>xyzxyz</span>. A back reference 
 to a sub-expression that did not participate in any match, matches the 
 NULL string: NB this is different to some other regular expression matchers. 
 Back references are only available if the expression is compiled with 
 the flag <span class=Code1>regbase::bk_refs</span> set.</p>
<p class=A5>Characters by code</p>
<p>This is an extension to the algorithm that is not available in other 
 libraries, it consists of the escape character followed by the digit "0" 
 followed by the octal character code. For example "\023" represents 
 the character whose octal code is 23. Where ambiguity could occur use 
 parentheses to break the expression up: "\0103" represents the 
 character whose code is 103, "(\010)3 represents the character 10 
 followed by "3". To match characters by their hexadecimal code, 
 use \x followed by a string of hexadecimal digits, optionally enclosed 
 inside {}, for example \xf0 or \x{aff}, notice the latter example is a 
 Unicode character.</p>
<p class=A5>Word operators</p>
<p>The following operators are provided for compatibility with the GNU 
 regular expression library.</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\w</span> 
 matches any single character that is a member of the "word" 
 character class, this is identical to the expression <span class=Code1>[:word:]]</span>.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\W</span> 
 matches any single character that is not a member of the "word" 
 character class, this is identical to the expression <span class=Code1>[^[:word:]]</span>.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\<</span> 
 matches the NULL string at the start of a word.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\></span> 
 matches the NULL string at the end of the word.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\b</span> 
 matches the NULL string at either the start or the end of a word.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\B</span> 
 matches a NULL string within a word.</p>
</li>
</ul>
<p>The start of the sequence passed to the matching algorithms is considered 
 to be a potential start of a word unless the flag <span class=Code1>match_not_bow</span> 
 is set. The end of the sequence passed to the matching algorithms is considered 
 to be a potential end of a word unless the flag <span class=Code1>match_not_eow</span> 
 is set.</p>
<p class=A5>Buffer operators</p>
<p>The following operators are provide for compatibility with the <span 
 class=Bolded>GNU</span> regular expression library, and <span class=Bolded>Perl</span> 
 regular expressions:</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\`</span> 
 matches the start of a buffer.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\A</span> 
 matches the start of the buffer.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\'</span> 
 matches the end of a buffer.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\z</span> 
 matches the end of a buffer.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\Z</span> 
 matches the end of a buffer, or possibly one or more new line characters 
 followed by the end of the buffer.</p>
</li>
</ul>
<p>A buffer is considered to consist of the whole sequence passed to the 
 matching algorithms, unless the flags <span class=Code1>match_not_bob</span> 
 or <span class=Code1>match_not_eob</span> are set.</p>
<p class=A5>Escape operator</p>
<p>The escape character "\" has several meanings.</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1>Inside a set declaration 
 the escape character is a normal character unless the flag <span class=Code1>regbase::escape_in_lists</span> 
 is set in which case whatever follows the escape is a literal character 
 regardless of its normal meaning.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1>The escape operator may 
 introduce an operator for example: back references, or a word operator.</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1>The escape operator may 
 make the following character normal, for example "\*" represents 
 a literal "*" rather than the repeat operator.</p>
</li>
</ul>
<p class=A5>Single character escape sequences</p>
<p>The following escape sequences are aliases for single characters:</p>
<table style="x-cell-content-align: top;
				width: 100%;
				border-left-style: none;
				border-right-style: none;
				border-top-style: none;
				border-bottom-style: none;
				border-spacing: 0px;
				border-spacing: 0px;" cellspacing="0" width="100%">
<col style="width: 10.737%;">
<col style="width: 10.977%;">
<col style="width: 78.286%;">
<tr style="x-cell-content-align: top;" valign="top">
<td class="tableHeader" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%">
<p class=TableHead>Escape sequence</td>
<td class="tableHeader" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%">
<p class=TableHead>Character code</td>
<td class="tableHeader" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">
<p class=TableHead>Meaning</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\a</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x07</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">Bell character</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\f</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x0C</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">Form feed</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\n</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x0A</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">Newline character</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\r</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x0D</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">Carriage return</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\t</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x09</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">Tab character</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\v</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x0B</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">Vertical tab</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\e</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0x1B</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">ASCII Escape character</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\0dd</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0dd</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">An octal character code, where dd is one or more octal 
 digits.</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\xXX</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0xXX</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">A hexadecimal character code, where XX is one or more 
 hexadecimal digits.</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\x{XX}</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>0xXX</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">A hexadecimal character code, where XX is one or more 
 hexadecimal digits, optionally a unicode character.</td></tr>
<tr style="x-cell-content-align: top;" valign="top">
<td class="TableCell" style="x-cell-content-align: top; width: 10.737%;" valign="top" width="10.737%"><span class=Code1>\cZ</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 10.977%;" valign="top" width="10.977%"><span class=Code1>z-@</span></td>
<td class="TableCell" style="x-cell-content-align: top; width: 78.286%;" valign="top" width="78.286%">An ASCII escape sequence control-Z, where Z is any ASCII 
 character greater than or equal to the character code for '@'.</td></tr>
</table>
<p class=A5>Miscellaneous escape sequences:</p>
<p>The following are provided mostly for <span class=Screen>Perl</span> 
 compatibility, but note that there are some differences in the meanings 
 of <span class=Code1>\l \L \u</span> and <span class=Code1>\U</span> :</p>
<ul style="list-style: disc;"
	type=disc>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\w</span> 
 Equivalent to <span class=Code1>[:word:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\W</span> 
 Equivalent to <span class=Code1>[^[:word:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\s</span> 
 Equivalent to <span class=Code1>[:space:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\S</span> 
 Equivalent to <span class=Code1>[^[:space:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\d</span> 
 Equivalent to <span class=Code1>[:digit:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\D</span> 
 Equivalent to <span class=Code1>[^[:digit:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\l</span> 
 Equivalent to <span class=Code1>[:lower:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\L</span> 
 Equivalent to <span class=Code1>[^[:lower:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\u</span> 
 Equivalent to <span class=Code1>[:upper:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\U</span> 
 Equivalent to <span class=Code1>[^[:upper:]]</span></p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\C</span> 
 Any single character, equivalent to ' <span class=Code1>.</span> '</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\X</span> 
 Match any Unicode combining character sequence, for example <span class=Code1>a\x 
 0301</span> (a letter a with an acute)</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\Q</span> 
 The begin quote operator, everything that follows is treated&nbsp;as&nbsp;a 
 literal character until a <span class=Code1>\E</span> end quote operator 
 is found</p>
</li>
	<li class=kadov-p-CBullet1><p class=Bullet1><span class=Code1>\E</span> 
 The end quote operator, terminates a sequence begun with <span class=Code1>\Q</span></p>
</li>
</ul>
<p class=A5>What gets matched?</p>
<p>The regular expression library will match the first possible matching 
 string, if more than one string starting at a given location can match 
 then it matches the longest possible string, unless the flag <span class=Code1>match_any</span> 
 is set, in which case the first match encountered is returned. Use of 
 the <span class=Code1>match_any</span> option can reduce the time taken 
 to find the match - but is only useful if the user is less concerned about 
 what matched - for example it would not be suitable for search and replace 
 operations. In cases where their are multiple possible matches all starting 
 at the same location, and all of the same length, then the match chosen 
 is the one with the longest first sub-ex<x>pression, if that is the same 
 for two or more matches, then the second sub-expression will be examined 
 and so on.</p>
<p class=A5>See Also</p>
<p><a href="../REGEX_MATCH Function.html" title="REGEX_MATCH Function" class="wiki">REGEX_MATCH(</a>), <a href="../REGEX_MERGE Function.html" title="REGEX_MERGE Function" class="wiki">REGEX_MERGE(</a>), 
 <a href="../REGEX_SPLIT Function.html" title="REGEX_SPLIT Function" class="wiki">REGEX_SPLIT(</a>), <a href="Matching Clauses in Regular Expressions.html" title="Matching Clauses in Regular Expressions" class="wiki">Text,   Numbers, and Punctuation in Regular Expressions</a></p>
	
	
	<hr class="hrwikibottom" /> 

	
	</article> 




	<!-- WIKIPATH:Overview+of+Regular+Expressions">-->


	<div class="wikitopline clearfix" style="clear: both;">
	<div class="content">
				<div class="wikiinfo" style="float: left">



<span id="description"></span>

		</div>

	 
 
	</div> 
</div> 

			</div>
		</div>


	
	
<!-- Put JS at the end -->
	
<!-- jsfile external -->


<!-- jsfile dynamic -->
<!-- jsfile 0 -->
<!---HELPMETADATA: {"tags":"common"} --->
</body></html>