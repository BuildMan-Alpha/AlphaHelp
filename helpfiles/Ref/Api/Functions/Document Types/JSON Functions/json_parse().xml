<page api="xb">
	<shortlink>json_parse Function</shortlink>
	<topic>json_parse Function</topic>
	<description>The json_parse function parses a string in JSON format and returns an Xbasic dot variable.</description>
	<prototype>dim result as p = json_parse(jsonTxt as C [, flagJavascriptSyntax as L])</prototype>
	<arguments>
		<argument>
			<name>jsonTxt</name>
			<type>C</type>
			<description>JSON formatted text.</description>
		</argument>
		<argument optional="true">
			<name>flagJavascriptSyntax</name>
			<type>L</type>
			<description>Default = .f.. If the JSON string contains Javascript function definitions, this parameter must be set to .t., otherwise json_parse() may fail to parse the JSON.</description>
		</argument>
	</arguments>
	<returns>
		<return>
			<name>result</name>
			<types>
				<type>p</type>
			</types>
			<description>Returns the JSON parsed as a dot variable.</description>
		</return>
	</returns>
	<discussion>
		<p>JSON parse is one of the most important functions for dealing with JSON in Xbasic. The json_parse function parses a string in JSON format and returns an Xbasic dot variable. Keep in mind that Xbasic is case in-sensitive so if the JSON you are parsing has duplicate property names (with different cases), the resulting Xbasic dot variable will only have a single instance of the property. </p>
	</discussion>
	<sections>
		<section>
			<example><![CDATA[? json_parse("{ foo : 1}")
= foo = 1]]></example>
		</section>
		<section>
			<description>
				<p>Json_parse can handle this incorrectly formatted json, i.e. JSON spec requires names be quoted. The json_parse() function can take an optional second argument to indicate if the JSON being parsed is a Javascript object literal rather than a JSON string. For example, the json_parse() function can interpret Javascript Date() functions in a JSON string. This allows you to parse JSON strings generated by the json_generate() function, if the json_generate() function generated a JSON string that uses the Date() function.</p>
			</description>
		</section>
		<section>
			<example><![CDATA[dim p as p 
p.name = "Fred" 
p.sayHello = "{javascript}function() { alert('hello');}"]]></example>
		</section>
		<section>
			<description>Now, generate a Javascript object literal. Pass in .t. as the second argument to vartojson() to indicate that we want an Javascript object literal and not a JSON string.</description>
			<example><![CDATA[dim jsObject as c 
jsObject = vartojson(p,.t.)]]></example>
		</section>
		<section>
			<description>Here is what the resulting string looks like:</description>
			<example><![CDATA[{
	name: 'Fred',
	sayHello: function() { alert('hello');}
}]]></example>
		</section>
		<section>
			<description>Now, in order to be able to parse this object literal back to Xbasic, we use the json_parse() function but we set the optional second argument to .t.</description>
			<example><![CDATA[dim pj as p
pj = json_parse(jsObject, .t.)
?pj.name 
= "Fred"

?pj.sayHello
= "{javascript}function() { alert('hello');}"]]></example>
		</section>
		<section>
			<example><![CDATA[p2 = json_parse("[{name:\"Fred Smith\", age: 23 },{name:\"John Jones\", age: 45}]")

?p2[1]
= age = 23
name = "Fred Smith"

?p2[2]
= age = 45
name = "John Jones"]]></example>
		</section>
		<section>
			<description>The following example shows a round trip using json_parse() and json_generate() to show how date and time values are preserved.</description>
			<example><![CDATA[dim p1 as p
p1.name = "Karen"
p1.dob = date()
p1.time = now()

? json_generate(p1)
{
	"name": "Karen",
	"dob": Date('2016/10/26'),
	"time": Date('2016/10/26T23:52:28:130')
}

dim jsonTxt as c
jsonTxt = json_generate(p1)
dim p2 as p
p2 = json_parse(jsonTxt)

?p2
= dob = {10/26/2016}
name = "Karen"
time = 10/26/2016 11:52:28 13 pm
]]></example>
		</section>
<!--		<section>
			<description>
				<p>*[Note]*: If the data in the JSON string contains any strings with line breaks (designated as '\n' in the data) , json_parse() will return a LF delimited data, not CR-LF delimited data. You will need to use the convert_lf_to_crlf() function to convert LFs to CR-LFs.</p>
				<p>Example:</p>
			</description>
		</section>
		<section>
			<example><![CDATA[p.name = "Alpha" + crlf() + "Beta"
?json_generate(p)
{name: 'Alpha\nBeta'}
p2 = json_parse(json_generate(p))
?p2.name = p.name
= .F.
?convert_lf_to_crlf(p2.name) = p.name
= .T.
]]></example>
		</section>-->
	</sections>
	<see>
		<ref link="json_generate Function">json_generate()</ref>
		<ref link="json_reformat Function">json_reformat()</ref>
		<ref link="JSON Data">JSON Data</ref>
	</see>
	<terms>JSON,arguments,contains,function,javascript,object,set,string,time,Xbasic</terms>
</page>