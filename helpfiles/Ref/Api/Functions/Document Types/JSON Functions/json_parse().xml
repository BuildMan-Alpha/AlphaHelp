<page>
	<shortlink>json_parse()</shortlink>
	<topic>json_parse Function</topic>
	<description>The json_parse function parses a string in JSON format and returns an Xbasic dot variable.</description>
	<syntax>json_parse(jsonTxt as C)</syntax>
	<arguments>
		<argument>
			<name>jsonTxt</name>
			<type>C</type>
			<description>JSON formatted text.</description>
		</argument>
	</arguments>
	<discussion>
		<p>JSON parse is one of the most important functions for dealing with JSON in Xbasic. The json_parse function parses a string in JSON format and returns an Xbasic dot variable. This function is simply a wrapper on the INET::JSONParser.parse() method. However, unlike the low level INET::JSONParser.parse() method, the json_parse() function can also be used to parse strings that are in Javascript array format. (INET::JSONParser.parse() can only be used for strings that are in JSON format.).</p>
		<p>JSON Parse is sometimes slower than other methods but it is also forgiving. Not all things that purport to be JSON are in fact JSON. For example, the use of quotes around a string. This is not required on Microsoft's parser but it is required in Javascript. This uses a Microsoft JSON parser:</p>
	</discussion>
	<sections>
		<section>
			<example><![CDATA[? json_parse("{ foo : 1}")
= foo = 1]]></example>
		</section>
		<section>
			<description>
				<p>Json_parse can handle this incorrectly formatted json, i.e. JSON spec requires names be quoted. The json_parse() function can take an optional second argument to indicate if the JSON being parsed is a Javascript object literal rather than a JSON string. For example, the json_parse() function can interpret Javascript Date() functions in a JSON string. This allows you to parse JSON strings generated by the json_generate() function, if the json_generate() function generated a JSON string that uses the Date() function.</p>
			</description>
		</section>
		<section>
			<example><![CDATA[dim p as p 
p.name = "Fred" 
p.sayHello = "{javascript}function() { alert('hello');}"]]></example>
		</section>
		<section>
			<description>Now, generate a Javascript object literal. Pass in .t. as the second argument to vartojson() to indicate that we want an Javascript object literal and not a JSON string.</description>
			<example><![CDATA[dim jsObject as c 
jsObject = vartojson(p,.t.)]]></example>
		</section>
		<section>
			<description>Here is what the resulting string looks like:</description>
			<example><![CDATA[{
	name: 'Fred',
	sayHello: function() { alert('hello');}
}]]></example>
		</section>
		<section>
			<description>Now, in order to be able to parse this object literal back to Xbasic, we use the json_parse() function but we set the optional second argument to .t.</description>
			<example><![CDATA[dim pj as p
pj = json_parse(jsObject, .t.)
?pj.name 
= "Fred"

?pj.sayHello
= "{javascript}function() { alert('hello');}"]]></example>
		</section>
		<section>
			<example><![CDATA[p2 = json_parse("[{name:\"Fred Smith\", age: 23 },{name:\"John Jones\", age: 45}]")

?p2[1]
= age = 23
name = "Fred Smith"

?p2[2]
= age = 45
name = "John Jones"]]></example>
		</section>
		<section>
			<description>The following example shows a round trip using json_parse() and json_generate() to show how date and time values are preserved.</description>
			<example><![CDATA[dim p1 as p
p1.name = "Karen"
p1.dob = date()
p1.time = now()

? json_generate(p1)
{
	"name": "Karen",
	"dob": Date('2016/10/26'),
	"time": Date('2016/10/26T23:52:28:130')
}

dim jsonTxt as c
jsonTxt = json_generate(p1)
dim p2 as p
p2 = json_parse(jsonTxt)

?p2
= dob = {10/26/2016}
name = "Karen"
time = 10/26/2016 11:52:28 13 pm
]]></example>
		</section>
<!--		<section>
			<description>
				<p>*[Note]*: If the data in the JSON string contains any strings with line breaks (designated as '\n' in the data) , json_parse() will return a LF delimited data, not CR-LF delimited data. You will need to use the convert_lf_to_crlf() function to convert LFs to CR-LFs.</p>
				<p>Example:</p>
			</description>
		</section>
		<section>
			<example><![CDATA[p.name = "Alpha" + crlf() + "Beta"
?json_generate(p)
{name: 'Alpha\nBeta'}
p2 = json_parse(json_generate(p))
?p2.name = p.name
= .F.
?convert_lf_to_crlf(p2.name) = p.name
= .T.
]]></example>
		</section>-->
	</sections>
	<see>
		<ref href="/documentation/index?search=json_generate()">json_generate()</ref>
		<ref href="/documentation/index?search=json_reformat()">json_reformat()</ref>
		<ref href="/documentation/index?search=JSON Data">JSON Data</ref>
	</see>
	<terms>JSON,arguments,contains,function,javascript,object,set,string,time,xbasic</terms>
</page>