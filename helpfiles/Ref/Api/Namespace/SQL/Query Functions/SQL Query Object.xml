<page>
	<topic>SQL::Query Object</topic>
<description>The SQL::Query object implements Portable SQL. The SQL::Query object parses Portable SQL statements and converts them to the native SQL dialect of the target database. The SQL::Query object is the root of all queries. as a result, it has the most properties. Its children are the various clauses that make up a complete SELECT statement.</description>	
	
	<sections>
		<section>
			
	<example><![CDATA[dim conn as SQL::Connection
dim qry as SQL::Query
dim rs as SQL::ResultSet
dim connString as C
dim select_exp as C
connString = "{A5API='Access', FileName='c:\program files\a5v7\mdbfiles\alphasports.mdb'}"
select_exp = "select Lastname from customer where bill_state_region = 'ma'"
conn.open(connString)
qry.execute(conn)
rs = qry.resultset]]></example>
			
		</section>
		<section>
			<description>In the simplest case, you can declare a variable and parse a string. From there you can explore the resulting query as an Xbasic object, or dump the parse tree by looking at the .ParseTree property, or even convert the query to XML using the XML property.
For example:
</description>
	<example><![CDATA[dim Q as SQL::Query
Q.Parse("select customer, cost, ?Hello' as Message from orderheader o order by customer")
? Q.ParseTree
=
{ SELECT:510:193 NONE:182 SELECT_LIST:160 TABLE_LIST:164
{ LOGICAL_EXPRESSION:191NONE:120 LIST:158 }
{ GROUPBY_CLAUSE:187GROUPBY_LIST:188 WHERE_CLAUSE:183 .f.:4 }ORDERBY_CLAUSE:184 UNION_LIST:189 ORDERBY_CLAUSE:184 }
? Q.XML
= ]]></example>
			
		</section>
		<section>
			<description>In addition, the XML string can be assigned to a different query.</description>
	<example><![CDATA[dim Q2 as SQL::Query
Q2.XML = Q.XML
? Q2.ParseTree
=
{ SELECT:510:193 NONE:182 SELECT_LIST:160 TABLE_LIST:164
{ LOGICAL_EXPRESSION:191NONE:120 LIST:158 }
{ GROUPBY_CLAUSE:187GROUPBY_LIST:188 WHERE_CLAUSE:183 .f.:4 }ORDERBY_CLAUSE:184 UNION_LIST:189 ORDERBY_CLAUSE:184 }]]></example>
			
		</section>
		
	</sections>
	
	
	<sections>
		<section><title>Using Arguments</title>
			<description>This script show how to use an argument when you want to substitute a value at run time. This syntax does not directly use a SQL::Arguments object. Instead, it allows the SQL::Query object to create its own SQL::Arguments object.</description>
	<example><![CDATA[q.Parse("SELECT CompanyName, City FROM Customers WHERE City = :city")
? q.Arguments.Count
= 1
? q.Arguments.Set("City", "London")
= .T.
c.Open(cs)
q.Execute(c)
? q.ResultSet.ToString()
= B's Beverages London
Consolidated Holdings London
Eastern Connection London
North/South London
Seven Seas Imports London]]></example>
			
		</section>
		<section>
			<description>This syntax uses a SQL::Arguments object, adds a name/value pair with the SQL::Argument.Add()method, and passes the object as part of the SQL::Connection::Execute()query.</description>
	<example><![CDATA[dim args as SQL::Arguments
dim conn as SQL::Connection
sql = "SELECT TOP 2 CompanyName, City FROM Customers WHERE City = :city"
args.Add("city", "London")
? conn.Execute(sql, args)
= .T.
? conn.ResultSet.ToString()
= B's Beverages London
Consolidated Holdings London
Eastern Connection London
North/South London
Seven Seas Imports London]]></example>
			
		</section>
	
	</sections>
	
	<properties>
		<property>
			<name>Arguments</name>
			<type>SQL::Arguments</type>
			<description>Read Only. Arguments for the current query.</description>
		</property>
		
		<property>
			<name>CallResult</name>
			<type>SQL::CallResult</type>
			<description>Read Only. Call results.</description>
		</property>
		
		<property>
			<name>Column</name>
			<type>List of SQL::Query:: SelectItem</type>
			<description>Read Write. List of the items in the select column list.</description>
		</property>
		
		<property>
			<name>ColumnReferences</name>
			<type>ReferenceList of SQL::Query::ColumnReference</type>
			<description>Read Only. An array of all column references in the query (including nested occurrences). Behaves the same way as  .SelectTableReferences.
</description>
		</property>
		
		<property>
			<name>Connection</name>
			<type>SQL::Connection</type>
			<description>Read Write. Current open connection</description>
		</property>
		
		<property>
			<name>DuplicateOption</name>
			<type>SQL::Query::DuplicateOption</type>
			<description>Read Write. See Enumerated Type Values.</description>
		</property>
		
		<property>
			<name>ErrorColumn</name>
			<type>N</type>
			<description>Read Only. The column number of the last error reported by the parser.</description>
		</property>
		
		<property>
			<name>ErrorText</name>
			<type>C</type>
			<description>Read Only. The text of the last parser error reported.</description>
		</property>
		<property>
			<name>First</name>
			<type>N</type>
			<description>-</description>
		</property>
		<property>
			<name>FunctionReferences</name>
			<type>ReferenceList of SQL::Query::ValueExpression</type>
			<description>Read Only. An array of all function calls. Behaves the same way as  .SelectTableReferences.
</description>
		</property>
		
		<property>
			<name>GroupBy</name>
			<type>SQL::Query::GroupBy</type>
			<description>Read Write. The GROUP BY clause. This object always exists. If the list inside is empty, no GROUP BY was coded.</description>
		</property>
		
		<property>
			<name>NestedOrderBy</name>
			<type>List of SQL::Query::ColumnOrder</type>
			<description>Read Write. A list of column order objects. If the list is empty, no ORDER BY clause  was coded. .NestedOrderBy comes before .Union. This was in a test case, so I am supporting it (for now).
 </description>
		</property>
		
		<property>
			<name>ObjectDefinitions</name>
			<type>C</type>
			<description>Read Only. For internal debugging. Returns a string description of the mapping between the ANTLR grammar and the Xbasic objects.
</description>
		</property>
		
		<property>
			<name>OrderBy</name>
			<type>List of SQL::Query::ColumnOrder</type>
			<description>Read Write. A list of column order objects. If the list is empty, no ORDER BY clause was coded.
</description>
		</property>
		
		<property>
			<name>ParseTree</name>
			<type>C</type>
			<description>Read Only. For internal debugging. A string description of the underlying parse tree.</description>
		</property>
		
		<property>
			<name>ResolveColumnTables</name>
			<type>L</type>
			<description>Read Write. Set to .T. if Execute should populate descriptions of tables and columns. This can affect performance.
</description>
		</property>
		
		<property>
			<name>ResultSet</name>
			<type>SQL::ResultSet</type>
			<description>Read Only. Descriptions and/or data from the last Execute or Validate function call.
</description>
		</property>
		
		<property>
			<name>SelectTableReferences</name>
			<type>ReferenceList of SQL::Query::SelectTableReference</type>
			<description>Read Only. An array of all table references in the from clause and those joined to them. This array is created when the property is requested, but can become out of date. Use the Resynch()function on any variable holding this list when any changes are made.
</description>
		</property>
		
		<property>
			<name>SQLStatement</name>
			<type>C</type>
			<description>Read Write. A variable that can be assigned a syntax string without parsing it. If no value is passed to the .Parse()method, this value is used.
</description>
		</property>
		
		<property>
			<name>Table</name>
			<type>List of SQL::Query::SelectTableReference</type>
			<description>Read Write. The items in the FROM clause or in a JOIN clause.
</description>
		</property>
		
		<property>
			<name>TableReferences</name>
			<type>ReferenceList of SQL::Query::SelectTableReference</type>
			<description>Read Only. An array of all table references in the query (including those nested inside of sub-selects and joins). This array is created when the property is requested, but can become out of date. Use the Resynch()function on any variable holding this list when any changes are made.
 </description>
		</property>
		<property>
			<name>TokenTypeName</name>
			<type>C</type>
			<description>"Query"</description>
		</property>
		<property>
			<name>Union</name>
			<type>List of SQL::Query::Union</type>
			<description>Read Write. A list (could be empty) of UNION clauses with their respective queries.
</description>
		</property>
		<property>
			<name>Where</name>
			<type>SQL::Query::LogicalExpression</type>
			<description>Read Write. An expression for the WHERE clause.
</description>
		</property>
		<property>
			<name>XML</name>
			<type>C</type>
			<description>Read Write. Creates XML from the tree or recreates the tree from the XML.
</description>
		</property>
		
	</properties>
	
	<methods>
		<method>
			<name>::Execute()</name>
			<description>Executes the current statement using the current or passed connection.
</description>
		</method>
		<method>
			<name>::Format()</name>
			<description>Formats a SQL statement, optionally placing each element on a separate line.</description>
		</method>
		<method>
			<name>::GenerateNativeSyntax()</name>
			<description>Generates a native SQL statement using the selected syntax associated with the current or passed connection.
</description>
		</method>
		<method>
			<name>::OpenConnection()</name>
			<description>Generates a native SQL statement using the selected syntax associated with the current or passed connection.
 </description>
		</method>
		<method>
			<name>::Parse()</name>
			<description>Parses the SQL statement passed (or the value previously set into the .SQLStatement property).</description>
		</method>
		<method>
			<name>::ReleaseConnection()</name>
			<description>Clears out the connection property.</description>
		</method>
		<method>
			<name>::Reset()</name>
			<description>Resets the query as if it had just been created.</description>
		</method>
		<method>
			<name>::Validate()</name>
			<description>Executes the current statement using the current or passed connection.</description>
		</method>
		
	</methods>
	
	
	
	<see>
		<ref>SQL Objects</ref>
		<ref>SQL Enumerated Types</ref>
	</see>
	
</page>