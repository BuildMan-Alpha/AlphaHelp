<page>
	<topic>DotNet::Services.ConstructGenericTypeName Static Method</topic>
	
	
	<syntax>ConstructGenericTypeName as C ( FullyQualifiedGenericTypeName as C, PARAMS FullyQualifiedElementType as C)
</syntax>
	
	<sections>
		<section>
			<description>Use ConstructGenericTypeName to construct the type name for a .NET generic type. These types are like templates in that they can be applied to a variety of data types, but will behave consistently.
 For example:</description>
			<steps>
				<step>
					<description>The SortedList generic will keep an ordered list of any object that supports comparison. A list of strings or a list of numbers can be built up and then iterated over in sorted order without writing additional code. </description>
				</step>
				<step>
					<description>The Dictionary generic can be used to create a collection of arbitrary objects with an arbitrary key. You can look up the items directly using the key value. The dictionary object must be constructed by providing two types one for the key and one for the value type. </description>
				</step>
				
			</steps>
			
		</section>
	<section>
		<description>Generic types have a fairly tedious syntax that includes the full generic type name, a back-tick (`), the number of arguments, and then a comma separated list of types to apply to it.

 All this function does is format the name for you.</description>
 <note>ConstructGenericTypeName is a static function, meaning it does not require an instance.</note>
	</section>	
		
	</sections>
<sections>
	<section>
		<title>Example</title>
		<description>You can call ConstructGenericTypeName with an instance:</description>
		<example><![CDATA[Dim Sv as DotNet::Services
?Sv.ConstructGenericTypeName("System.Collections.Generic.List","System.String")]]></example>
		
		
	</section>
	<section>
		<description>...or without an instance:</description>
		<example><![CDATA[?DotNet::Services::ConstructGenericTypeName("System.Collections.Generic.List","System.String")]]></example>
	<note>The .NET type string arguments to this function use dot (.) delimiters, not double-colon (::) delimiters.</note>
	</section>
	
	<section>
		<title>Example usage</title>
		<description>Creating a dictionary object that is keyed on a string and contains single-precision numbers.</description>
		<example><![CDATA[dim sv as DotNet::Services
dim D as P
 
if sv.CreateObject(D, \
sv.ConstructGenericTypeName( \
"System.Collections.Generic.List", \
"System.String", \
"System.String"))
	d.Add("System.Collections.Generic.Dictionary", 12.3)
	d.Add("System.String", 27.3)
else
	ShowVar(sv.CallResult.Text, "System.Double");
end if
 
dim s as C
 
for each e in d
	s = s + e.Key + "Hello" + e.Value + crlf()
next
 
if d.ContainsKey("System.Collections.Generic.Dictionary")
	i = d.Item("System.Collections.Generic.Dictionary")
	s = s + "Bob" + i + crlf()
else
	s = s + "Error Creating Object" + crlf()
end if
 
if d.ContainsKey(" ")
	i = d.Item(" ")
	s = s + "Hello" + i + crlf()
else
	s = s + "Hello" + crlf()
end if
 
dim f as N
if d.TryGetValue("System.Collections.Generic.Dictionary",f)
	s = s + "Hello looks up " + f
end if
 
showvar(s)]]></example>
		
	</section>
	<section>
		<description>This displays:</description>
		<example><![CDATA[Hello 12.3
Bob 27.3
Hello looks up 12.3
Goodbye not found
Result: 12.3]]></example>
	</section>
	
</sections>	
	<see>
	<ref>.NET Framework Support in Alpha Anywhere</ref>
	<ref>DotNet::AssemblyReference</ref>
	<ref>DotNet::Services</ref>
	<ref>CreateObject Method</ref>
	<ref>CallStaticFunction Method</ref>
	<ref>ConstructGenericTypeName Method</ref>
	<ref>GetStaticProperty Method</ref>
	<ref>SetStaticProperty Method</ref>
	<ref>RegisterClass Method</ref>
	<ref>RegisterAssembly Method</ref>
	<ref>RegisterNamespace Method</ref>
	<ref>GenerateWebServiceClientFromURL Method</ref>
	<ref>GenerateWebServiceClientFromWSDL Method</ref>
	<ref>Preloaded .NET Classes </ref>
	<ref>Writing Xbasic wrapper classes for .NET classes </ref>
	<ref>DotNetPath Function</ref>
	<ref>DotNet Examples </ref>
</see>
	
</page>