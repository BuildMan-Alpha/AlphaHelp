<page>
   <topic>*PATTERN_LOOKUPI Function</topic>
   <syntax>Result as C = *PATTERN_LOOKUPI(text as c,key as c,pattern as c,otherwise as c)</syntax>
   <arguments>
     <argument>
         <name>Result</name>
         <description>The value returned by the function.</description>
     </argument>
     <argument>
         <name>text</name>
         <description>Contains a delimited list to search for a pattern. The delimiter is the last character in the Pattern string.
</description>
     </argument>
     <argument>
         <name>key</name>
         <description>The value to find in Text.</description>
     </argument>
     <argument>
         <name>pattern</name>
         <description>A string with two "*" placeholders in it. The first placeholder encountered is the Key. The second is the Result to return. The Pattern must have one or more characters between the two placeholders, and a list delimiter at the beginning, at the end, or at both the beginning and end of the Pattern string.
</description>
     </argument>
     <argument>
         <name>otherwise</name>
         <description>The value to return if the Key is not found in the list.</description>
     </argument>
   </arguments>
   <description>Looks up a value matching a key on text, if none found return 'otherwise' condition.</description>
   <discussion>
The *PATTERN_LOOKUPzI() function examines Text for a Key value. If the Key is not found, the function returns Otherwise. Case insensitive.

   </discussion>
   <example><![CDATA[
? *pattern_lookupi("one=1,two=2,three=3","two","*=*,","0") 
 = "2" 

 ? *pattern_lookupi("=1,=2,=3","four","=*,","0") 
 = "0" 

 ? *pattern_lookupi("=1,=2,=3","three","=*,","0") 
 = "3"

]]></example>
   
   <see>
      <ref>List Processing Functions</ref>
   </see>
</page>