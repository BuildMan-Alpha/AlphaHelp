<page>
	<topic>Arrays</topic>
	<sections>
<section>
	<description>To store a series of data values of the same data type together under the same variable name, declare the variable as an array. Arrays are useful for collecting and processing lists of information. They must be explicitly defined with the DIM statement before they are used. The declaration must include the Array Size which is the maximum number of data elements the array will contain.

For example, the following statements declare an array of character strings holding five elements:
</description>
	<example><![CDATA[dim names[5] as C
dim names[1..5] as C
dim names[0..4] as C 'dim a 0 based array
dim names[-3..3] as C 'dim array with 7 elements ]]></example>
	
</section>
<section>
	<description>It is possible to dim multiple array dimensions in one statement.</description>
	<example><![CDATA[dim arr.row[1..10].col[1..5].edited as C ]]></example>
	<note>The first element of an array is 1 (unless the array was specifically dimmed with a different initial index e.g. dim a[0..4] as c).</note>
</section>
<section>
	<description>This array can be used to collect and store a list of five names. The contents of the array elements are assigned like any other variable using the assignment operator ( = ). The number of the element in which you want to put the data must also be supplied. For example:</description>
	<example><![CDATA[names[1] = "Henry"
names[2] = "Burt"
names[3] = "Ernie"
names[4] = "Linda"
names[5] = "Cheryl" ]]></example>
	
</section>
<section>
	<title>Multidimensional Arrays</title>
	<description>In Alpha Anywhere arrays can contain multiple dimensions. For example:</description>
	<example><![CDATA[dim a[3,3,3] as C]]></example>
	
</section>
<section>
	<title>Arrays of Pointers ('Property' Arrays)</title>
	<description>You can define an array of pointers (also called a 'Property' array). For example:</description>
	<example><![CDATA[dim ar[5] as P
ar[1].mom = "Irene"
ar[1].dad = "Abe"
ar[2].mom = "Arlene"
ar[2].dad = "Kyle"
? ar[1].mom
= "Irene"
? ar[1].dad
= "Abe"
? ar[2].mom
= "Arlene"
? ar[2].dad
= "Kyle"
ar.SORT("A","mom")
? ar[1].mom
= "Arlene"
? ar[1].dad
= "Kyle"]]></example>
	
</section>
<section>
	<description>It is useful to visualize an array of pointers like this:</description>
<figure><link>images/chart1.png</link></figure>
	
</section>
<section>
	<description>The array might have more "columns". For example:</description>
	<figure><link>images/chart2.png</link></figure>
	
</section>
<section>
	<description>In this example, ar[3].kids is 1. To sort the array on the "Kids" element, you would type:
</description>
	<example><![CDATA[ar.sort("","kids")]]></example>
	
</section>
<section>
	<title>Nested Arrays</title>
	<description>Alpha Anywhere supports nested arrays. For example:
</description>
	<example><![CDATA[dim row[10] as P
for i = 1 to 10
    dim row[i].col[10] as C
next i
row[1].col[1] = "c"
row[1].col[2] = "b"
row[1].col[3] = "d"
row[2].col[1] = "a"
row[2].col[2] = "x"
row[2].col[3] = "m"
'Sort the elements of the row[1].col array.
'i.e. elements are sorted into this order: b,c,d
row[1].col.sort()]]></example>
	
</section>

<section>
	<title>Examining Arrays in the Interactive Window</title>
	<description>If you are working with an array in the Interactive window, you can examine the contents of an array by typing ? arrayname in the Interactive window. For example:
</description>
	<example><![CDATA[dim Names[3] as C
Names[1] = "John"
Names[2] = "Fred"
Names[3] = "Tom"
? Names
= [1] = "John"
[2] = "Fred"
[3] = "Tom"
 ]]></example>
	
</section>

<section>
	<title>Automatically Inserting Elements into an Array</title>
	<description>Alpha Anywhere supports a special syntax that allows you to automatically insert elements at the end of an array without having to specify the array index. If necessary, Alpha Anywhere will automatically resize the array to accommodate the new entry. Whether resizing also happens when deleting an entry depends on using the .setDynamic(Boolean) method.
For example:
</description>
	<example><![CDATA[dim cities[1] as C
'add a new entry to the array by omitting the array index
cities[] = "boston"
? cities.SIZE()
= 1.000000
? cities
= [1] = "boston"
cities[] = "chicago"
? cities.size()
= 2.000000
? cities
= [1] = "boston"
[2] = "chicago"
]]></example>
	
</section>
<section>
	<description>If you are working with a property array, you can do this.
</description>
	<example><![CDATA[Dim a[1] as P
A[1].name = "Fred"
A[1].city = "Boston"
A[1].age = 23
A[].name = "Tom"
A[..].city = "NY"
A[..].age = 35
 ]]></example>
	
</section>

<section>
	<description>The a[].name = "Tom" adds array element number 2. A[..]. city = "NY" adds "NY" to the newly created array element (i.e. number 2). If you did not use the syntax a[..].city = "NY", but instead did a[].city = "NY" then your array would look like this:
</description>
	<figure><link>images/chart3.png</link></figure>
	
</section>

<section>
	<description>This example shows another common technique used with Property arrays:
</description>
	<example><![CDATA[type Family
   Mother as c 
   Father as c 
end type

'All new array entries will now automatically have a 'Mother' and 'Father' property.
'Notice that the initial array size is dimmed as 0
dim a[0] as {Family}

a[].Mother = "Irene"
a[].Mother = "Ann"
a[..].Father = "Bernard"

?a[1].Father
= ""
?a[2].Father = "Bernard"

A[..].age = 35 ]]></example>
	
</section>

<section>
	<title>Dynamic Array Sizing</title>
	<description>When you delete entries from an array, the array size does not change. With dynamic array sizing turned on, deleting an entry from an array will resize the array. The following Interactive window session demonstrates:
</description>
	<example><![CDATA[dim array[3] as c
array[1] = "alpha"
array[2] = "beta"
array[3] = "gamma"
?array.size()
=3
array.delete(2,1)
?array.dump()
= alpha
gamma
?array.size()
=3

 ]]></example>
	
</section>

<section>
	<description>Now, repeating this exercise, but turning on the array's 'dynamic' property:
</description>
	<example><![CDATA[dim array[3] as c
array.set_dynamic(.t.)
array[1] = "alpha"
array[2] = "beta"
array[3] = "gamma"
?array.size()
=3
array.delete(2,1)
?array.dump()
= alpha
gamma
?array.size()
=2 ]]></example>
	
</section>

<section>
	<description><![CDATA[The <array>.set_dynamic(flag) method can be used to turn on/off the dynamic sizing property of an array. The <array>.get_dynamic() method can be used to determine the state of an array's dynamic sizing property.
If you dim an array with a size of 0 (and then populate the array using the [] syntax), the dynamic sizing property is automatically assumed to be set to True. For example:
 ]]></description>
	<example><![CDATA[dim array[0] as p
array[] = "alpha"
array[] = "beta"
?array.size()
=2
array.delete(2,1)
?array.size()
=1


'This shows that an array dimmed with an initial size of 0 defaults to dynamic properties on, whereas
'an array dimmed with non-zero size defaults to dynamic properties off.
dim arr1[0] as p
dim arr2[1] as p
? arr1.get_dynamic()
= .T.
? arr2.get_dynamic()
= .F.
 ]]></example>
	
</section>

<section>
	<title>Passing Arrays to Functions</title>
	<description>When you pass an array to a function, the receiving function defines the argument as a pointer.
</description>
	<example><![CDATA[Dim a[5] as C
a[1] = "a value"
my_function(a)

function my_function as V (arr as P)
    ui_msg_box("Array Value", arr[1])
end function ]]></example>
	
</section>



	</sections>
	<see>
		<ref>Array Functions and Methods</ref>
<ref>Dot Variables</ref>
	<ref>Collections</ref>	
		<ref>StringDictionary</ref>	
	</see>
	
</page>