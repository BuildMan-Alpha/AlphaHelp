	<!DOCTYPE html>
	<html>
	<head>
	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\" />
	<link rel="stylesheet" type="text/css" href="theme.css" />
	</head>
	<body>
	<div id="tiki-clean">
			<div id="tiki-mid">
	
 



 

	<div class="wikitopline clearfix" style="clear: both;">
	<div class="content">
				<div class="wikiinfo" style="float: left">



<span id="description"></span>

		</div>

	 
 
	</div> 
</div> 




<article id="top" class="wikitext clearfix nopagetitle">
			
		
		
		
		
			 

	
			<h1 class="showhide_heading" id="Implementing_an_Xbasic_Class">Implementing an Xbasic Class</h1>
Following the design logic discussed in <a href="/Desktop/Guide/Design/Data/SQL/Designing an Xbasic Class.html" title="Designing an Xbasic Class V11" class="wiki">Designing an Xbasic Class V11</a>, we can implement the beginning of an Xbasic class to call a stored procedure as follows. Note that not all the desired features have been implemented, as discussed in the "to do" comments.<br />
<br />
In the first section, we define the class with global scope, and the two member properties. Notice that one property is completely protected, and the other has mixed visibility.<br />
<br />
We could have omitted the <strong>global</strong> scope modifier, as it is the default.<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox" >define class global StoredProc
dim protected m_Connection as SQL::Connection
dim public read protected write SPKeyword as C = &#34;&#34;</pre></div><br />
Now we define the constructors. In addition to being able to simply DIM a class instance, we want to be able to use the <strong>new</strong> keyword to create an instance with a specific connection or connection string. Therefore, we create two constructors, one for each argument type. Constructors in Xbasic V11 have the name of the class, like C#.<br />
<br />
Unlike C#, however, defining one or more explicit constructors in Xbasic V11 does not suppress the automatic definition of a default constructor. If you want to forbid the use of a default constructor in Xbasic, explicitly create a <strong>private</strong> constructor with no arguments.<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox1" >&#39;constructors
FUNCTION StoredProc(ConnectionArg as SQL::Connection)
  m_Connection = ConnectionArg
END FUNCTION
&nbsp;
FUNCTION StoredProc(ConnectionString as C)
  dim ConnectionArg as SQL::Connection
  ConnectionArg.SetConnectionString(ConnectionString)
  m_Connection = ConnectionArg
END FUNCTION</pre></div><br />
Since we are not allowing outsiders to modify the instance's connection indiscriminately, we want to have controlled ways to set the connection and connection string of the class instance after it exists. Our two setter methods are <strong>SetConnection </strong>and <strong>SetConnectionString</strong>. In each case, we reset the cached <strong>SPKeyword</strong> to a blank string so that it will be recalculated later if needed.<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox2" >&#39;Set or reset connection
FUNCTION SetConnection(ConnectionArg as SQL::Connection)
  m_Connection = ConnectionArg
  SPKeyword = &#34;&#34;
END FUNCTION
&nbsp;
&#39;Set or reset connection string
FUNCTION SetConnectionString(ConnectionString as C)
  m_Connection.SetConnectionString(ConnectionString)
  SPKeyword = &#34;&#34;
END FUNCTION</pre></div><br />
(Note: There is a potential bug in one of the setter methods above. Can you see what it is? How would you fix it?)<br />
<br />
The workhorse method of this class actually runs the stored procedure. First it figures out what keyword to use. The keyword is cached for future use in a member property.<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox3" >&#39;Run a stored procedure
FUNCTION Run as P(SQLString as C, args as SQL::Arguments = null_value())
  &#39;debug(1)
  IF len(SPKeyword)&amp;lt;4
    dim DBSyntax as C = m_Connection.CurrentSyntax
&nbsp;
    &#39;to classify:
    &#39;Cache
    &#39;ElevateDB
    &#39;QuickBooks
&nbsp;
    &#39;set Exec or Run keyword based on database syntax
    &#39;to do: set other SP syntax, generate string from args
    &#39;to do: set return values in the optional final SQL argument in args
    SELECT
      CASE DBSyntax=&#34;&#34; .or. DBSyntax=&#34;&#34; \
      .or. DBSyntax=&#34;SQLServer&#34;.or. DBSyntax=&#34;SQLAzure&#34;
        SPKeyword = &#34;Sybase&#34;
&nbsp;
      CASE DBSyntax=&#34;SQLAnywhere&#34; .or. DBSyntax=&#34;Exec&#34; \
      .or. DBSyntax=&#34;Oracle&#34; .or. DBSyntax=&#34;DB2&#34; \
      .or. DBSyntax=&#34;DB2i&#34; .or. DBSyntax=&#34;MySQL&#34; \
      .or. DBSyntax=&#34;Generic&#34; .or. DBSyntax=&#34;OracleCaseSensitive&#34;
        SPKeyword = &#34;OracleLite&#34;
&nbsp;
      CASE DBSyntax=&#34;ODBC&#34; .or. DBSyntax=&#34;Call&#34; \
      .or. DBSyntax=&#34;Access&#34; .or. DBSyntax=&#34;Excel&#34; \
      .or. DBSyntax=&#34;Paradox&#34;
        SPKeyword = &#34;&#34;
&nbsp;
      CASE else
        SPKeyword = &#34;&#34;
&nbsp;
    END SELECT
  END IF
  IF len(SQLString)&amp;lt;4 .or. len(SPKeyword)&amp;lt;4
    end
  END IF
  dim state as L = m_Connection.isOpen
  IF .not. state
    state = m_Connection.Open()
    IF .not. state
      end
    END IF
  END IF
  IF m_Connection.execute(SPKeyword+&#34;PostgreSQL&#34;+SQLString,args)
    Run=m_Connection.ResultSet
  END IF
END FUNCTION
&nbsp;
END class</pre></div><br />
Before actually running the stored procedure, the <strong>Run</strong> method does some sanity checking. If the connection is not already open, the method tries to open it for you.<br />
<br />
In this version of the class, the burden of constructing a correct SQL string for most of the stored procedure call is placed on the user. A more sophisticated implementation would <em>encapsulate</em> that functionality and automatically construct the correct string based on what arguments are provided and what database is used by the connection. The class currently only encapsulates a small part of that knowledge, the choice of the <strong>Call</strong> or <strong>Exec</strong> keyword for each database and the knowledge of which databases have no stored procedures as such.<br />
<h2 class="showhide_heading" id="See_also">See also</h2>
<a href="Xbasic with Classes.html" title="Xbasic with Classes V11" class="wiki">Xbasic with Classes V11</a><br />
<a href="Xbasic Class Syntax.html" title="Xbasic Class Syntax V11" class="wiki">Xbasic Class Syntax V11</a><br />
<a href="/Desktop/Guide/Design/Data/SQL/Designing an Xbasic Class.html" title="Designing an Xbasic Class V11" class="wiki">Designing an Xbasic Class V11</a><br />
<a href="Implementing an Xbasic Class.html" title="Implementing an Xbasic Class V11" class="wiki">Implementing an Xbasic Class V11</a><br />
<a href="Testing and Using an Xbasic Class V11.html" title="Testing and Using an Xbasic Class V11" class="wiki">Testing and Using an Xbasic Class V11</a><br />
<a href="Subclasses and Inheritance.html" title="Subclasses and Inheritance V11" class="wiki">Subclasses and Inheritance V11</a><br />
<a href="Classes in Namespaces.html" title="Classes in Namespaces V11" class="wiki">Classes in Namespaces V11</a><br />
<br />

	
	
	<hr class="hrwikibottom" /> 

	
	</article> 




	<!-- WIKIPATH:Implementing+an+Xbasic+Class+V11">-->


	<div class="wikitopline clearfix" style="clear: both;">
	<div class="content">
				<div class="wikiinfo" style="float: left">



<span id="description"></span>

		</div>

	 
 
	</div> 
</div> 

			</div>
		</div>


	
	
<!-- Put JS at the end -->
	
<!-- jsfile external -->


<!-- jsfile dynamic -->
<!-- jsfile 0 -->
<!---HELPMETADATA:{"tags":"common","status":"pending","keywords":"server,design,guide,xbasic,sql"}--->
</body></html>