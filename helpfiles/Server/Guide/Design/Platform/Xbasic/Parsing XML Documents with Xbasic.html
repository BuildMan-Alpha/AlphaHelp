	<!DOCTYPE html>
	<html>
	<head>
	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\" />
	<link rel="stylesheet" type="text/css" href="theme.css" />
	</head>
	<body>
	<div id="tiki-clean">
			<div id="tiki-mid">
	
 



 

	<div class="wikitopline clearfix" style="clear: both;">
	<div class="content">
				<div class="wikiinfo" style="float: left">



<span id="description"></span>

		</div>

	 
 
	</div> 
</div> 




<article id="top" class="wikitext clearfix nopagetitle">
			
		
		
		
		
			 

	
			<h1>Parsing XML Documents with Xbasic</h1>

<p>Alpha Five has a powerful XML parser built-in that can be used as an 
alternative to the Microsoft XML parser. The advantage of the Xbasic XML parser 
is that it can use all of the powerful string functions in Xbasic. The Microsoft 
XML parsers are more complex to use because you have to use OLE Automation. </p>
<p>With the Alpha Five XML parser you can:</p>
<ul>
<li>Extract information from XML data</li>
<li>Transform XML data (much like an XSLT)</li>
<li>Add elements and attributes to XML data</li>
<li>Remove elements and attributes from XML data</li>
<li>Change attribute values in XML data</li>
<li>Reorder elements in XML data</li>
</ul>

<h2>Using the Xbasic XML Parser - A Tutorial</h2>
<p>Assume that you have an XML file with the following data in it:</p>
<p>&nbsp;</p>
<p class="xbasic">&ltemployee></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp; &ltname city="Boston"></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Frank&lt/firstname></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Smith&lt/lastname></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp; &lt/name></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp; &ltname city="Ithaca"></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Milton&lt/firstname></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Jones&lt/lastname></p>
<p class="xbasic">&nbsp;&nbsp;&nbsp; &lt/name></p>
<p class="xbasic">&lt/employee></p>
<p>&nbsp;</p>
<p>The following sample Interactive window session shows some of the features of 
the XML parser:</p>
<p>&nbsp;</p>
<p class="xbasic">'Get a new instance of the XML parser</p>
<p class="xbasic">sm = xmlSchemaManager.Get()</p>
<p class="xbasic">'Load the XML file into a variable<br>
xml = get_from_file("<a href="file:///c:/data/testxml.xml">c:\data\testxml.xml</a>")</p>
<p class="xbasic">'Load the XML data into the XML parser.</p>
<p class="xbasic">'The .LoadXML() method or the .LoadUnBalancedXML() method can 
be used.</p>
<p class="xbasic">'If you want to parse HTML (where unbalanced tags are 
allowed), then the .LoadUnBalancedXML() method</p>
<p class="xbasic">'should be used<br>
dom = sm.LoadXML(xml)<br>
&nbsp;</p>
<p class="method"><span style="font-weight: 400">TIP: Xbasic also provides a 
simple high level function to get a parsed XML document in a single step 
(without having to first instantiate the xmlSchemaManager object). The *XML_Document() 
function can also be used.</span></p>
<p class="method"><span style="font-weight: 400">The following single Xbasic 
command is equivalent to the commands above parse the XML document:</span></p>
<p class="xbasic"><span style="font-weight: 400">dom = *XML_Document(xml)</span></p>
<p class="method">&nbsp;</p>
<p class="method"><span style="font-weight: 400">Once you have loaded the XML 
data into the schema manager (i.e. you have parsed the XML - it is loaded into a 
'parse tree'), you can start examining the properties and working with the 
methods of the schema manager. For example:</span></p>
<p class="method">&nbsp;</p>
<p class="xbasic">'The .top property references the outermost element.</p>
<p class="xbasic">'All elements have an .OuterXML property (among many other 
properties)</p>
<p class="xbasic">'Notice that the bubble help in the Interactive window will 
show you all of the properties.</p>
<p class="xbasic">&nbsp;</p>
<p class="xbasic"><span style="font-weight: 400">?dom.top.OuterXML</span></p>
<p class="xbasic">= &ltemployee><br>
&nbsp;&nbsp;&nbsp; &ltname city="Boston"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Frank&lt/firstname><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Smith&lt/lastname><br>
&nbsp;&nbsp;&nbsp; &lt/name><br>
&nbsp;&nbsp;&nbsp; &ltname city="Ithaca"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Milton&lt/firstname><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Jones&lt/lastname><br>
&nbsp;&nbsp;&nbsp; &lt/name><br>
&nbsp;&nbsp; &lt/employee></p>
<p class="xbasic">&nbsp;</p>
<p>When the XML is parsed an array of all of the elements is automatically 
created. </p>
<p>&nbsp;&nbsp;&nbsp; </p>
<p class="xbasic">'The XML data has 7 elements</p>
<p class="xbasic">?dom.all.size()</p>
<p class="xbasic">= 7</p>
<p class="xbasic">&nbsp;</p>
<p class="xbasic">'The .Output() method can be used to dump information from the 
XML parse tree.</p>
<p class="xbasic">'The .Output() method can use specially named symbols in the 
output expression. </p>
<p class="xbasic">'For example, *elementId is the index into the 'all' array 
(seen above), and</p>
<p class="xbasic">'*tag is the name of the element. The output expression is a 
standard Xbasic expression.</p>
<p class="xbasic">&nbsp;</p>
<p class="xbasic">?dom.Output("*elementId +' ' +*tag +crlf()")<br>
= 1 employee<br>
2 name<br>
3 firstname<br>
4 lastname<br>
5 name<br>
6 firstname<br>
7 lastname</p>
<p class="xbasic">&nbsp;</p>
<p>&nbsp;</p>

<p class="xbasic">&nbsp;</p>

<p class="xbasic">'Note that in this output expression, 'city' is an attribute 
value (we can tell because it does not start with *)</p>

<p class="xbasic">'Any 'fields' in the output expression that don't start with * 
are attribute names.</p>

<p class="xbasic">'Notice that only elements 2 and 5 have values for the 'city' 
attribute because the 'city'</p>

<p class="xbasic">'attribute is only defined for the 'name' element.</p>

<p class="xbasic">?dom.Output("*elementId +' ' +*tag + ' - ' + city + crlf()")<br>
= 1 employee - <br>
2 name - Boston<br>
3 firstname - <br>
4 lastname - <br>
5 name - Ithaca<br>
6 firstname - <br>
7 lastname - <br>
&nbsp;</p>

<p class="xbasic">'The 'all' array contains all of the XML elements</p>

<p class="xbasic">'The outerXML property is the entire XML string for that 
element</p>

<p class="xbasic">?dom.all[5].outerxml<br>
= &ltname city="Ithaca"><br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&lt/name><br>
&nbsp;</p>

<p class="xbasic">&nbsp;</p>

<p class="xbasic">'The innerXML property is the XML that is contained by that 
element.<br>
?dom.all[5].innerxml<br>
= <br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&nbsp;</p>

<p>Once you have parsed the XML, it is easy to modify it. For example, here is 
how we can delete elements in the XML data. This section shows how nodes in the 
XML tree can be 'marked' and then deleted.</p>
<p class="xbasic">&nbsp;</p>

<p class="xbasic">'Make sure all elements are initially unmarked</p>

<p class="xbasic">'If .T. is returned, then there were some marked elements.</p>

<p class="xbasic">'If .F. is returned, then there were no marked elements.</p>

<p class="xbasic">'In this case since we have not previously marked any 
elements, .F. is returned.</p>

<p class="xbasic">?dom.UnmarkAllElements()<br>
= .F.<br>
&nbsp;</p>

<p class="xbasic">'Now mark all elements that have a 'city' attribute equal to 
'Boston'</p>

<p class="xbasic">'Note that the query expression is a standard Xbasic filter 
expression</p>

<p class="xbasic">'No need for cryptic XPath syntax!!</p>

<p class="xbasic">'The second argument is set to .T.. This causes the child 
elements of each found</p>

<p class="xbasic">'element to also be marked.</p>

<p class="xbasic">'The method returns .T. in this case, indicating that at least 
one match was found.</p>

<p class="xbasic">?dom.MarkElements("city='boston'",.t.)<br>
= .T.</p>

<p class="xbasic">&nbsp;</p>

<p class="xbasic">'Now delete the marked elements<br>
dom.DeleteMarked()<br>
<br>
&nbsp;</p>

<p class="xbasic">'Examine the resulting XML</p>

<p class="xbasic">'It looks as expected, but it contains blank rows where the 
deleted elements were.<br>
?dom.top.OuterXML<br>
= &ltemployee><br>
<br>
&nbsp;&nbsp;&nbsp; &ltname city="Ithaca"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Milton&lt/firstname><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Jones&lt/lastname><br>
&nbsp;&nbsp;&nbsp; &lt/name><br>
&lt/employee><br>
<br>
&nbsp;</p>

<p class="xbasic">'Call the .reformat() method and examine the XML again<br>
dom.Reformat()<br>
?dom.top.OuterXML<br>
= &ltemployee><br>
&nbsp;&nbsp;&nbsp; &ltname city="Ithaca"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Milton&lt/firstname><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Jones&lt/lastname><br>
&nbsp;&nbsp;&nbsp; &lt/name><br>
&nbsp;&lt/employee><br>
<br>
<br>
&nbsp;</p>
<p>Xbasic has several ways in which you can navigate the XML DOM after it has 
been parsed.</p>
<p>First, lets find out how many nodes exist at the top level of the XML tree.</p>
<p class="xbasic">?dom.top.children.size()<br>
= 2<br>
&nbsp;</p>
<p>There are two nodes. Let's get a pointer to the first node.</p>
<p class="xbasic">c1 = dom.top.children[1]</p>
<p>&nbsp;</p>
<p>This object now has several properties, one of which is 'OuterXML'. This 
property can be read, and set.<br>
Let's first examine it:</p>
<p class="xbasic">?c1.OuterXML<br>
= &ltname city="Boston"><br>
&ltfirstname>Frank&lt/firstname><br>
&ltlastname>Smith&lt/lastname><br>
&lt/name></p>
<p class="xbasic">&nbsp;</p>
<p>Now, let's set it to a new value:</p>
<p class="xbasic">c1.OuterXML = "&ltname city=\"Atlanta\">&lt/name>"<br>
&nbsp;</p>
<p>And now let's examine the entire XML tree to see our change:</p>
<p class="xbasic">&nbsp;</p>
<p class="xbasic">?dom.top.OuterXML<br>
= &ltemployee><br>
&ltname city="Atlanta"/><br>
&ltname city="Ithaca"><br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&lt/name><br>
&lt/employee><br>
&nbsp;</p>
<p>Note that the 'InnerXML' property is similar to the 'OuterXML' property, but 
it does not include the enclosing tags:</p>
<p class="xbasic"><br>
?dom.top.children[2].innerXML<br>
= <br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
<br>
&nbsp;</p>
<p>Each element in the XML tree can have an arbitrary number of attributes. You 
can read and set these attributes, and&nbsp; you can create new attributes. In 
our example, 'city' is an attribute of the 'Name' element.</p>
<p>To find out how many attributes a particular element has, get a pointer to 
the element and then use the .attribute.size() method. For example, let's 
examing the second element in our XML tree.</p>
<p>First, get a pointer to the element:</p>
<p class="xbasic">c2 = dom.top.children[2]</p>
<p>See how many attributes this element has:</p>
<p class="xbasic">?c2.attribute.size()<br>
= 1<br>
&nbsp;</p>
<p>Check to see if a particular attribute of this element exists:</p>
<p class="xbasic">?c2.AttributeExists("city")<br>
= .T.</p>
<p>&nbsp;</p>
<p>Now, get the attribute's value:</p>
<p class="xbasic">?c2.AttributeGet("city")<br>
= "Ithaca"<br>
&nbsp;</p>
<p>Now, set the attribute to a new value:</p>
<p class="xbasic">c2.AttributeSet("city","Binghamton")<br>
&nbsp;</p>
<p>Inspect the element's 'OuterXML' to confirm that the change was made:</p>
<p class="xbasic">?c2.OuterXML<br>
= &ltname city="Binghamton"><br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&lt/name><br>
&nbsp;</p>
<p>Now create a new attribute for the element:</p>
<p class="xbasic">c2.AttributeSet("population","123000")<br>
&nbsp;</p>
<p>And again, inspect the element's 'OuterXML':</p>
<p class="xbasic">?c2.OuterXML<br>
= &ltname city="Binghamton" Population="123000"><br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&lt/name></p>
<p>&nbsp;</p>
<p>If we check the size of the 'attribute' array, we see that it now has two 
entries:</p>
<p class="xbasic">?c2.attribute.size()<br>
= 2</p>
<p>&nbsp;</p>
<p>We can read the name of the value of any entry in the 'attribute' array:</p>
<p class="xbasic">?c2.attribute[1].name <br>
= "city"<br>
?c2.attribute[1].value <br>
= "Binghamton"<br>
&nbsp;</p>
<p>Attributes can be dropped:</p>
<p class="xbasic"><br>
c2.AttributeDrop("population")<br>
?c2.OuterXML<br>
= &ltname city="Binghamton"><br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&lt/name><br>
<br>
&nbsp;</p>





































<h3>Running Queries against the XML Data</h3>
























































<h4>Element Queries</h4>



















<p>The Xbasic XML parser lets you run queries against your XML file using 
familiar Xbasic query syntax. There is no need to learn complicated QPath 
syntax, which is normally used to query XML files.</p>
<p>In the following example, we run element queries. You can also run attribute 
queries, which we show later. The .queryElement() method is used to run element 
queries. This method creates an 'element array' - an array of all elements that 
match the query expression. (You can think of an element query as returning a 
'pruned' version of the DOM - without a top node.)</p>
<p>In this example, we find all elements that have a tag name of 'firstname':</p>
<p class="xbasic">q2 = dom.QueryElement("*tag = 'firstname'")</p>
<p>We can find out how many elements were found by calling the .size() method of 
the 'all' object:</p>
<p class="xbasic">?q2.all.size()<br>
= 2</p>
<p>We can dump the values of the elements:</p>
<p class="xbasic">?q2.Output("*value+crlf()")<br>
= Frank<br>
Milton<br>
&nbsp;</p>
<p>Now, let's do a more complex search. Notice that we are using familiar Xbasic 
filter syntax:</p>
<p class="xbasic">q3 = dom.QueryElement("*tag = 'name' .and. city = 'boston'")<br>
?q3.all.size()<br>
= 1<br>
<br>
?q3.all[1].outerXML<br>
= &ltname city="Boston"><br>
&ltfirstname>Frank&lt/firstname><br>
&ltlastname>Smith&lt/lastname><br>
&lt/name><br>
&nbsp;</p>
<p>Note that the query object is still linked to the XML parser. Any changes 
made to the XML when working with the results of a query will be reflected in 
the full XML tree (i.e. the XML shown by dom.top.OuterXML in these examples).<br>
&nbsp;</p>





































<h4>Attribute Queries</h4>



















<p>Attribute queries are typically less useful. An attribute query returns an 
'attribute array' - an array of all attributes that match the 'filter' 
ex<x>pression. (In the case of an attribute query, you do not enter a logical 
filter expression. Instead, you specify a CR-LF delimited list of attribute 
names).</p>
<p>&nbsp;</p>
<p>Let's add a new attribute to our XML and then do an attribute query:</p>
<p class="xbasic">c1 = dom.top.children[1]</p>
<p class="xbasic">c1.AttributeSet("state","MA")</p>
<p class="xbasic">qa1 = dom.queryAttributes("state")</p>
<p class="xbasic">?qa1.all.size()</p>
<p class="xbasic">=1</p>
<p class="xbasic">?qa1.all<a class="wiki"  href="1" rel="">1</a>.value</p>
<p class="xbasic">= "MA"</p>
<p>&nbsp;</p>
<p>Now, let's search for multiple attributes:</p>
<p>&nbsp;</p>
<p class="xbasic">qa1 = dom.queryAttributes("state" + crlf() + "name")</p>
<p class="xbasic">?qa1.all.size()</p>
<p class="xbasic">=3</p>
<p class="xbasic">?qa1.all[1].value</p>
<p class="xbasic">= "MA"</p>
<p class="xbasic">?qa1.all[1].name </p>
<p class="xbasic">= "state"</p>
<p>&nbsp;</p>
<p>The .DumpFormat(), .GetValues() and .SetValues() methods can be used with the 
result of an Attribute query, as shown below:</p>
<p>&nbsp;</p>
<p>Here we dump out the element name, attribute name and value of each item in 
the array returned by the attribute query:</p>
<p class="xbasic"><br>
?qa1.DumpFormat("E.N=V" + crlf() )<br>
= name.state=MA<br>
name.city=Boston<br>
name.city=Ithaca<br>
&nbsp;</p>
<p>Here we get a CR-LF delimited list of attribute values:</p>
<p class="xbasic">?qa1.GetValues()<br>
= MA<br>
Boston<br>
Ithaca<br>
&nbsp;</p>
<p>Now, lets do some transformation on these values:</p>
<p class="xbasic">list = qa1.GetValues()<br>
list = alltrim( upper(list) )<br>
qa1.SetValues(list)<br>
<br>
?dom.top.OuterXML<br>
= &ltemployee><br>
&ltname city="BOSTON" state="MA"><br>
&ltfirstname>Frank&lt/firstname><br>
&ltlastname>Smith&lt/lastname><br>
&lt/name><br>
&ltname city="ITHACA"><br>
&ltfirstname>Milton&lt/firstname><br>
&ltlastname>Jones&lt/lastname><br>
&lt/name><br>
&lt/employee><br>
<br>
&nbsp;</p>
<p><b>Important:</b> If your XML tree does not have a top element, the XML parser will 
automatically insert one.</p>
<p class="xbasic">&nbsp;</p>





































<h3>XML Parser Expression Reserved Words</h3>



















<p>The following table show a list of reserved words that can be used where 
expressions can be used (i.e. with the .Output(), .QueryElement()&nbsp; .MarkElements(), 
UnmarkElements(), .Resolve(), and .FindElement() methods)</p>
<p>&nbsp;</p>
<table id="table3" style="BORDER-COLLAPSE: collapse" cellSpacing="1" cellPadding="3" border="1">
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
<b>Reserved Word</b></td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
<b>Meaning</b></td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*elementId</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Index into the all[] array. This is the order in which the 
                elements appear in the XML data.</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*value</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Contents of the XML element as raw text</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*xml</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Inner XML of an element</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*istop</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Returns .T. if the element is the top most element</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*tagnumber</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
child number of the element within the current parent element</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*tagcount</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
number of siblings for this element</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*isleaf</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Returns .T. if an element has no children</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*depth</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
How many nodes deep is the current element (if *istop is .T., 
                then *depth is 1)</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*marked</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Returns .T. if the current element has been marked. Tags are 
                marked by setting the element's .Marked property, or by called 
                the .MarkElements() method.</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*fullname</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
The fully qualified tag name. A dot separated list of this tag 
name and all of the parents. Assume you have an &ltemployees> tag 
with a child &ltname> tag, with a child &ltfirstname> tag. The *fullname 
of the 'firstname' tag is 'employees.name.firstname'.</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top" >
*tag</td>
<td width="1062" style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
The current element name. The *tag reserved words can be used 
with the following 'navigation' directives. Navigation 
directives are delimited with periods:<br>
*parent - the parent tag<br>
*prev - the previous sibling<br>
*next - the next sibling<br>
*first - the fist sibling on the current branch<br>
*last - the last sibling on the current branch.<br>
<br>
Navigation directives can be nested to an arbitrary depth. For 
example:<br>
*tag.*parent.*parent.*next - the&nbsp; next sibling of the 
current tag's grandparent tag.<p>&nbsp;</p>
<p>&nbsp;</p>
<p>This sytax can also be used to get attribute values. For 
example, the following syntax will get the value of the 'city' 
attribute from the current element's parent element.</p>
<p>*tag.*parent.city</p>
<p>&nbsp;</p>
<p>&nbsp;</td>
</tr>
</table>

<p>&nbsp;</p>
<p>The following example shows how the navigation directives can be used to 
create complex output:</p>
<p class="xbasic">q1 = dom.QueryElement("*tag = 'firstname'")<br>
?q1.Output("*value + ' ' + *tag.*next.*value + ' from ' + *tag.*parent.city + 
crlf()")<br>
= Frank Smith from BOSTON<br>
Milton Jones from ITHACA<br>
&nbsp;</p>
<p class="xbasic">&nbsp;</p>





































<h3>Marking Elements in the XML Tree</h3>



















<p>Marking elements is useful because it allows you to move and delete elements 
from the XML tree. You can use an Xbasic filter expression to select the 
elements that you want to mark. Having marked elements, you can then methods to 
move and delete the marked elements.</p>
<p>For example:</p>
<p>&nbsp;</p>
<p class="xbasic">?dom.top.OuterXML<br>
= &ltemployee><br>
&nbsp;&nbsp;&nbsp; &ltname city="BOSTON" state="MA"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Frank&lt/firstname><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Smith&lt/lastname><br>
&nbsp;&nbsp;&nbsp; &lt/name><br>
&nbsp;&nbsp;&nbsp; &ltname city="ITHACA"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltfirstname>Milton&lt/firstname><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &ltlastname>Jones&lt/lastname><br>
&nbsp;&nbsp;&nbsp; &lt/name><br>
&lt/employee></p>
<p><br>
<br>
Now, let's mark the element that has a city attribute equal to 'Boston':</p>
<p class="xbasic">?dom.MarkElements("city='boston'")<br>
= .T.</p>
<p>Note that .t. indicates that at least one element was selected and marked.</p>
<p>&nbsp;</p>
<p>This shows that the first element of the top parent was marked, and the 
second was not marked.<br>
&nbsp;</p>
<p class="xbasic">?dom.top.children<a class="wiki"  href="1" rel="">1</a>.marked <br>
= .T.<br>
?dom.top.children<a class="wiki"  href="2" rel="">2</a>.marked <br>
= .F.<br>
&nbsp;</p>
<p>Get a pointer to the second element of the top parent</p>
<p class="xbasic">c2 = dom.top.children<a class="wiki"  href="2" rel="">2</a></p>
<p>&nbsp;</p>
<p>Now move all of the marked elements after this element:</p>
<p class="xbasic">c2.MoveMarkedAfter()<br>
<br>
&nbsp;</p>
<p>And here is how the XML tree has been transformed:</p>
<p class="xbasic">?dom.top.OuterXML<br>
= &ltemployee></p>
<p class="xbasic">&ltname city="ITHACA"><br>
&nbsp;&nbsp;&nbsp; &ltfirstname>Milton&lt/firstname><br>
&nbsp;&nbsp;&nbsp; &ltlastname>Jones&lt/lastname><br>
&lt/name><br>
&ltname city="BOSTON" state="MA"><br>
&nbsp;&nbsp;&nbsp; &ltfirstname>Frank&lt/firstname><br>
&nbsp;&nbsp;&nbsp; &ltlastname>Smith&lt/lastname><br>
&lt/name>&lt/employee><br>
<br>
&nbsp;</p>
<p>The following methods are useful for working with marked elements:</p>
<table style="BORDER-COLLAPSE: collapse" cellSpacing="1" cellPadding="3" border="1">
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
&ltdocument>.MarkElements()</td>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Marks elements that satisfy a query expression. NOTE: Remember to unmark 
all elements before doing a new query to mark elements!</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
&ltdocument>.UnmarkAllElements()</td>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Unmark all elements.</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
&ltdocument>.UnmarkElements()</td>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Unmark elements selected by a query expression.</td>
</tr>
<tr>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
&ltdocument>.DeleteMarked()</td>
<td style="font-family: Tahoma; font-size: 8pt; vertical-align: top">
Remove marked elements from the XML tree.</td>
</tr>
<tr>
<td>&ltelement>.MoveMarkedAfter()</td>
<td>Move all marked elements after this element.</td>
</tr>
<tr>
<td>&ltelement>.MoveMarkedBefore()</td>
<td>Move all marked elements before this element.</td>
</tr>
<tr>
<td>&ltelement>.MoveMarkedInside()</td>
<td>Move all marked elements to be children of the current element.</td>
</tr>
</table>
<p>&nbsp;</p>





































<h3>XML Helper Functions</h3>



















<p>A common requirement with working with XML data is to quickly extract some 
attribute values from an XML element. Xbasic provides a function to do this. The 
*XML_PEEK_ATTRIBUTE() function can be used to extract attribute values from a 
top level element in a XML element. The following examples demonstrate the 
function.</p>
<p class="xbasic">xml = "&ltdata city='Boston' firstname='Fred' lastname='Smith'/>"</p>
<p class="xbasic"><span style="font-weight: 400">
?*XML_PEEK_ATTRIBUTE(xml,"city")<br>
= "Boston"</span></p>
<p class="xbasic"><span style="font-weight: 400">?*XML_PEEK_ATTRIBUTE(xml,"firstname")<br>
= "Fred"</span></p>

	
	
	<hr class="hrwikibottom" /> 

	
	</article> 




	<!-- WIKIPATH:Parsing+XML+Documents+with+Xbasic+V9">-->


	<div class="wikitopline clearfix" style="clear: both;">
	<div class="content">
				<div class="wikiinfo" style="float: left">



<span id="description"></span>

		</div>

	 
 
	</div> 
</div> 

			</div>
		</div>


	
	
<!-- Put JS at the end -->
	
<!-- jsfile external -->


<!-- jsfile dynamic -->
<!-- jsfile 0 -->
<!---HELPMETADATA:{"tags":"common","status":"pending","keywords":"server,design,guide,xbasic"}--->
</body></html>