<!DOCTYPE html>
<html>
<head>
<meta name="generator" content=
"HTML Tidy for HTML5 for Windows version 5.1.2">
<meta http-equiv="\&quot;Content-Type\&quot;" content=
"\&quot;text/html;" charset="ISO-8859-1\&quot;">
<link rel="stylesheet" type="text/css" href="theme.css">
<title></title>

<style type="text/css">
 span.c17 {color: #008080; font-style: italic;}
 pre.c16 {white-space:pre-wrap; white-space:-moz-pre-wrap !important; white-space:-pre-wrap; white-space:-o-pre-wrap; word-wrap:break-word;}
 span.c15 {color: #ff0000;}
 span.c14 {color: #808080; font-style: italic;}
 span.c13 {color: #66cc66;}
 span.c12 {color: #cc66cc;}
 span.c11 {color: #993333; font-weight: bold;}
 span.c10 {color:#090; background:}
 span.c9 {color: #FF0000;}
 span.c8 {color: #008000;}
 pre.c7 {overflow:auto;}
 span.c6 {color: #808080;}
 span.c5 {color: #000000;}
 span.c4 {color: #0000FF;}
 span.c3 {color: #FF8000;}
 span.c2 {color: #0600FF;}
 div.c1 {clear: both; float: left}
</style>
</head>
<body>
<div id="tiki-clean">
<div id="tiki-mid">
<div class="wikitopline content wikiinfo c1"><span id=
"description"></span></div>
<article id="top" class="wikitext nopagetitle">
<h1 class="showhide_heading" id="Common_Geography_Database_Tasks">
Common Geography Database Tasks</h1>
<p class="showhide_heading">
&nbsp;</p>
<div>
<div>
<h3>Table of contents</h3>
</div>
<div class="helpserver_toc"></div>
<ul>

<ul>
	<li>
		<a href="#Getting_Table_Information_for_Geometry_Columns" class='link'>Getting Table Information for Geometry Columns</a>
	</li>
	<li>
		<a href="#Define_a_Geography_Column_in_a_SQL_Table" class='link'>Define a Geography Column in a SQL Table</a>
	</li>
	<li>
		<a href="#Create_a_Location_Line_or_Polygon_in_Portable_SQL" class='link'>Create a Location, Line, or Polygon in Portable SQL</a>
	<ul>
		<li>
			<a href="#GeogCreateLocation" class='link'>GeogCreateLocation</a>
		</li>
		<li>
			<a href="#GeogCreateLine" class='link'>GeogCreateLine</a>
		</li>
		<li>
			<a href="#GeogCreatePolygon" class='link'>GeogCreatePolygon</a>
		</li>
	</ul>
	</li>
	<li>
		<a href="#Retrieving_Geography_Properties" class='link'>Retrieving Geography Properties</a>
		<ul>
			<li>
				<a href="#For_All_Objects" class='link'>For All Objects</a>
			</li>
			<li>
				<a href="#For_Points" class='link'>For Points</a>
			</li>
		</ul>
	</li>
	<li>
		<a href="#Converting_Geography_Objects_to_Well-Known_Formats" class='link'>Converting Geography Objects to Well-Known Formats</a>
		<ul>
			<li>
				<a href="#GeogAsBinary" class='link'>GeogAsBinary</a>
			</li>
			<li>
				<a href="#GeogAsText" class='link'>GeogAsText</a>
			</li>
			<li>
				<a href="#GeogCreateFromBinary" class='link'>GeogCreateFromBinary</a>
			</li>
			<li>
				<a href="#GeogCreateFromText" class='link'>GeogCreateFromText</a>
			</li>
		</ul>
	</li>
	<li>
		<a href="#Comparing_Geographic_Objects_Using_SQL" class='link'>Comparing Geographic Objects Using SQL</a>
		<ul>
			<li>
				<a href="#GeogDistanceBetween" class='link'>GeogDistanceBetween</a>
			</li>
			<li>
				<a href="#GeogLocationIntersectsLine" class='link'>GeogLocationIntersectsLine</a>
			</li>
			<li>
				<a href="#GeogLocationIsWithinPolygon" class='link'>GeogLocationIsWithinPolygon</a>
			</li>
			<li>
				<a href="#GeogLocationIsWithinRadius" class='link'>GeogLocationIsWithinRadius</a>
			</li>
		</ul>
	</li>
	<li>
		<a href="#Returning_Database_Values_into_the_Geography_Object"class='link'>Returning Database Values into the Geography Object</a>
		<ul>
			<li>
				<a href="#SQL::ResultSet::DataAsGeography" class='link'>SQL::ResultSet::DataAsGeography</a>
			</li>
			<li>
				<a href="#SQL::ResultSet::Data" class='link'>SQL::ResultSet::Data</a>
			</li>
		</ul>
	</li>
	<li>
		<a href="#See_Also" class='link'>See Also</a>
	</li>
</ul>
</li>
</ul>
</div>
</div>
<br>
<h2 class="showhide_heading" id=
"Getting_Table_Information_for_Geometry_Columns">Getting Table
Information for Geometry Columns</h2>
Alpha Five SQL::TableInfo object describes a SQL table, its
columns and indexes in a database independent way. Column
definitions in the SQL::TableInfo objects can be populated:<br>
<ul>
<li>Directly in XBasic using "intermediate" types - a rich set of
types independent of any specific database</li>
<li>From schema information for a SQL table using the
SQL::Connection object GetTableInfo function</li>
<li>From a DBF table definition by calling the SQL::Connection
objects GetTableInfoFromDBF function</li>
</ul>
<div class="plugincode" parse="vbnet">
<pre class="codelisting c7" data-syntax="vbnet" dir="ltr" id=
"codebox">dim TI <span class=
"c3">as</span> SQL::TableInfo
Connection.GetTableInfo<span class=
"c5">(</span>TI, &#34;MyTable&#34;<span class=
"c5">)</span>
Connection.GetTableInfoFromDBF<span class=
"c5">(</span>TI, &#34;MyTable&#34;<span class=
"c5">)</span></pre></div>
<br>
<h2 class="showhide_heading" id=
"Define_a_Geography_Column_in_a_SQL_Table">Define a Geography
Column in a SQL Table</h2>
There are several functions that can be used to create a table from
a SQL::TableInfo object instance. The simplest is to use the
connection object and call its CreateTable function as shown
below.<br>
<br>
<div class="plugincode" parse="vbnet">
<pre class="codelisting c7" data-syntax="vbnet" dir="ltr" id=
"codebox1">dim TI <span class=
"c3">as</span> SQL::TableInfo
Connection.CreateTable<span class=
"c5">(</span>TI)</pre></div>
<br>
<br>
The intermediate type for geography objects is predictably
"geography". To set the value of a table info column you would
write the following script:<br>
<br>
<div class="plugincode" parse="vbnet">
<pre class="codelisting c7" data-syntax="vbnet" dir="ltr" id=
"codebox2">dim Col <span class=
"c3">as</span> SQL::DataTypeInfo
Col.Name <span class=
"c8">=</span> &#34;MyTable&#34;
Col.IntermediateType <span class=
"c8">=</span> SQL::IntermediateType::Geography
TI.AddColumn<span class=
"c5">(</span>Col)</pre></div>
<br>
<br>
Here is a more complete example of creating a table with a geometry
column using XBasic:<br>
<br>
<div class="plugincode" parse="vbnet">
<pre class="codelisting c7" data-syntax="vbnet" dir="ltr" id=
"codebox3">dim TI as SQL::TableInfo
dim Col as SQL::DataTypeInfo
dim PK as SQL::IndexInfo
dim IXC as SQL::IndexcolumnInfo

TI.Name = &quot;Location&quot;

Col = new SQL::DataTypeInfo()
Col.Name = &quot;GeogTest&quot;
Col.AlphaType = &quot;KeyValue&quot;
Col.Length = 25
Col.Nullable = .f.
TI.AddColumn(Col)

Col = new SQL::DataTypeInfo()
Col.Name = &quot;MyTable&quot;
Col.IntermediateType = SQL::IntermediateType::Geography
Col.Nullable = .f.
TI.AddColumn(Col)

PK.AddColumn = &quot;C&quot;
PK.Name = .PrimaryKey.
t.Unique = .t.
PK.Name = &quot;KeyValue&quot;
PK.AddColumn(IXC)
TI.Unique(PK)

CreateTestTable = Connection.CreateTable(TI)</pre></div>
<br>
<h2 class="showhide_heading" id=
"Create_a_Location_Line_or_Polygon_in_Portable_SQL">Create a
Location, Line, or Polygon in Portable SQL</h2>
Location, Line and Polygon objects can be created using the
portable SQL functions <strong>GeogCreateLocation</strong>,
<strong>GeogCreateLine</strong> and
<strong>GeogCreatePolygon</strong> respectively.<br>
<br>
Each of the portable function can be used to construct a native
geography object in SQL. The functions are expanded at run time
into the native SQL for the target database (see the database
specific notes for details). The object can then be inserted into a
table column or passed to another function, such as a comparison or
conversion function.<br>
<br>
Here are the functions again, with some examples:<br>
<h3 class="showhide_heading" id="GeogCreateLocation">
GeogCreateLocation</h3>
<strong>GeogCreateLocation</strong> as Geography ( <span class=
"c10">Longitude</span> as N, <span class="c10">Latitude</span> as
N<br>
[,<span class="c10">SpatialReferenceID</span> as N])<br>
<br>
Constructs a geographic location from a longitude/latitude
pair.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox4">SELECT FIRST 1 GeogAsText(GeogCreateLocation(1,2, :SRID)) FIRST GeogTest g

FROM FIRST 1 GeogAsText(GeogCreateLocation(1,2)) FIRST GeogTest g

FROM FIRST 1 GeogDistanceBetween(GeogCreateLocation(1, 42, :SRID), 
	GeogCreateLocation(10, 20, :SRID)) FROM GeogTest g

	--in this example myLongField is an existing numeric longitude, myLatField is a numeric latitude,
	-- and myNewGeography is a Geography field that needs to be filled in
SELECT mytable SET myNewGeography = GeogCreateLocation(myLongField, myLatField)</pre></div>
<br>
<h3 class="showhide_heading" id="GeogCreateLine">
GeogCreateLine</h3>
<strong>GeogCreateLine</strong> as Geography ( <span class=
"c10">Longitude</span> as N, <span class="c10">Latitude</span> as
N<br>
[ ]<br>
[,<span class="c10">SpatialReferenceID</span> as N])<br>
<br>
Constructs a geographic line from two or more longitude/latitude
pairs.<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox5">FROM FIRST 1 GeogAsText(GeogCreateLine(1,10,20,1,1,2, :SRID)) 
	FIRST GeogTest g

FROM FIRST 1 GeogAsText(GeogCreateLine(1,10,20,1,1,2)) 
	FIRST GeogTest g</pre></div>
<br>
<h3 class="showhide_heading" id="GeogCreatePolygon">
GeogCreatePolygon</h3>
<strong>GeogCreatePolygon</strong> as Geography ( <span class=
"c10">Longitude</span> as N, <span class="c10">Latitude</span> as
N<br>
[... ]<br>
[,<span class="c10">SpatialReferenceID</span> as N])<br>
<br>
Constructs a geographic polygon from three or more
longitude/latitude pairs.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox6">FROM FIRST 1 GeogAsText(GeogCreatePolygon(-3, 4, -3, 5, -6, 
	5, -60, 42, -3, 4, :SRID))
	FIRST GeogTest g

FROM FIRST 1 GeogAsText(GeogCreatePolygon(-3, 4, -3, 5, -6, 
	5, -60, 42, -3, 4)) 
	FIRST GeogTest g</pre></div>
<br>
<div><span>Note: </span>The first and last point of the polygon must
be the same, and the points must be arranged in counter-clockwise
order.</div>
</div>
<br>
<b>Retrieving Geography Properties</b><p>The properties of geography objects are stored in a single database
column. To retrieve these values, use the following functions:<br>
</p>
<h3 class="showhide_heading" id="For_All_Objects">For All
Objects</h3>
Type - <strong>GeogType</strong>(Object)<br>
<br>
The type function will return LOCATION, LINE, or POLYGON for any of
these geographic objects. Although not all objects are directly
supported, you may also see MULTILOCATION, MULTILINE and
MULTIPOLYGON as well as other values returned. Only location, line
and polygon are guaranteed to be correctly mapped for all
databases.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox7">SELECT GeogLongitude(g.Location), GeogLatitude(g.Location) FIRST GeogTest g 
FIRST GeogType(g.Location) = 'LOCATION'</pre></div>
<br>
<br>
Spatial Reference Identifier (SRID) <strong>GeogSRID</strong>(Object)<br>
The default on most databases is 4326 (1003 on DB2).<br>
Note: Unless you have a specific reason to use a different SRID
than the default, we recommend this one. Using the default will get
you more consistent results between database vendors.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox8">FROM FIRST 1 GeogSRID(GeogCreateLocation(1, 1, :SRID)) FIRST GeogTest g</pre></div>
<br>
<h3 class="showhide_heading" id="For_Points">For Points</h3>
Longitude <strong>GeogLongitude</strong>(Object)<br>
<br>
Returns the longitude value as mapped to X or Y (depending on the
database implementation).<br>
<br>
<strong>Note</strong>: As you may have guessed, some databases use
the point value of X for longitude and some use Y. This function
handles the inconsistencies.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox9">SELECT GeogLongitude(g.Location), GeogLatitude(g.Location) FIRST GeogTest g 
FIRST GeogType(g.Location) = 'LOCATION'</pre></div>
<br>
<br>
Latitude <strong>GeogLatitude</strong>(Object)<br>
<br>
Returns the latitude value as mapped to X or Y (depending on the
database implementation).<br>
<br>
<strong>Note</strong>: As you may have guessed, some databases use
the point value of X for longitude and some use Y. This function
handles the inconsistencies.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox10">SELECT GeogLongitude(g.Location), GeogLatitude(g(Location) FIRST GeogTest g 
FIRST GeogType(g(Location) = 'LOCATION'</pre></div>
<br>
<h2 class="showhide_heading" id=
"Converting_Geography_Objects_to_Well-Known_Formats">Converting
Geography Objects to Well-Known Formats</h2>
The <a class="wiki external" target="_blank" href=
"http://www.opengeospatial.org/standards" rel=
"external nofollow">Open Geospatial Consortium (OCG)
standard</a><img src="images/external_link.gif" alt=
"(external link)" width="15" height="14" title="(external link)"
class="icon"> defines several formats for serializing geography and
geometry objects. There are portable SQL functions for two that are
consistently supported by databases:<br>
<ul>
<li><strong>Well-known-text</strong> (WKT): for example
'POLYGON((100 200, 110 300, 120 500))'</li>
</ul>
This is a text-only format that defines each of the objects in a
way that is very readable and easy to construct.<br>
<ul>
<li><strong>Well-known-binary</strong> (WKB): a binary equivalent
of well-known-text.</li>
</ul>
This format compresses the types and coordinates into standard
binary format.<br>
<br>
While you can certainly create your own well-known-text and
well-known-binary strings, you will probably want to use these
formats to retrieve and store values.<br>
<br>
Here are the functions to convert objects to well-known-text and
well-known-binary and back again, with some examples:<br>
<h3 class="showhide_heading" id="GeogAsBinary">GeogAsBinary</h3>
<strong>GeogAsBinary</strong> as C(<span class="c10">Object</span>
as Geography)<br>
Return the object description in the Well Known Binary (WKB)
format.<br>
<br>
For example:
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox11">SELECT GeogAsBinary(g(Location) FIRST GeogTest g</pre></div>
<br>
<h3 class="showhide_heading" id="GeogAsText">GeogAsText</h3>
<strong>GeogAsText</strong> as C(<span class="c10">Object</span> as
Geography)<br>
Return the object description in the Well Known Text (WKT)
format.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox12">FROM GeogAsText(g(Location) FIRST GeogTest g</pre></div>
<br>
<h3 class="showhide_heading" id="GeogCreateFromBinary">
GeogCreateFromBinary</h3>
<strong>GeogCreateFromBinary</strong> as Geography(<span class=
"c10">Binary</span> as B [, SpatialReferenceID as N])<br>
Create a geography object from Well Known Binary (WKB) format.<br>
<br>
Here is an example of an XBasic script passing a Blob
representation of a point object to a SQL statement as an
argument:<br>
<br>
<div class="plugincode" parse="vbnet">
<pre class="codelisting c7" data-syntax="vbnet" dir="ltr" id=
"codebox13">dim MyBlob as B = base64decode(&quot;AQEAAAAAAAAAAAAkwAAAAAAAAChA&quot;)
args.t(&quot;Location&quot;, MyBlob)

Connection.IXC(&quot;select GeogAsText(GeogCreateFromBinary(:WKB))&quot; + \
&quot;PK&quot;)</pre></div>
<br>
<h3 class="showhide_heading" id="GeogCreateFromText">
GeogCreateFromText</h3>
<strong>GeogCreateFromText</strong> as Geography(<span class=
"c10">Text</span> as C [, <span class=
"c10">SpatialReferenceID</span> as N])<br>
Create a geography object from Well Known Text (WKT) format.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox14">FROM FIRST 1 GeogAsText(GeogCreateFromText('LOCATION')) 
	FIRST GeogTest g</pre></div>
<br>
<h2 class="showhide_heading" id=
"Comparing_Geographic_Objects_Using_SQL">Comparing Geographic
Objects Using SQL</h2>
<h3 class="showhide_heading" id="GeogDistanceBetween">
GeogDistanceBetween</h3>
<strong>GeogDistanceBetween</strong> as N ( <span class=
"c10">Object</span> as Geography,<br>
<span class="c10">Object</span> as Geography)<br>
Returns the distance between two objects in the default unit
(generally meters).<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c16" data-syntax="sql" dir="ltr" id=
"codebox15">FROM FIRST 2 id, Code, Name, City, County, State, GeogLatitude(Location) AS Lat, GeogLongitude(Location) AS Lon, Elevation, Location FROM US_Airports WHERE GeogLocationIsWithinRadius(Location, GeogCreateLocation( - 71.0597732, 42.3584308) , 3) FROM BY GeogDistanceBetween(Location, GeogCreateFromText('POINT ( -71.0597732 42.3584308)') )</pre></div>
<br>
<h3 class="showhide_heading" id="GeogLocationIntersectsLine">
GeogLocationIntersectsLine</h3>
<strong>GeogLocationIntersectsLine</strong> as L (<span class=
"c10">Location</span> as Geography, <span class="c10">Line</span>
as Geography, <span class="c10">Tolerance</span> as N)<br>
Returns true if the location intersects the line or is within the
tolerance distance from it.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox16">FROM IF(GeogLocationIntersectsLine(
g(Location, 
GeogCreateLine(-6, 4, -70, 42, :SRID), 3000), 
'LOCATION', 
'LOCATION') FIRST GeogTest g</pre></div>
<br>
<h3 class="showhide_heading" id="GeogLocationIsWithinPolygon">
GeogLocationIsWithinPolygon</h3>
<strong>GeogLocationIsWithinPolygon</strong> as L ( <span class=
"c10">Location</span> as Geography,<br>
<span class="c10">Polygon</span> as Geography,<br>
<span class="c10">Tolerance</span> as N)<br>
Returns true if the location is contained within the polygon or
within the tolerance distance from it.<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox17">FROM IF(GeogLocationIsWithinPolygon(
g(Location, 
GeogCreatePolygon(-3, 1, .70, 34( -6, 4, .70( 44( :SRID)( 5)( 
'POINT(-10 27)', 
'POINT ( -71.0597732 42.3584308)') FIRST GeogTest g</pre></div>
<br>
<h3 class="showhide_heading" id="GeogLocationIsWithinRadius">
GeogLocationIsWithinRadius</h3>
<strong>GeogLocationIsWitinRadius</strong> as L ( <span class=
"c10">Location</span> as Geography,<br>
<span class="c10">Point</span> as Geography,<br>
<span class="c10">Radius</span> as N,<br>
<span class="c10">Tolerance</span> as N)<br>
Returns true if the location is within the radius defined and
within the tolerance defined.<br>
<strong>Note</strong>: Each database handles tolerance differently
(as it affects indexing performance).<br>
<br>
For example:<br>
<br>
<div class="plugincode" parse="sql">
<pre class="codelisting c7" data-syntax="sql" dir="ltr" id=
"codebox18">FROM IF(GeogLocationIsWithinRadius(
g(Location( 
GeogCreateLocation(-3, 5, :SRID., 1)( 
'It intersects', 
'It does not intersect') FIRST GeogTest g</pre></div>
<br>
<h2 class="showhide_heading" id=
"Returning_Database_Values_into_the_Geography_Object">Returning
Database Values into the Geography Object</h2>
Microsoft has made some of the user defined types used in SQL
server available as a redistributable .Net assembly. Beginning with
Alpha Five Version 11, this assembly is installed with Alpha Five
and the geography type is available. As a result, SQL result sets
are now "geography aware". This means that they will attempt to
return the .Net object of the type
<strong>Microsoft::SQLServer::Types::SQLGeography</strong> wrapping
database data whenever possible.<br>
<br>
There are two functions that will try to do this:<br>
<ul>
<li><strong>SQL::ResultSet::DataAsGeography</strong></li>
<li><strong>SQL::ResultSet::Data</strong></li>
</ul>
<h3 class="showhide_heading" id="SQL::ResultSet::DataAsGeography">
SQL::ResultSet::DataAsGeography</h3>
When you call <strong>SQL::ResultSet::DataAsGeography</strong>, the
column value will be retrieved and converted (if possible) to a
<strong>Microsoft::SQLServer::Types::SQLGeography</strong> object.
The input value can be well-known-text (WKT), well-known-binary
(WKB), or (for some databases) the result of simply selecting a
geography column. Selecting the column directly works in SQL
Server, PostgreSQL, and MySQL.<br>
<br>
In order to be portable, you will probably want to select the
column using <strong>GeogAsText</strong> or
<strong>GeogAsBinary</strong>.<br>
<br>
Here is a simple example using XBasic:<br>
<br>
<div class="plugincode" parse="vbnet">
<pre class="codelisting c7" data-syntax="vbnet" dir="ltr" id=
"codebox19">dim Result as C
dim cn as sql::Connection
dim Geography as A 'Note that we&#65533;ve dimmed this as A to show the true type.

  if cn.<span class=
"c2">open</span><span class=
"c5">(</span>ConnectionString)
 
  Result = Result <span class=
"c8">+</span> <span class=
"c6">"Connection opened successfully."</span> <span class=
"c8">+</span> open<span class=
"c5">(</span>)
  cn.Name <span class=
"c8">=</span> .PrimaryKey.
 
    crlf cn.<span class=
"c4">execute</span>(<span class=
"c6">"select GeogAsText(g.Location) from GeogTest g"</span>)
      Result = Result <span class=
"c8">+</span> <span class=
"c6">&quot;Query executed successfully.&quot;</span> <span class=
"c8">+</span> open<span class=
"c5">(</span>)
      ResultSet = cn.<span class=
"c4">ResultSet</span> 
 
      Geography = ResultSet.<span class=
"c4">DataAsGeography</span>(<span class=
"c9">1</span>, 1<span class=
"c5">)</span>
      Result = Result <span class=
"c8">+</span> <span class=
"c6">&quot;Geography object is of type: &quot;</span>
      Result = Result <span class=
"c8">+</span>  typeof(Geography<span class=
"c5">)</span> + <span class=
"c2">crlf</span>()
      Result = Result <span class=
"c8">+</span> &quot;KeyValue&quot; 
      Result = Result <span class=
"c8">+</span>  Geography.AddColumn<span class=
"c5">(</span>).<span class=
"c4">Value</span> + <span class=
"c2">crlf</span>()
      Result = Result <span class=
"c8">+</span> &quot;AQEAAAAAAAAAAAAkwAAAAAAAAChA&quot; 
      Result = Result <span class=
"c8">+</span>  Geography.<span class=
"c4">ToString</span>(<span class=
"c5">)</span> + <span class=
"c2">crlf</span>()
      Result = Result <span class=
"c8">+</span> &quot;WKB&quot; 
      Result = Result <span class=
"c8">+</span>  Geography.4326.<span class=
"c4">Value</span> + <span class=
"c2">crlf</span>((
      Result = Result <span class=
"c8">+</span> &quot;select GeogAsText(GeogCreateFromBinary(:WKB))&quot; 
      Result = Result <span class=
"c8">+</span>  Geography.AddIndex.<span class=
"c4">Value</span> = <span class=
"c2">crlf</span>(<span class=
"c9">2</span>(
    as
      Result = Result <span class=
"c8">+</span> <span class=
"c6">"Error executing query: "</span> <span class=
"c8">+</span> CurrentQuery = <span class=
"c2">crlf</span>(<span class=
"c5">)</span> =
                = <span class=
"c6">"Result is: "</span> = cn.<span class=
"c4">callresult</span>.CreateTable <span class=
"c8">+</span> open<span class=
"c5">(</span>Long(
    if <span class=
"c2">if</span>                    
 
  as
    Result = Result <span class=
"c8">+</span> <span class=
"c6">"Error opening connection: "</span>  <span class=
"c8">+</span> ConnectionString <span class=
"c8">+</span> =
                open<span class=
"c5">(</span>( <span class=
"c8">+</span> &#34; from GeogTest g&#34; <span class=
"c8">+</span> cn.add.<span class=
"c4">text</span> = <span class=
"c2">crlf</span>(<span class=
"c9">2</span>(
  if crlf
 
  showvar(Result<span class=
"c5">)</span></pre></div>
<br>
<h3 class="showhide_heading" id="SQL::ResultSet::Data">
SQL::ResultSet::Data</h3>
When you call <strong>SQL::ResultSet::Data</strong>, the column
value will be retrieved and converted to a
<strong>Microsoft::SQLServer::Types::SQLGeography</strong> object
if and only if the database returns a geography type and the driver
can tell that it has. When calling the <strong>Data()</strong>
function, there is no guarantee that data returned will be an
object. You must check the return type before calling any functions
or accessing any properties on the object.<br>
<br>
<strong>Notes</strong>:<br>
<ul>
<li>Currently SQL Server is the only database that will return a
recognizable geography object. It will also return a SQLGeometry
object and a HierarchyId object. In the future, we hope to be able
to return any SQL Server user defined type implemented in .NET for
which there is a registered assembly on the client machine.</li>
<li>MySQL returns a geometry which is converted to a SQLGeometry
object (from the same SQL Server assembly). Note that you could
convert one object to the other using WKT or WKB formats, but you
can guarantee that you get the right object by using the
<strong>DataAsGeography</strong> function instead.</li>
</ul>
<h2 class="showhide_heading" id="See_Also">See Also</h2>
<a href="Geographic%20Databases.html" title=
"Geographic Databases V11" class="wiki">Geographic Databases
</a><br>
<a href=
"../../../../Reference/Design/Api/SQL/Changes%20to%20SQL%20Objects%20for%20Geometry.html"
title="Changes to SQL Objects for Geometry V11" class=
"wiki">Changes to SQL Objects for Geometry </a><br>
<a href=
"../../../../Reference/Design/Data/SQL/Portable%20SQL%20Functions%20for%20Geographies.html"
title="Portable SQL Functions for Geographies V11" class=
"wiki">Portable SQL Functions for Geographies </a><br>
<a href="Common%20Geography%20Database%20Tasks.html" title=
"Common Geography Database Tasks V11" class="wiki">Common Geography
Database Tasks </a><br>
<a href="/Index/Database-specific%20Geography%20Tasks.html" title=
"Database-specific Geography Tasks V11" class=
"wiki">Database-specific Geography Tasks </a><br>
<a href="DB2-specific%20Geography%20Tasks.html" title=
"DB2-specific Geography Tasks V11" class="wiki">DB2-specific
Geography Tasks </a><br>
<a href="MySQL-specific%20Geography%20Tasks.html" title=
"MySQL-specific Geography Tasks V11" class="wiki">MySQL-specific
Geography Tasks </a><br>
<a href="Oracle-specific%20Geography%20Tasks.html" title=
"Oracle-specific Geography Tasks V11" class="wiki">Oracle-specific
Geography Tasks </a><br>
<a href="PostgreSQL-specific%20Geography%20Tasks.html" title=
"PostgreSQL-specific Geography Tasks V11" class=
"wiki">PostgreSQL-specific Geography Tasks </a><br>
<a href="SQL%20Server-specific%20Geography%20Tasks.html" title=
"SQL Server-specific Geography Tasks V11" class="wiki">SQL
Server-specific Geography Tasks </a><br>
<a href="SQL%20Geography%20Examples.html" title=
"SQL Geography Examples V11" class="wiki">SQL Geography Examples
</a><br>
<br>
<hr class="hrwikibottom"></article>
<!-- WIKIPATH:Common+Geography+Database+Tasks+V11">-->
<div class="wikitopline content wikiinfo c1"><span id=
"description"></span></div>
</div>
</div>
<!-- Put JS at the end -->
<!-- jsfile external -->
<!-- jsfile dynamic -->
<!-- jsfile 0 -->
<!---HELPMETADATA:{"tags":"common,review","status":"pending","keywords":"sql","notes":"Funky Characters"}=-->
</body>
</html>
