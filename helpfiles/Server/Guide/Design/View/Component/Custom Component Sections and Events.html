	<!DOCTYPE html>
	<html>
	<head>
	<meta http-equiv=\"Content-Type\" content=\"text/html; charset=ISO-8859-1\" />
	<link rel="stylesheet" type="text/css" href="theme.css" />
	</head>
	<body>
	<div id="tiki-clean">
			<div id="tiki-mid">
	
 



 

	 




<article id="top" class="wikitext nopagetitle">
			
		
		
		
		
			 

	
			<h1 class="showhide_heading" id="Custom_Component_Sections_and_Events">Custom Component Sections and Events</h1>
Let's go over the Sections and Events of the Custom Component Builder. We'll skip the Overview section, as we looked at it sufficiently in <a href="Creating a Custom Component.html" title="Creating a Custom Component V11" class="wiki">the previous article in this series</a>. When we come to a section used by our Demo component, we'll go over the relevant code.<br />
<h2 class="showhide_heading" id="Properties">Properties</h2>
The properties grid, which allows either the developer or the user to easily adjust the appearance and operation of the component, has five groups: Component Properties, CSS, Arguments, Javascript, and Other.<br />
<h3 class="showhide_heading" id="Component_Properties">Component Properties</h3>
The four generic component properties are the Style name, Style overrides, Font size, and Master Template. The Style name refers to a standard Alpha Five web Grid style, such as GlassBlue. When a custom component is linked from or called from a Grid, the component will typically be inherited from the Grid, so specifying the style here is mostly for standalone usage.<br />
<br />
Style overrides are rarely needed in Custom Components, unless they have Tabs, Accordions, pop-up Windows, or Lists of their own. The Font size property can override the size of text elements, either all text elements or only those in grid style classes.<br />
<br />
The Master Template allows you to wrap the component in HTML of your choosing. This can be useful for creating borders or adding text and images that belong to the component without being inside the working body of the component.<br />
<h3 class="showhide_heading" id="CSS">CSS</h3>
You can define local CSS definitions for your component, additional Grid styles in addition to the primary style, and linked CSS files needed by your component. You might need linked CSS files if you are building a custom component around a third-party widget which uses its own CSS.<br />
<h3 class="showhide_heading" id="Arguments">Arguments</h3>
Arguments can be set at run-time, which is what you want for a component linked from a Grid. They can also be bound to a page, session, or cookie variable. Arguments can only bind to a constant or a single variable or field; you can not create an expression or combine fields in the argument binding dialog.<br />
<br />
How <em>can </em>you create an expression or combine fields? It depends on the kind of database you are using.<br />
<br />
In a DBF database, you can define a computed field in the database that gets its value from an expression using one or more other fields in the database.<br />
<br />
If you need an argument to be bound to a value that is a formatted combination of fields from a SQL database, you can create a SQL expression in your parent Grid's query string, such as<br />
<br />
<div class="plugincode" parse="sql"><pre class="codelisting" data-syntax="sql" dir="ltr" style="overflow:auto;" id="codebox" >SELECT Firstname+&#39; &#39;+Lastname AS Fullname FROM customers</pre></div><br />
You don't need to display this SQL expression field in your grid for it to be available for argument binding &mdash; it can be in a hidden column.<br />
<h3 class="showhide_heading" id="Javascript">Javascript</h3>
Javascript linked files are necessary when you are using third-party Javascript libraries other than the ones supplied by default in Alpha Five. You can optionally specify the name of an initialization function to be called for each library after a vertical bar character, for example<br />
<br />
<div class="plugincode" ><pre class="codelisting" data-syntax="" dir="ltr" style="overflow:auto;" id="codebox1" >js/fancybox/jquery.fancybox-x.y.z.js|bindFancyBox</pre></div><br />
Remember that Javascript is case-sensitive. <strong>bindfancybox</strong> will <em>not </em>match <strong>bindFancyBox</strong>.<br />
<h3 class="showhide_heading" id="Other">Other</h3>
<strong>Language definitions</strong> let you define language-dependent substitutions for fields within &lt;a5:r&gt; ... &lt;/a5:r&gt; tags. Our Demo component has two such placeholder tags, as we can see by clicking the <strong>Refresh List of Placeholders</strong> button in the <strong>Language Definitions</strong> dialog. If we set<br />
<br />
<div class="plugincode" ><pre class="codelisting" data-syntax="" dir="ltr" style="overflow:auto;" id="codebox2" >txt1=some substituted value for txt1
txt2=a different substituted value for txt2</pre></div><br />
and save the component, the next time we run it we'll see "some substituted value for txt1" at the bottom of the grid when it first renders, and "a different substituted value for txt2" at the top of the grid after pressing <strong>Next</strong>.<br />
<br />
If we define multiple languages for substitution, we can set the Active Language for testing purposes. The active language can be overriden at runtime using the <strong>session.__protected__activeLanguage</strong> variable.<br />
<br />
Sometimes a component may need to insert markup into the HEAD section of its page. This may be JavaScript library references, CSS, or metatags. This markup can be specified in the <strong>Head section tags</strong> area.<br />
<br />
Some JavaScript libraries and other third-party widgets assume that they are single or isolated instances. If you have trouble running multiple copies of your control on a page, check <strong>Component must run in IFrame</strong> and each copy of your component will have its own environment. When you do this you give up the ability to run in Working Preview mode and on the desktop, but your component will still work in Live Preview and published in a Web application.<br />
<br />
The Other properties dialog allows you to set the values of properties for which a builder (i.e. property grid) is not available, primarily for testing purposes. Since, unlike a User-defined Component, a Custom Component has no builders of its own, this can be any property you add to the Xbasic code of the component. Such properties can be set by other components that are aware of them, or by your Xbasic code, for example in one of your server events or in a callback.<br />
<br />
<em>Defining </em>properties looks something like this:<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox3" >dim wp.CenterLat as N = default 0
dim wp.CenterLng as N = default 0</pre></div><br />
In the Other properties dialog, you could override these two arguments (for testing purposes) with:<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox4" >tmpl.CenterLat = 42.478606
tmpl.CenterLng = -71.201289</pre></div><br />
<h2 class="showhide_heading" id="Javascript_Functions">Javascript Functions</h2>
The Javascript Functions dialog is a Javascript editor. You can define Javascript functions here that are called from your HTML events or from your inline Javascript code.<br />
<h2 class="showhide_heading" id="Xbasic_Functions">Xbasic Functions</h2>
The Xbasic Functions dialog is an Xbasic editor. You can define Xbasic functions here that are called from your inline Xbasic code.<br />
<ul><li><em><strong>Note</strong>: You may also place Xbasic functions in your project database as long as they are compiled into an AEX file for publication to the web.</em>
</li></ul>In our Demo component, we have two functions in this area. <strong>renderTable</strong> does the grunt work of creating the HTML table for a lightweight grid:<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox5" >function renderTable as c ( e as p)
dim recordsPerPage as n
recordsPerPage = 5 
dim logicalRecNo as n    
dim filter as c 
filter = &#34;bill_state_region = :componentArg_whatstate&#34;
&#39;filter = &#34;.t.&#34;
dim args as sql::arguments
args = e.arguments
filter = replace_arguments_in_string(filter,args)
dim t as p
t = table.open(&#34;customer&#34;) 
dim itbl as p
itbl = t.query_create(&#34;&#34;,filter)
dim totalRecords as n 
totalRecords = itbl.records_get()
dim totalPages as n 
totalPages = round_up((totalRecords/recordsPerPage),0)
&nbsp;
if e._pageNumber = -1 then 
  e._pageNumber = totalPages 
  e._state.pageNumber = totalPages
end if 
&#39;make sure user can&#39;t navigate past last page
e._pageNumber = min(totalPages,e._pageNumber)
&nbsp;
if e._pageNumber = 1 then 
  logicalRecNo = 1 
else
  logicalRecNo =  ((e._pageNumber - 1) * recordsPerPage) + 1
end if 
&nbsp;
t.LogicalRecord_Set(logicalRecNo)
dim html as c   
ph = a5_Generate_HTML_Table(t,e.tmpl.style_name,recordsPerPage)
e.html = ph.htmlTable
t.close()
end function</pre></div><br />
<br />
This code replaces the <strong>componentArg_whatstate</strong> argument in the filter, opens the <strong>customer</strong> table, applies a query using the filter, figures out where we are in the table, sets the page and logical record state, and then calls the Xbasic library function <strong>a5_Generate_HTML_Table</strong> to generate the actual HTML table markup.<br />
<br />
The other function defined here, <strong>Navigate</strong>, is used as a call-back function by the four navigation buttons:<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="white-space:pre-wrap; white-space:-moz-pre-wrap !important; white-space:-pre-wrap; white-space:-o-pre-wrap; word-wrap:break-word;" id="codebox6" >Function Navigate as c (e as p)
&nbsp;
  dim direction as c 
  direction = Request.Variables._direction
  if direction = &#34;Next&#34; then 
    e._pageNumber = val(e._state.pageNumber) + 1
  else if direction = &#34;First&#34; then 
    e._pageNumber = 1 
  else if direction = &#34;Prev&#34; then 
    e._pageNumber = val(e._state.pageNumber) - 1
    if e._pageNumber &amp;lt; 1 then 
      e._pageNumber = 1 
    end if
  else if direction = &#34;Last&#34; then 
    e._pageNumber = -1 
  end if 
&nbsp;
  e._state.pageNumber = e._pageNumber
  renderTable(e)
  dim div as c 
  div = &#34;tbl&#34;
  dim jscmd as c   
  dim html as c 
  html = js_escape(e.html)
  Navigate = &#34;$(&#39;&#34; + div + &#34;&#39;).innerHTML = &#39;this is a callback &amp;lt;a5:r&amp;gt;txt2&amp;lt;/a5:r&amp;gt; - page will be set to - &#34;+html+&#34; &#39;;&#34; 
end function</pre></div><br />
This code changes the page number state, calls into <strong>renderTable</strong> to recalculate the HTML for the page, and then manipulates the contents of the DIV "tbl" to print a message.<br />
<h2 class="showhide_heading" id="Server-side_Events">Server-side Events</h2>
A Custom Component supports three server-side events:<br />
<ul><li>onInitialRender
</li><li>onComponentInitialize
</li><li>onComponentExecute
</li></ul>The events fire in this order:<br />
<ul><li>when component is run initially: onComponentInitialize, onComponentExecute, and finally onInitialRender
</li><li>When an ajax callback is made: onComponentExecute
</li></ul>What this means is that for components where nothing needs to be done in the <strong>onComponentExecute </strong>event (such as generic updates during callbacks no matter what callback function is used), there is also no need for the <strong>onComponentInitialize </strong>event. Our example only uses the <strong>onInitialRender </strong>event.<br />
<br />
If you did have code that needed to run in every callback as well as at initialization, you might want to split up the code that needs to run before the <strong>onComponentExecute </strong>call from  the code that needs to run after it.<br />
<br />
Our Demo component runs the following code in the <strong>onInitialRender </strong>event.<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox7" >function onInitialRender as p (e as p)
&nbsp;
&#39;debug(1)
e._pageNumber = 1    
renderTable(e)
e._state.pageNumber = &#34;1&#34;
&nbsp;
&#39;wrap table in a div with buttons.
e.html = &#34;&amp;lt;div id=\&#34;tbl\&#34;&amp;gt;&#34; + e.html + &#34;&amp;lt;/div&amp;gt;&#34;
e.html = e.html + &amp;lt;&amp;lt;%html%
&amp;lt;br&amp;gt;
&amp;lt;a5:r&amp;gt;txt1&amp;lt;/a5:r&amp;gt; -- this should get replaced &amp;lt;/br&amp;gt;
&amp;lt;br&amp;gt;
&amp;lt;button class=&#34;{component.style}Button&#34; 
onclick=&#34;Component.Object}.ajaxCallback(&#39;&#39;,&#39;&#39;,&#39;Navigate&#39;,&#39;&#39;,&#39;_direction=First&#39;);&#34;&amp;gt;
First&amp;lt;/button&amp;gt;  
&amp;lt;button class=&#34;{component.style}Button&#34; 
onclick=&#34;{component.style}Button&#34;&amp;gt;
Previous&amp;lt;/button&amp;gt;  
&amp;lt;button class=&#34;{component.style}Button&#34; 
onclick=&#34;Component.Object}.ajaxCallback(&#39;&#39;,&#39;&#39;,&#39;Navigate&#39;,&#39;&#39;,&#39;_direction=Prev&#39;);&#34;&amp;gt;
Next&amp;lt;/button&amp;gt;  
&amp;lt;button class=&#34;{component.style}Button&#34; 
onclick=&#34;{component.style}Button&#34;&amp;gt;
Last&amp;lt;/button&amp;gt;  
%html%
&nbsp;
&nbsp;
end function</pre></div><br />
This function sets the page number to 1, calls renderTable, sets the saved page state to 1, and adds a DIV tag and some button definitions with onclick calls.<br />
<h2 class="showhide_heading" id="Client-side_Events">Client-side Events</h2>
There are four client-side events in a Custom Component:<br />
<ul><li>canAjaxCallback
</li><li>afterAjaxCallbackComplete
</li><li>onInitializeComplete
</li><li>onRenderComplete
</li></ul><strong>canAjaxCallback </strong>happens before an Ajax callback is executed, and can abort the callback by returning <strong>false</strong>. <strong>afterAjaxCallbackComplete </strong>happens after an Ajax callback returns, and is able to process the callback result. <strong>onInitializeComplete</strong> happens after all HTML and JavaScript has been emitted by the <strong>onInitialRender</strong> server-side event. <strong>onRenderComplete</strong> happens after all JavaScript defined by the page definition has run on the client.<br />
<br />
If you use a third-party JavaScript library that needs to be initialized, you can put the initialization call, which would normally go in a <strong>body.onload()</strong> or <strong>window.onload</strong> event in a typical HTML page, in the Client-side <strong>onInitializeComplete </strong>event of the custom component. If you want to automate initialization actions on the Component, you can run the appropriate calls in the <strong>onRenderComplete</strong> and expect that, under normal conditions, any exposed Component client-side method or property will be available for your use.<br />
<h2 class="showhide_heading" id="Tip:_Placeholder_replacement">Tip: Placeholder replacement</h2>
In the <strong>renderTable()</strong> code above, we replaced a SQL argument in <strong>:argumentName</strong> form using <strong>replace_arguments_in_string</strong>. You may also find it useful to replace <strong>{argumentName}</strong> placeholders. The following code added to the <strong>onInitialRender</strong> event will do the trick:<br />
<br />
<div class="plugincode" parse="vbnet"><pre class="codelisting" data-syntax="vbnet" dir="ltr" style="overflow:auto;" id="codebox8" >&#39;Replace parameters with their current argument values
e.html = replace_placeholders_with_argument_values(e.html,e.arguments)
e.javascript = replace_placeholders_with_argument_values(e.javascript,e.arguments)</pre></div><br />
<h2 class="showhide_heading" id="Call_to_action">Call to action</h2>
Now that you have a simple working component, you can try building your own. You will find using <a href="/Api/Functions/Xbasic/Script Functions/DEBUG Function.xml" title="DEBUG Function" class="wiki">debug(1</a>) statements in your Xbasic helpful (in Working Preview mode), and <span style="color:blue; background:">debugger;</span> statements in your JavaScript.<br />
<br />
When you design your own custom component, think carefully about what arguments you wish to expose. A good set of arguments will make the component more useful and versatile. Creating a good default for each arguments will make it easier for your users.<br />
<br />
The <a href="../Grid/Sharing and Using a Custom Component.html" title="Sharing and Using a Custom Component V11" class="wiki">next article in this series</a> explains how to distribute your Custom Component to users.<br />
<h2 class="showhide_heading" id="See_also">See also</h2>
<a href="Custom Components.html" title="Custom Components V11" class="wiki">Custom Components V11</a><br />
<a href="../../Platform/Javascript/Using the Custom Component JavaScript Class.html" title="Using the Custom Component JavaScript Class V11" class="wiki">Using the Custom Component JavaScript Class V11</a><br />
<a href="Creating a Custom Component.html" title="Creating a Custom Component V11" class="wiki">Creating a Custom Component V11</a><br />
<a href="Custom Component Sections and Events.html" title="Custom Component Sections and Events V11" class="wiki">Custom Component Sections and Events V11</a><br />
<a href="../Grid/Sharing and Using a Custom Component.html" title="Sharing and Using a Custom Component V11" class="wiki">Sharing and Using a Custom Component V11</a><br />
<a href="../CSS/JQuery Support.html" title="JQuery Support V11" class="wiki">JQuery Support V11</a><br />
<br />

	
	
	<hr class="hrwikibottom" /> 

	
	</article> 




	<!-- WIKIPATH:Custom+Component+Sections+and+Events+V11">-->


	 

			</div>
		</div>


	
	
<!-- Put JS at the end -->
	
<!-- jsfile external -->


<!-- jsfile dynamic -->
<!-- jsfile 0 -->
<!---HELPMETADATA:{"tags":"web","status":"pending","keywords":"server,design,guide,component"}--->
</body></html>