<page>
<topic>Javascript in UX Components</topic>
<groups>
    <group>
    <title>Introduction</title>
    <sections>
        <section>
            <description>UX components let you design robust interfaces to convey information to a user. Javascript is used to create the interactive piece of the UX component. Javascript allows you to create a rich user experience. Retrieving data from a server, showing a message, resetting data in a form, or enabling a button are behaviors created with javascript.
            </description></section><section><description>
            Javascript is added through events or properties to create effects and functionality in a UX component. Action Javascript offers a wide assortment of functionality you can drop into your component or use as a starting point in your scripts. UX components also have built-in methods you can use to access information about and manipulate the controls in your component. Built-in debugging tools and compatibility with third-party debuggers also help to track down problems before you publish them to the web.</description>
        </section>
    </sections>
    </group>
    <group>
    <title>Client-Side Events</title>
    <sections>
        <section><description>Creating or modifying behaviors on a web page with javascript can be done with events. Events are triggered from actions initiated by the user or change of state in the UX. Some events are top-level events that belong to the UX component, such as the onRenderComplete or onInitializeBegin events. Other events apply to controls that can be placed in the UX component, such as lists, repeating sections, or data controls (text boxes, radio buttons, dropdowns, etc.) Many events are part of a larger chain of events. For example, when an ajax callback is made, Client-Side Events are called before the callback is sent to the server (canAjaxCallback) and when the callback returns from the server (afterAjaxCallbackComplete).
            </description></section><section><description>
        UX component Client-side Events are hooks that can be used to customize behavior, inject content, cache state, or add your own customizations to the component. Client-Side Events are listed in the Events section under "Client-side" in the UX component. Here you will find events for repeating sections and events for the UX component caused by state changes in the UX component's environment. Some examples of a state change in a UX component include the UX component is rendered or initialized, a login or logout event occurs in the security framework, a callback is sent or returned from the server, or data in controls on the UX component have been populated, reset, or validated.
            </description>
        <figure><link>images/image09.png</link></figure>
        </section>
        <section>
            <description>
        Controls and objects placed on a UX component also have events. Most events are listed under "Javascript (Mouse, Touch, Pointer)" and "Javascript" in the control's Properties. Some controls have additional events that are specific to the type of control. For example, a textbox with a date picker will have optional events for the date picker.
            </description></section><section><description>
        The core events, "Javascript (Mouse, Touch, Pointer)" and "Javascript", are events created by device interaction: touch screens, mice, and keyboards. Older versions of Alpha Anywhere only had "Javascript" events. With more recent releases, "Javascript (Mouse, Touch, Pointer)" events were added. The only significant difference between these two sets of event are how the javascript is registered with the event handlers. "Javascript" events are registered using the HTML attribute for the control. "Javascript (Mouse, Touch, Pointer)" events are registered using $e.add(), an event register function from Alpha Anywhere's core javascript library.
            </description>
        <figure><link>images/image06.png"</link></figure>
        </section>
        <section>
        <description>
        You may be wondering why there are two click (click, onClick) and double-click (dblClick, onDblClick) events. The click and dblClick events are optimized to support both mobile and desktop devices. On mobile devices, the browser adds a 300ms delay to the onClick event. This delay was added so the browser could detect touch events, such as swiping. The click event does not have this delay. Alpha Anywhere automatically maps the click event to the appropriate event handler based on the user's device. On mobile devices, the click event resolves to a touch event and eliminates the 300ms delay. On a desktop computer, click resolves to a mouse click event, which has no delay.
            </description></section><section><description>
        The events listed may not be available for a control. Event availability depends on both the type of HTML element rendered for the control as well as the web application's environment (mobile phone versus a laptop computer.) A touch screen will issue both click and tap events whereas a mouse will only trigger click events. Additionally, some events are not available for all controls --- a container doesn't have a value, so the container won't have an onChange event. Therefore, it is important to consider both the context of the environment the UX component will run in as well as the type of control when working with events.
        </description>
        </section>
    </sections>
    </group>
    <group>
        <title>Action Javascript</title>
        <sections>
            <section><description>Action Javascript is a way to add javascript to a component in Alpha Anywhere with minimal to no code required on your part. Action Javascript uses properties to gather the information need to add the desired functionality. A wide variety of actions are available that accomplish numerous tasks, including opening components, uploading or downloading images and files, generating PDF reports, and more.
            </description>    
            <figure><link>images/image41.png</link></figure>
            </section><section><description>
            It's important to understand that every Action Javascript requires javascript to trigger the action. Even if the bulk of the action happens on the server in an xbasic routine, javascript is still required to contact the server to start the process. While code may not be displayed on the screen, you are creating javascript to implement the features and functionality added with Action Javascript.
</description></section><section><description>
            When you edit an event for a control, the event's editor opens in Action Javascript editing mode. The two other modes, Text mode and Server-side Xbasic, are modes for writing javascript and xbasic code, respectively. A new Action Javascript can be created using the "Add new Action" button. You can add as many Action Javascripts as you want.
            </description>
            <figure><link>images/image32.png</link></figure>
            </section><section><description>
            Action Javascript is configured using properties. These properties allow you to define the behavior of the Action Javascript. For example, suppose you want to show a container in your UX component when the user clicks a button. In the click event for your button, you can add an Action Javascript, "Toggle display of a container or DIV with animation," to create this effect. In the specification for the Toggle display action, you'll find options to configure everything from the show/hide action, the element or container to modify, and the animations to use for showing and hiding the object.
                </description>
            <figure><link>images/image15.png</link></figure>
            </section><section><description>
            If you have multiple containers or elements you want to hide, you can add multiple toggle display actions to handle each element or container affected.
</description></section><section><description>
            Some Action Javascripts cannot be called multiple times in one event due to their underlying implementation. For example, if you wanted to show two or more messages in sequence when a button is clicked, you would probably add two "Message box" Action Javascripts to the button's click event. The expected behavior would be the first message would appear followed by the second message after the first message is dismissed. If you use a simple message box, this is the behavior you will see.
            </description>
            <figure><link>images/image01.png</link></figure>
            </section><section><description>
            However, if the "Message box" actions both use advanced message boxes, the behavior is different. Using advanced messages, the first message is shown and immediately replaced by the second message. This is because the advanced message box doesn't block javascript execution nor does the underlying implementation support displaying multiple concurrent messages.
            </description>
            <figure><link>images/image10.png</link></figure>
            </section><section><description>
            Similar to advanced message boxes, callbacks to a web server also do not block javascript execution. If you wanted to show another UX component in a window, your web application needs to make a callback to the server to retrieve the HTML, CSS, and javascript defining the UX component. If you wanted to show a message after the UX component is loaded, you would run into a new issue where the message box may be displayed before the UX component even starts to load. Fortunately, in this situation the Action Javascript can be run in sequence by checking "Run actions synchronously", which can be found at the bottom of the Edit Event window.
            </description>    
            <figure><link>images/image13.png</link></figure>
            </section><section><description>
            Run actions synchronously only applies to ajax callbacks made to the Alpha Anywhere server. It doesn't apply to ajax callbacks made to third-party servers.
            </description>
            </section>
        </sections>
    </group>
    <group>
    <title>Javascript Actions</title>
    <sections>
        <section>
            <description>Action Javascript can be added to control events through their event editor. However, Client-Side Events for the UX component don't have an Action Javascript editor mode. They have to be defined with javascript. Javascript Actions let you define Action Javascript events that can be called anywhere in a UX component using the {dialog.object}.runAction() method.
</description></section><section><description>
            In the UX component properties, there is a property called "Javascript Actions". Click the button to open the Javascript Actions window. Creating a Javascript Action is a two-fold process. First, you must create a Javascript Action. The action name must be unique. The name is the value you will pass to {dialog.object}.runAction() to call your Javascript Action.
            </description>
            <figure><link>images/image19.png</link></figure>
        </section><section><description>    
            After the Javascript Action is created, you can then select the Javascript Action and edit it by clicking the Edit Action button. Editing the action opens the Unbound Event Editor. This editor is the same editor you find when editing the click or onKeyPress event for a control. Like control events, you can add any number of Action Javascripts to your Javascript Action.
                </description>
            <figure><link>images/image21.png</link></figure>
            </section><section><description>
            A small red or green dot appears next to the action name in the Javascript Actions window. This visual feedback indicates whether or not a Javascript Action has been defined. If nothing has been defined for the action, it will be red. If an action calls any Action Javascript or has javascript or server-side xbasic, the dot will be green.
        </description>
            <figure><link>images/image28.png</link></figure>
            </section><section><description>
            To call a Javascript Action, use {dialog.object}.runAction(). You can type the function call out yourself, or click on "Click to see the Javascript code to invoke this action" link in the Javascript Actions window:
        </description>
                <example><![CDATA[{dialog.object}.runAction('myAction1');]]></example>
        </section><section><description>
            {dialog.object}.runAction() takes a second, optional parameter. If an Action Javascript requires information about the object that runs the action, you need to pass in that object to the {dialog.object}.runAction() method. The "Open a Help Window" is an example of an Action Javascript that may require an object. The Window Position's can be relative to the control that invoked the action. Since Javascript Actions are not bound to any control, the object referenced by your Javascript Action doesn't have to be the one the user clicked.
        </description>
            <example><![CDATA[var ele = {dialog.object}.getPointer('MY_CONTROL');
{dialog.object}.runAction('myAction2',ele);]]></example>
                </section><section><description>
        Javascript Actions can be called anywhere, including Client-Side Events, Javascript Functions, or control events. They can also be exported and imported across UX components using the "Copy/paste actions" link.</description>
                </section>
            </sections>
    </group>
        <group>
        <title>Aliases &amp; Placeholders</title>
        <sections>
            <section><description>Every component in Alpha Anywhere, whether it is a Grid, UX, or Custom component, has an alias. The alias is a unique name given to the component at run-time, so it can be referenced in javascript. In Working and Live Preview, the alias defaults to a known value ("DLG1" for UX components.) When you insert a UX component in an .a5w page or as an embedded object on another UX component, however, Alpha Anywhere will prompt you for an alias for the UX component.
                </description></section><section><description>
            Aliases are used to create unique IDs for the UX component and its controls. If you inspect the code for your components in a web browser, you will see the UX component's alias is used as part of the ID for all of the elements on the page. If you want to interact with an element on the page in your UX component, you need the alias. Since the alias in Working Preview isn't the same as the alias used when your UX component is published, you need a way to reference the alias in your javascript. To do this, use placeholders.
</description></section><section><description>    
            Placeholders act as substitutes for various properties and objects in a component. The UX component alias, for example, is used to determine the IDs of controls in the UX component as well as the name of the UX component javascript object, which contains javascript methods for interacting with the UX component. There are placeholders for other information about the UX component, such as the CSS style used, embedded components, or the full ID for a control. You can find a list of available placeholders in the Insert Placeholder window.
                </description>
            <figure><link>images/image39.png</link></figure>
                </section><section><description>
            Insert Placeholder provides a description of available placeholders along with some examples. Insert Placeholder can be found in the javascript editor. It will either be located at the bottom of the editor as a link called "Insert placeholder..." or found under the "Insert..." button found in a toolbar located at the top of the editor
            </description>
            <figure><link>images/image00.png</link></figure>
                </section><section><description>
            The placeholders you will most frequently encounter are {dialog.object} and {dialog.componentName}. {dialog.object} is the javascript object that contains methods and properties for manipulating and querying the UX component. {dialog.componentName} is the alias for the UX component, which was defined when the UX was either embedded in an .a5w page, another component, or opened using Action Javascript. {dialog.componentName} becomes important when you want to reference elements in the UX component. The UX component uses the alias as part of the ID for elements on the page, in part to ensure IDs are unique. You can use methods in {dialog.object} get pointers to controls in your component (eg, {dialog.object}.getPointer), but other elements in the DOM can only be accessed using $() (a shorthand for document.getElementById) or similar methods.
</description></section><section><description>                
            You may also want to specify IDs for objects in Action Javascripts or free-form HTML so you can reference them. For example, you can specify an ID for the window containing a UX component in the "Open a UX Component" Action Javascript. Specifying an ID for the window allows you to acquire a pointer to the window object so you can call methods, such as hide(), on that window. You need to guarantee your window ID is unique, however. If multiple instances of your UX component will be present on the same page, you can use {dialog.componentName} to create a unique window ID for each instance of the UX component. Without {dialog.ComponentName}, you could potentially create a scenario where both instances of the UX try to update the same window.
</description></section><section><description>
            Not all placeholder objects are available in all contexts. For example, {dialog.ControlID} and {dialog.ControlIDEscaped} are only used in Control Javascript for a control. In Control Javascript, you can specify javascript for a control to add third-party features like jQuery's datepicker. {dialog.ControlIDEscaped} is provided to make it easier for initializing a custom javascript control. Embedding a jQuery date picker is an example of a custom control.
            </description>
            <example><![CDATA[var ele = jQuery('#{dialog.controlIDEscaped}');]]></example>
                </section><section><description>
            If you tried to use this same code in a Client-Side javascript event, such as onRenderComplete, Alpha doesn't know what to do with the placeholder {dialog.controlIDEscaped}. {dialog.controlIDEscaped} has been used outside the context Alpha expects --- the Control Javascript property. If you wanted to reference the same control using jQuery elsewhere, you would need to construct the ID manually. You can use {dialog.componentName} to help re-create the ID.
            </description>    
            <example><![CDATA[var ele = jQuery('{dialog.componentName}\\.V\\.R1\\.TODAY');]]></example>
            
            </section><section><description>
            List objects also have several placeholders which, like {dialog.controlIDEscaped}, can only be used in javascript inside the list control.
</description></section><section><description>
            Embedded components can be referenced using placeholders as well. If you embed a UX component in your UX component, you can use the {dialog.EmbeddedUX_[UXAlias]} to get a pointer to the embedded UX component's {dialog.object} object. You can treat {dialog.EmbeddedUX_[UXAlias]} the same way you treat {dialog.object}. It will have all the same methods, allowing you to interact with the embedded UX component directly. Embedded object placeholders can only be used if you specified an explicit alias
</description></section><section><description>
            [1] for the component. This is also true if you want to use {dialog.object}.getChildObject() method to get a pointer to your embedded component.
            </description></section></sections>
    </group>
    <group>
        <title>{dialog.object} Methods</title>
        <sections><section><description>
    The UX component provides its own set of methods and properties for interacting with the controls on the component. These methods are accessed using the {dialog.object} placeholder. {dialog.object} includes methods for getting and setting values, acquiring pointers to controls and object, modifying the state of controls, and more. Most methods are documented in the Insert Method dialog. The Insert Method dialog can be accessed via the javascript editor's "Insert..." menu in Javascript Functions or Client-Side Events. It may also be listed as a link at the bottom of the javascript editor elsewhere in the UX component.
            </description>
    <figure><link>images/image27.png</link></figure>
            </section><section><description>
    Insert Method contains a listing of functions available in the UX component along with documentation about what the functions do and examples of how to use them. Example code for methods in Insert Method can be copied to the clipboard using the "Copy example to clipboard" link. If you don't need the full example but want to insert a method into your script, select the method to insert and click the Insert button.
</description></section><section><description>
    Insert Method lists the methods you are most likely to encounter or need. It doesn't list every possible method available in {dialog.object}. If you want a list of all methods in {dialog.object}, you can inspect the {dialog.object} using a debugging tool such as Google Chrome's debugger.
</description></section><section><description>
    Alpha Anywhere also provides contextual help in the Javascript editor for methods and placeholders. The auto-complete feature will suggest possible methods or placeholders as you type.
            </description>
    <figure><link>images/image16.png</link></figure>
        </section><section><description>
    Additionally, some methods include access to tools to help define parameters. For example, the help popup for {dialog.object}.getValue() and {dialog.object}.setValue() includes access to a context menu that lists all possible controls in the UX component that can be accessed using these methods. The context menu can be accessed using the right mouse button or holding the control and down arrow key.
            </description>
    <figure><link>images/image17.png</link></figure>
    </section><section><description>
    When writing javascript to interact with your UX component, prefer to use methods in {dialog.object} over native javascript or methods found in Alpha's Core Library. {dialog.object} methods handle updating the UX component's state -- such as flagging the UX component dirty, triggering Client Side Expressions, or calling Client-Side Events. Client Side Expressions can include references to the state of the UX component, such as whether or not the UX component is dirty.
            </description>
    <figure><link>images/image24.png</link></figure>
    </section><section><description>
    The UX component becomes dirty when data in any editable control is changed from its original value. If you programmatically set the value in the text control using a method such as $svs(), the UX component won't know that the data value changed and won't update the enabled state of the button.
    $svs('{dialog.componentName}.V.R1.NAME','Alice');
            </description>
    <figure><link>images/image23.png</link></figure>
    </section><section><description>
    If you use {dialog.object}.setValue(), however, the UX component will flag the text control as dirty, indicating that the control's data value has been modified. This will, in turn, trigger the "Say hello" button to become enabled.
            </description>
            <example><![CDATA[{dialog.object}.setValue('NAME','Edna');]]></example>
    
    <figure><link>images/image11.png</link></figure>
    </section><section><description>
            Methods in {dialog.object} are more than just wrappers around native javascript operations. They do the extra work to update the UX component's state so behaviors dependent on that information know when changes occur.</description>
    </section></sections>
    </group>
    <group>
        <title>Extending {dialog.object}</title>
   <sections><section><description>When a UX component is loaded, the functions and variables defined in Javascript Functions are added to the global namespace. Even though javascript code lives inside your UX component, it doesn't mean it's isolated from the rest of the page. Therefore, it's very important to understand how a component will be used in the context of your entire web application.
</description></section><section><description>
        If a UX component will be used in conjunction with other components or multiple instances of a UX component can exist on the same page, how javascript functions are defined and implemented becomes important. For example, if the web page can have more than one simultaneous instance of the UX component on it within a single session, you will want to consider how you reference any placeholder variables, such as {dialog.object} and {dialog.componentName}. You also want to be cautious how you name your functions. Javascript is a dynamic, interpreted language that permits redefinition of not only variables but also functions during run-time.
</description></section><section><description>
        Consider the following function that is called from the onClick event of a button, called BUTTON_1, on a UX:
       </description>
    <example><![CDATA[function showAlias() {
    var alias = {dialog.object}.dialogId;
    var message = "The Alias of the UX is " + alias;
       
    alert(message);
}]]></example></section><section><description>
    When BUTTON_1 is clicked, the showAlias() function is called. showAlias() gets the alias of the UX component and displays it in a popup message.
       </description>
        <figure><link>images/image04.png</link></figure>
    </section><section><description>
        Suppose, however, that there are two instances of the UX component on a page. This can be accomplished by embedding the UX component twice in another UX component.
       </description>
        <figure><link>images/image22.png</link></figure>
    </section><section><description>
        Run the UX component in Live Preview and click BUTTON_1 in each UX component's instance.
       </description>
        <figure><link>images/image12.png</link></figure>
    </section><section><description>
        Both buttons display the same message. Why did this happen? Since there are two instances of the UX component, the UX component is loaded twice. This also means the UX component's javascript was loaded into the global namespace twice. The first time, the showAlias() function didn't exist, so it was created. The second time, however, the function did exist and was redefined. The implementation of showAlias() used a Placeholder, {dialog.object}, to look up the UX component's alias. Placeholder objects are replaced with their actual values when the UX component is loaded. Each instance of the UX component has a unique {dialog.object}. However, showAlias() resides in the global namespace and can only have one definition.
</description></section><section><description>
        So, how could you fix your code so the showAlias() function shows the correct alias for both UX components? One method involves passing {dialog.object} as a parameter to the function.
       </description>
    <example><![CDATA[function showAlias(ux) {
    var alias = ux.dialogId;
    var message = "The Alias of the UX is " + alias;
       
    alert(message);
}]]></example>
</section><section><description>
        With this change, the implementation of showAlias() is identical for all instances of the UX component. The code in the click event for BUTTON_1 needs to be modified to pass in {dialog.object} to showAlias().
       </description>
        <figure><link>images/image08.png</link></figure>
    </section><section><description>
        If two UX components define a function with the same name but have different implementations, it's no longer a matter of referencing the wrong {dialog.object}. Instead of defining the function in Javascript Functions, it can be added to {dialog.object} as a method. As with the multiple instance case, the last UX component loaded will overwrite the function definition with it's own implementation.
       </description>
    <example><![CDATA[{dialog.object}._functions.showAlias = function () {
    var alias = {dialog.object}.dialogId;
    var message = "The Alias of the UX is " + alias;
       
    alert(message);
}]]></example>
</section><section><description>
        Adding your functions to {dialog.object}._functions is considered a best practice in Alpha Anywhere. Not only does this prevent function name collisions, but it frees you from having to remember what names you've used in components across your web project.
    </description></section><section><description>
        If you use this method, however, you cannot define your functions in Javascript Functions. Code in Javascript Functions is only executed when the UX component is first loaded. If a UX component is displayed using Action Javascript, such as the "Open a UX Component" action, code in Javascript Functions is only loaded the first time the Action Javascript is executed. Subsequent calls to the same Action Javascript will not load Javascript Functions a second time; it may, however, destroy and recreate the UX component's {dialog.object} resulting in a loss of all the methods you added to {dialog.object}._functions.
       </description>
        <figure><link>images/image03.png</link></figure>
</section><section><description>    
        Define methods extending {dialog.object}._functions in the UX component's Client-Side onRenderComplete event instead. This will guarantee the methods are always added to {dialog.object}._functions, even if the {dialog.object} is re-created.
       </description></section></sections>    
        </group>
    <group>
        <title>Modifying Action Javascript Code</title>
    <sections><section><description>In most situations, Action Javascript is sufficient to get the job done. But what if you need to populate attributes with data from a third-party library or need to make a static setting dynamic? In these situations, it may become necessary to convert your Action Javascript to its underlying implementation.
    </description></section><section><description>
    Any Action Javascript in Alpha Anywhere can be converted into code by switching the Event Editor to Text mode. When switching from Action Javascript to Text mode, Alpha Anywhere will convert all Action Javascript actions to code. The javascript that implements the Action Javascripts can be found on the "Javascript - Attribute" and "Declarations - Global" tabs at the bottom of the Event Editor. On the first tab, "Javascript - Attribute", is where you will find the code that calls the Action Javascript. On the second tab, "Declarations - Global", you may find additional logic that implements an Action Javascript. If you had multiple Action Javascripts defined, the javascript instantiating the actions will be listed in the same order as they were defined in Action Javascript Mode.
    </description></section><section><description>
    When you convert Action Javascript to code, Alpha Anywhere will issue a warning message. Converting Action Javascript to code is a one-way street. While you gain access to the underlying implementation, you lose the friendly interface for editing the Action Javascript. Furthermore, you cannot reverse the process. Once an Action Javascript has been turned into code, you can only edit it as code.
    </description></section><section><description>
    Suppose you want to display a Hello message to the user when they click a button after entering their name. Add the "Message Box" Action Javascript to the button's click event. In the message, specify 'Hello, ' + {dialog.object}.getValue('NAME').
        </description>
    <figure><link>images/image33.png</link></figure>
    
    <figure><link>images/image26.png</link></figure>
    </section><section><description>
    This gives you the message, however the message displayed doesn't use the same styling as the UX component. It's  displayed using a javascript alert(), which makes the message appear like a warning when the message isn't a warning at all. Instead of using the simple message, modify the Message Box action to use an advanced message box. The popup will no longer look like a warning. A title can also be added to indicate the message is a greeting. Data from controls, however, can't be included as part of the definition for "Message box text".
        </description>
    <figure><link>images/image40.png</link></figure>
</section><section><description>    
    The basic message box is too alarming and the advanced message box doesn't let you access data in the controls. Since the advanced message box has the desired look, it would be easiest to convert the Message Box action using the advanced message box to code---only the message box text needs to be changed. Switching the editor to Text Mode will expose the implementation so it can be modified.
        </description>
    <figure><link>images/image30.png</link></figure>
    </section><section><description>
    The message box is shown using the A5.msgBox.show() method. A5.msgBox.show() takes 4 parameters: a title, the HTML for the message box body, the buttons to show, and a function to call when the message box is closed. 
        </description></section><section><description>
    In the form generated by Alpha Anywhere, the javascript can be difficult to parse. Using a few variables and a little bit of formatting can make the javascript easier to read.
        </description>
    <example><![CDATA[var title = 'Greeting';
var message = '<div style="padding: 15pt;">Hello, </div>';
var buttons = [{html: 'OK', value: 'ok'}];
var onClose = function(button) {
    if(button == 'ok') {
        setTimeout(function() {},10);
    }
}
A5.msgBox.show(title,message,buttons,onClose);]]></example>
    </section><section><description>
    The final step is to get the value from the NAME control and place it in the message.
        </description>
    <example><![CDATA[var name = {dialog.object}.getValue('NAME');
var title = 'Greeting';
var message = '&lt;div style="padding: 15pt;"&gt;Hello, '+name+'</div>';
var buttons = [{html: 'OK', value: 'ok'}];
var onClose = function(button) {
    if(button == 'ok') {
        setTimeout(function() {},10);
    }
}
A5.msgBox.show(title,message,buttons,onClose);]]></example>
    </section><section><description>
    Now, when the Say hello button is clicked, the message displays the desired greeting.
        </description>
    <figure><link>images/image02.png</link></figure>
        </section></sections>
    </group>
    <group>
        <title>Client Side Expressions, Validation, and Calculated Fields</title>
    <sections><section><description>A number of properties for controls can be configured using javascript, this includes Validation, Show/Hide and Enable expressions, and Calculated Fields. Javascript functions for properties usually take a few parameters and return the value that defines the state of the parameter.
    </description></section><section>
    <title>Validation Javascript</title>
    <description>
    Validation in Alpha Anywhere is very powerful. Using a combination of Client-Side javascript and Server-Side xbasic, you can implement incredibly complex validation criteria with relative ease. Alpha handles displaying the errors to the user. All you need to provide are the rules.
    </description></section><section><description>
    Validation Javascript is defined with javascript. The javascript is run whenever the control's onBlur event fires. Validation Javascript is not executed if the user never interacts with the control. You will need to use Validation Rules or other methods if you want controls in your UX component to be validated before executing some other action, such as submitting the data back to the server.
    </description></section><section><description>
    In your javascript for Validation Javascript, you have access to the value in the control via the data variable. data is a string, so you may need to convert the value to a different type using either Alpha's $u.s.toNum, $u.s.toBool functions or some other method. Alpha expects the Validation Javascript to return an error message or the value false. If you return an error message, the error will be shown to the user and visual indicators will appear in the UX component indicating what control has the error.
    </description></section><section>
    <title>Client-Side Expressions</title>
    <description>
    Listed in a control's Client Side Properties, there are several Client-Side Expressions available: Show/hide expression, Enable expression, and Readonly expression. Expressions are built using a SQL-like syntax. They can reference control values in the UX, some properties of the UX, and functions. There are a set of predefined functions available for use. You can also write your own javascript functions to use in your expressions.
    AGE &gt; 18 and hasValidName(NAME)
        </description>
    <example><![CDATA[function hasValidName(name) {
    if ($u.s.aTrim(name).length &gt; 0) {
        return true;
    }
    return false;
}]]></example>
    </section><section><description>
    It may be tempting to move all expression logic into a function and use {dialog.object}.getValue(). If an expression doesn't reference any controls in an UX, though, the expression will rarely be evaluated. Suppose the following expressions have been defined for two buttons. Each expression call a user-defined javascript function:
    evalMyExp1()
        </description>
        <example><![CDATA[evalMyExp2(NAME)]]></example>
    </section><section><description>
    In evalMyExp1, {dialog.object}.getValue('NAME') is called to get the value in the 'NAME' control.
        </description>
    <example><![CDATA[function evalMyExp1() {
    var name = {dialog.object}.getValue('NAME');
    if ($u.s.aTrim(name).length &gt; 0) {
        return true;
    }
    return false;
}]]></example>
        </section><section><description>
evalMyExp2, however, requires 'NAME' to be passed in as a parameter.
        </description>
<example><![CDATA[function evalMyExp2(name) {
    if ($u.s.aTrim(name).length &gt; 0) {
        return true;
    }
    return false;
}]]></example>
    </section><section><description>
    Both functions perform the same calculation on the same data, the 'NAME' control; however, both expressions are not called when the data, 'NAME', is modified. Only the expression calling evalMyExp2 will be executed after the value in the 'NAME' control changes. Since the evalMyExp1 expression doesn't reference any controls, the UX component doesn't know it should be called when 'NAME' is modified.
    </description></section><section><description>
    Expressions that don't reference any controls in a component are only called when Client Side computations are recalculated. This usually only occurs when a component is first rendered or when data in a component is re-populated in some fashion. You can force expressions to be re-evaluated using {dialog.Object}.refreshClientSideComputations(), but this is not the ideal solution. It's best to include controls as part of your expressions.
    </description></section><section><description>
    If you use javascript to manipulate the state of a control, such as the Action Javascript "Toggle display of a DIV or container" or writing your own javascript function to enable/disable a control as part of another event, do not define an expression for the corresponding property you plan to manipulate. A common mistake is setting a control's Show/hide expression to "1=2" when the UX component is first rendered and then using javascript elsewhere to display the container. Unfortunately, what often happens is the container will disappear seemingly at random. This is usually caused by calls to methods in {dialog.object} that trigger recalculation of the UX component's Client Side computations. "1=2" will always be false, so when the Show/hide expression is re-evaluated by the UX component, it concludes the control should be hidden. If you want a control to be hidden on initial render of a UX component, use styles or add javascript in one of the Client Side Events, such as onInitializeComplete, to hide the control.
    </description></section><section>
    <title>Show/Hide Expression: User Defined Javascript event</title>
    <description>
    For the Show/hide Expression property, you can also create a "User Defined Javascript event", which is a function that is called whenever the Show/hide expression is evaluated. The javascript function takes two parameters: a flag indicating whether or not the control is visible and a row number. Row number refers to the row for a control, a construct found in Grid components. The UX component doesn't have rows, so row number will always have a value of 1 in a UX component.
    </description></section><section>
    <title>Calculated Field Expression</title>
    <description>
    Calculated Field Expressions let you populate a control's value based on the values from other controls in the UX component. The expression can be simple, such as multiplying two numeric fields together. However, sometimes a calculation is more complex than a simple math equation. For example, suppose you wanted to display a person's age based on their birth date. You could create a javascript function to perform the calculation for the Calculated Field Expression. In the Calculated Field Expression, you would call the javascript function, passing the birth date as a parameter (BIRTHDATE is the name of the control containing the birth date)
        </description>
        <example><![CDATA[calcAge(BIRTHDATE)]]></example>
    </section><section><description>
    The function, calcAge, can use the date and time functions in javascript to calculate the age.
        </description>
    <example><![CDATA[function calcAge(birthDate) {
    if (birthDate.length == 0) {
        // no birth date selected
        return 0;
    }
    
    var bDay = new Date(birthDate);
    var today = new Date();
    
    var thisYear = today.getFullYear();
    var bDayThisYear = new Date(thisYear, bDay.getMonth(), bDay.getDate());
    
    var age = thisYear - bDay.getFullYear();
    if (today &lt; bDayThisYear) {
        age = age - 1;
    }        
    return age;
}]]></example></section></sections>
    </group>
    <group>
        <title>Import External Javascript</title>
    <sections><section><description>
    External javascript files can be included in your UX component via the Javascript Files property. Files listed in Javascript Files will be loaded into the browser when the UX component is loaded, and you can reference code in them anywhere in your UX component. The javascript file path can be specified using either a relative or absolute path name. Unless you're referencing javascript files hosted on another server, the javascript files must include the web project so they are published alongside your UX component.
        </description>
    <figure><link>images/image37.png</link></figure>
    </section><section><description>
    Files listed in the Javascript Files property are loaded asynchronously and are therefore not guaranteed to be loaded in a specific order. They're also not guaranteed to be loaded before the UX component is rendered. Since you have no control over how the files are loaded with the Javascript Files property, loading a set of files with order dependencies can present problems. To solve this, javascript files can be loaded using 
        </description>
        <example><![CDATA[{dialog.object}.loadJavascriptFile().]]></example>
    </section><section><description>
    {dialog.object}.loadJavascriptFile() will load a javascript file and then make a (optional) callback to a user-defined function after the file has loaded. The callback can be used to specify another javascript file to load or run any initialization operations that need to happen after the file has loaded. The callback is optional and can be omitted. Loading multiple javascript files can be serialized using a combination of callbacks and {dialog.object}.loadJavascriptFile() operations.
        </description>
    <example><![CDATA[function loadJsFile3() {
    {dialog.object}.loadJavascriptFile('javascript/script3.js');
}

function loadJsFile2() {
    {dialog.object}.loadJavascriptFile('javascript/script2.js',loadJsFile3);
}

function loadJsFiles() {
    {dialog.object}.loadJavascriptFile('javascript/script1.js',loadJsFile2);
}

loadJsFiles();]]></example>
</section><section><description>
    Code loaded using {dialog.object}.loadJavascriptFile() will not be available until after the files have finished loading. Depending on when you load your javascript files, the code within them may not be available in all Client-Side events for the UX component. The callback can be used to finish initializing controls dependent on the javascript file or setup any properties or objects that are required before the javascript file can be used.
        </description>
    <example><![CDATA[function loadingComplete() {
    var msg = "Javascript files have finished loading";
    alert(msg);
}

{dialog.object}.loadJavascriptFile('javascript/messages.js',loadingComplete);]]></example>
        </section></sections>
    </group>
    <group>
        <title>Testing &amp; Debugging</title>
    <sections><section><description>Alpha Anywhere has a number of ways you can debug and test your Javascript code from within the development environment. These debugging methods are available for more than just the UX component. They can be used in Grids, Tabbed UIs, Custom Components, and even .html and .a5w pages.
    </description></section><section>
    <title>Javascript Interactive Window</title>
    <description>The Interactive Window is like a scratch pad for writing javascript. It can be found on the Interactive Window tab in Javascript Functions. Code written in the Interactive Window is executed when <figure><link>images/image25.png</link></figure>Run Javascript is clicked. If there were any errors in your javascript, a popup will appear with a description of the error. If there were no errors and your script doesn't invoke any popup windows (alert(), prompt() or confirm()), nothing will happen. Use one of the native javascript messaging functions, such as alert(), to display any values you want to see in your javascript.
        </description>
    <figure><link>images/image05.png</link></figure>
    </section><section><description>
    The Interactive Window does not have the full context of a web browser, so you do not have access to document or window objects found in a web browser nor do you have access to external javascript sources, placeholder objects, or any other built-in javascript functions and objects in Alpha Anywhere. The Interactive Window is a good place to work out and test simple scripts that don't require external input, such as a text formatting or date parsing script. For more complicated scripts that require the browser, you will need to publish the component to the local webroot and test it in a browser. You can also run the component in Working Preview and use Visual Studio or Google Chrome to assist with debugging and testing javascript.
        </description></section><section><title>Debugging using Visual Studio</title>
        <description>
    Microsoft Visual Studio's debugger can be used in Working Preview to debug javascript. If Visual Studio is installed, you can leverage Visual Studio's Just-In-Time debugging tool for javascript. The debugger can be launched from the Internet Explorer environment using the debugger; statement. To tell what browser is being used, look at the bottom of the Working Preview window. You should see a link that says either "Internet Explorer" or "Chrome". If the link says "Chrome", click the link to switch to Internet Explorer.
        </description>
    <figure><link>images/image42.png</link></figure>
    </section><section><description>
    To open the Visual Studio debugger, place the debugger; statement in your javascript code. You can put this anywhere -- including Client-Side and control events! The first time the debugger; statement is encountered, Visual Studio's Just-In-Time Debugger window will appear. You will be asked what program to use for debugging the component. Select Visual Studio from the list of programs and launch Working Preview again to begin debugging the component.
        </description></section><section><description>
    If you placed the debugger; statement in your javascript and the Just-In-Time debugger did not appear, double-check Working Preview is using Internet Explorer. If Working Preview is using Internet Explorer and the Just-In-Time debugger doesn't appear, debugging may be disabled in Internet Explorer's Internet Options. Check Internet Options to make sure debugging is not disabled.
        </description>
    <figure><link>images/image34.png</link></figure>
    </section><section><description>
    If you don't have Visual Studio installed, you can download Microsoft's Visual Studio Express for free from Microsoft's website.
        </description></section><section>
        <title>Chrome Debugger</title>
    <description>
    If you don't have Visual Studio installed, Google's Chrome debugger is a great alternative. The Chrome debugger can be used inside Working Preview to debug your component. At the bottom of Working Preview, there is an "Internet Explorer" link. Clicking the link opens a window that will let you change the browser used by Working Preview. If Google Chrome is installed on your system, you'll have an option to switch to Chrome for the Working Preview. Changing the browser used in Working Preview will close the Working Preview and place you back in Design mode. Subsequent visits to Working Preview will be using the browser you selected.
        </description>
    <figure><link>images/image31.png</link></figure>
    </section><section><description>
    Similar to using the Visual Studio debugger, Chrome's debugger also supports using the debugger; statement to add breakpoints. Placing the debugger; statement in your javascript will open the Chrome debugger in Working Preview when the statement is encountered. The first time you run a component in Working Preview, the debugger; statement may not open the Chrome debugger. The Chrome debugger needs to be activated first. The Open Chrome Debugger link at the bottom of the Working Preview window will launch the Chrome debugger.
        </description>
        <figure><link>images/image36.png</link></figure>
    </section><section><description>
    Once the Chrome debugger has been opened, it will remain open in the background. Click Reload Page and the Chrome debugger will popup whenever debugger; is encountered. You can also click the Open Chrome Debugger link to bring the Chrome debugger to the foreground.
        </description>
    <figure><link>images/image38.png</link></figure>
    </section><section><description>
    The Working Preview window can be detached from the designer when using the Chrome browser. When detached, you can make changes to the component in Design mode and see the changes right away in the Working Preview window. The Refresh button will update the Working Preview. You can also turn on auto-refresh. Auto-refresh will immediately update Working Preview when any change is made to the component. If you component has a lot of controls or is complex, however, you may notice a delay while editing with auto-refresh on.
        </description>
    <figure><link>images/image14.png</link></figure>
    </section><section><description>
        [1] Note: {dialog.componentName} is used as part of the ID for an embedded or child component. An embedded component's alias only needs to be unique among the other components embedded in the same UX component.</description></section></sections>
    </group>
</groups>

</page>