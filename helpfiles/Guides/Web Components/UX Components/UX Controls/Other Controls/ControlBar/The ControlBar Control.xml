<page>
<topic>The ControlBar</topic>

<groups>
<group>
<title>ControlBar Concepts</title>
<sections>

<section>
<description>In order to understand how ControlBars work you need to understand the following ControlBar concepts, each of which is explained in more detail below.</description>
</section>

<section>
<title>Layouts</title>
<description><p>A ControlBar control can have multiple 'layouts'. In this respect, a ControlBar is similar to a List control, a ViewBox control or a FormView control, all of which also can have multiple layouts.</p>
<p>You can dynamically select which of the ControlBar layouts to display. So, for example, you might use one layout for a phone in portrait mode, another layout for a phone in landscape mode, yet another layout for a tablet in portrait mode, etc. You can use Javascript to choose which ControlBar layout to set as the active layout, or you can use the Responsive Layout Settings genie to select the active layout.</p>
<p>Another example of where having a ControlBar with multiple layouts would be useful is in the case of a PanelNavigator. You could also define a ControlBar for the header section of the PanelNavigator and then dynamically change the layout that was shown depending on which PanelCard was shown in the PanelNavigator.</p></description>
</section>


<section>
<title>Layout Lines</title>
<description>Each layout that you define in a ControBar can have one or more 'lines'. In many cases a layout will only have a single line. In the first image showing a typical Panel header, only a single 'line' would be needed in the ControlBar layout.
Each 'line' in a ControlBar layout is divided into three sections.</description>
</section>

<section>
<list>
<item><description>before</description></item>
<item><description>middle</description></item>
<item><description>after</description></item>


</list>

</section>

<section>
<description>
The 'before' section is for left justified content, and the 'after' section is for right justified content. The reason that these sections are not called 'left', 'center' and 'right' as you might have expected is that a ControlBar can be aligned to any edge of the screen. If a ControlBar is aligned to the top or bottom of the screen, the ControlBar is horizontal and 'before' does correspond to 'left' and 'after' does correspond to 'right'. However, ControlBars can also be aligned to the left or right of the screen. In these cases, the ControlBar will be rendered vertically, and the 'before' section will then correspond to the 'top' of the ControlBar and the 'after' section will correspond to the 'bottom' of the ControlBar.</description>
</section>


<section>
<title>ControlBar Items</title>
<description>The content that you place in each of the Layout line sections are termed 'ControlBar Items'. There are several types of ControlBar items:
html - used to display text
button - used to invoke an action
button-toggle - used to set a state. You can define 'two state' or 'multi-state' toggles.
button-list - used to display a list of buttons, one (or multiple - depending on a setting) of which can be in the 'selected' state.
disclosure-button - used to display a 'disclosure' (see below for definition)
ControlBar items (with the exception of the 'html' item type) can have associated actions. For example, you can define actions for the following events on a ControlBar button:
Click
Downhold
Up
Down
Swipe
 </description>


</section>

<section>
<title>Actions</title>
<description>The code for each of these events is not defined directly in the definition of the ControlBar item. Instead, you define the code in 'actions'.
You can create as many 'actions' as you want. Each 'action' is given an arbitrary name.
Once you have defined an action (say 'myaction1') you associate a ControlBar item event with a particular action. So for example, you might set the 'click' event for a ControlBar button to 'myaction1'.
The advantage of putting your code in named 'actions' rather than directly in a ControlBar item's event (e.g. a button's Click event) is that you might define multiple buttons for display on different ControlBar layouts and each of these buttons can invoke the same action.</description>



</section>
<section>
<title>Data</title>
<description>
ControlBars can have an arbitrary amount of data. The data for a ControlBar is defined as a series of name/value pairs. The values can either be strings, or objects.
For example, you might define a data item called 'name' and give it a value of 'Alpha Anywhere'. You could define another data item called 'address' and give it a value of:</description>

<example><![CDATA[{ address: '123 Main St', city: 'Lexington', state: 'MA'}]]></example>
</section>
<section>
<description>
In this case the data item is an object and to reference the state you would use address.state as the data item name.
The common reason for defining data items in a ControlBar is to bind the text displayed by the ControlBar items to data values.
For example, you might define an 'html' ControlBar item called (say) 'html1'. You could set the text for this ControlBar item to a literal value (e.g. 'My Mobile App') or you might set the text to:</description>
<example><![CDATA[{name}]]></example>
</section>

<section>
<description>
When the ControlBar was displayed if the 'name' item in the ControlBar's data was set to 'Alpha Software' the ControlBar would display this value. To change the text shown in the ControlBar, you simply update the value of the data item (using a method of the ControlBar - see ControlBar Methods below).
Similarly, you might define a 'button' ControlBar item and set the button text to '{name}'.
The curly braces are how you reference values from the ControlBar's data object. You can use the client side templating syntax when defining the text for a ControlBar item. For example:</description>
<example><![CDATA[{*if dataItem1 == 'A'}{dataitem2}{*else}{dataitem3}{*endif}]]></example>
 
<note>For more information on client-side templates see the documentation.</note>
</section>
<section>
 <description>Data values can be set to update automatically when a 'watch' event fires. For example, when the value in a control that is being watched changes, a watch event will fire if that particular control is being watched. Watch events also fire when the UX changes 'state'. For example, when the UX goes from 'clean' to 'dirty', all of the watch events will fire.
You can also manually cause watch events to fire using this UX method:</description>
<example><![CDATA[{dialog.Object}.refreshClientSideComputations()]]></example>
</section>
<section>
<description> <p>A common use case for setting data values with watch events is to control the enable/disable or shown/hidden state of ControlBar items. For example, say you have a button in the ControlBar to synchronize data. You would like this button to only be enabled if the List control is dirty.</p>
<p>To do this you would define an entry (call 'SyncDisabled' for example) in the ControlBar's Data collection. Let's assume that the value of the data property will be set to either false or true depending on whether the List has data to synch.
So, the Disabled expression for this button would be:</p></description>
<example><![CDATA[syncDisabled]]></example>
</section>
<section>

 <description>We need to turn the value of the SyncDisabled data value to 'on' when the List has dirty data.
If we look at the enable expression for a standard sync button on the UX (button was created using the List genie), we see that the expression is defined as:</description>
<example><![CDATA[(dialog.list.LIST1.isDirty = true) AND (dialog.listDetailView.LIST1.mode <> 'search')]]></example>
</section>

 <section><description>
The syntax used for client-side enable functions is not Javascript. It is a special Xbasic like syntax that gets converted by AllphaAnywhere into Javascript.
The above enable expression can be expressed as a Javascript expression as follows:</description>
<example><![CDATA[(dialog.list.LIST1.isDirty ) && (dialog.listDetailView.LIST1.mode != 'search')]]></example>
</section>
<section>
 
<description>The watch event for the 'syncDisabled' data value could therefore be defined as:</description>
<example><![CDATA[return !(dialog.list.LIST1.isDirty ) && (dialog.listDetailView.LIST1.mode != 'search');]]></example>
 
</section>
<section>
<description>
Notice that we are returning the inverse of the expression. If the expression (not including the leading ! character, which inverts a logical value) returns true (indicating that the button should be enabled), we want to return false (so that the Disabled expression for the button is false and the button is not disabled).</description>


</section>

<section>
<title>Disclosures</title>

<description>Disclosures are displayed when the user taps on a 'disclosure-button'. A disclosure can be:
any arbitrary html (defined in the Disclosure sections of the ControlBar builder)
another layout defined in the ControlBar
 
The images below show a typical use case for disclosures. The images are taken from the Gmail app running on an iPhone. In the first image the Gmail toolbar is shown with the disclosure in its closed state.</description>
</section>
<section>

<description>In this image the user has tapped on the 'disclosure button' (the down arrow in the above image) and the disclosure is now shown. Notice that the state of the 'disclosure button' has changed and it now displays an up arrow).</description>
</section>

<section>
<description>Building this type of behavior in your own apps is easy with the ControlBar.
When a disclosure is shown you can specify where on the screen it should be displayed and you can also specify if animation should be used when showing and hiding the disclosure.
You have a great deal of control over where the disclosure is shown. For example, the disclosure might extend below the ControlBar (as it does in the Gmail example shown above), it might overlay the ControlBar, or it might be displayed at a specific location on the screen.
You also have control over how a disclosure is hidden after it has been shown. The disclosure can be set to 'auto-hide' which means that as soon as the user taps on any part of the screen that is not part of the disclosure, the disclosure will close. Alternatively, when the user taps the 'disclosure button' a second time, the disclosure will close.
Only one disclosure can be shown at a time. If a button on a disclosure opens another disclosure, the first disclosure will be closed.</description>
</section>

<section>
<title>Injectable Content Inside a Disclosure</title>
<description>When you define a disclosure you specify the HTML to be shown by the disclosure. In some cases you will want the disclosure to display standard UX controls (e.g. text boxes, buttons, Lists, etc.)
In order to display standard UX controls in a disclosure you add the controls you want to display in the disclosure to the UX and then you wrap the controls in a Container with a sub-type of InjectibleContent.
Then when you are defining the HTML for the disclosure, you can insert a placeholder for the InjectibleContent. When the disclosure is displayed, the contents of the InjectibleContent container is injected into the disclosure.</description>
</section>



</sections>

</group>
<group>
<title>ControlBar Methods</title>
<sections>
<section>
<description>The ControlBar has several methods. These methods are documented in detail in the API documentation. Click here for details. This section will describe the more commonly used methods.</description>
<figure><link></link></figure>
</section>
<section>
<title>Updating ControlBar Data</title>
<description>The ControlBar data is often used to define the text shown on the ControlBar. For example, this pattern is very common:</description>
<steps>
<step>
<description>
Define a property in the ControlBar's data (called 'Label1' for example)
</description>
</step>
<step>
<description>
Define an HTML item for the ControlBar and set the text for this HTML item to {Label1}
</description>
</step>
<step>
<description>
Add this HTML item to the 'before', 'middle', or 'after' section on a 'Line' in a ControlBar Layout.
</description>
</step>
</steps>
</section>
<section>

<description>
When the ControlBar is rendered, the text shown on the ControlBar for the HTML item will be the value of the 'Label1' data property.
To change the text that is displayed on the ControlBar you would need to update the value of the 'Label1' data property in the ControlBar. The .update() method is used for this. The .update() method allows you to update a single data property or an array of data properties.
For example:</description>

<example><![CDATA[var cbObj = {dialog.object}.getControl('CONTROLBAR_1') //get a pointer to the ControlBar
var newValue = {dialog.object}.getValue('LIST1') //get the new value
cbObj.update('Label1',newValue); //update the data property.]]></example>
 
<note><![CDATA[NOTE: When you call the <controlBar>.update() method, the ControlBar is automatically refreshed. There is no need to explicitly call the <controlBar>.refresh() method.]]></note>
 </section>
<section>

<description>
If you wanted to update several data properties you pass in an array of data property names and an array of values. For example:
</description>
<example><![CDATA[var props = ['prop1','myObj.prop1'];
var vals = ['value1',true];
var cbObj = {dialog.object}.getControl('CONTROLBAR_1');
cbObj.update(props,vals);]]></example>
 
<note>It is preferable to update several data properties at once rather than calling the .update() method several times because that will only cause the ControlBar to refresh once, rather than each time the .update() method is called.</note>
</section> 
<section>


<note>You can use Action Javascript to generate the code for the .update() method.</note>
 </section>

<section>
<description>
You can also use 'low level' techniques to update the ControlBar data. For example, the following code does the same thing as the .update() method:</description>
 
<example><![CDATA[var cb = {dialog.object}.getControl('CONTROLBAR_1'); //get pointer to ControlBar
cb.data.item1 = 'new value of item1'; //set a data property directly
cb.refresh(); //refresh the ControlBar]]></example>
</section>
 <section>
<description>
When any data values in the ControlBar data are changes, the ControlBar onChange event fires. The event gets an array of data properties that were changed and an array of the values for these properties.
 
</description>
</section>
<section>
<title>Selecting the Active ControlBar Layout</title>
<description>It is common when using the ControlBar builder to add multiple Layouts to the ControlBar and then to dynamically select which Layout to display. For example, you might define different Layout for for Phone-Landscape, Phone-Portrait, Tablet-Portrait and Tablet-Landscape. The .setLayout() method allows you to dynamically select which Layout to show.
When you set the active Layout you can specify if animation should be used and if so, what type of animation and the animation duraction.
For example, the following code sets the active Layout without animation:</description>
<example><![CDATA[var cbObj = {dialog.object}.getControl('CONTROLBAR_1');
cbObj.setLayout('Layout2');]]></example>
</section>
<section> 
<description>Now, set the active Layout, but this time, use animation.</description>
<example><![CDATA[var cbObj = {dialog.object}.getControl('CONTROLBAR_1');
cbObj.setLayout('Layout2',{"type": "slide-in","duration": 200,"tween": "ease-in-out"});]]></example>
 
<note>The active ControlBar Layout can be set in the UX's Responsive Layout Settings. You can also use Action Javascript to generate the code.</note>
 </section>
<section>
<description>As part of the ControlBar definition, you can specify that the active Layout should be dynamically computed using Javascript. Whenever the ControlBar is refreshed (using the .refresh() method), the Javascript to compute the active Layout is executed.
</description>


</section>

<section>

<title>Summary of ControlBar Methods</title>

<list>
<item>
<title>action()</title>
<description><![CDATA[<controlBar>.action()	Programmatically fire an action of the control bar.]]></description>
</item>
<item>
<title>destroy</title>
<description><![CDATA[<controlBar>.destroy()	Destroy the control bar. This method should be called before the control bar is removed from the DOM.]]><description>
</item>
<item>
<title>hideDisclosure()</title>
<description><![CDATA[The <controlBar>.hideDisclosure() hides the currently shown disclosure.]]></description>
</item>
<item>
<title>initializeItems()</title>
<description><![CDATA[The <controlBar>.initializeItems() method	initializes items in the control bar. This is automatically called when the control bar is created. If item definitions are changed after creation, <controlBar>.initializeItems()  must be called in order for the changes to take effect.</description>
</item>
<item>
<title>populate()</title>
<description><![CDATA[The <controlBar>.populate() populates the control bar with new data.]]></description>
</item>
<item>
<title>refresh()</title>
<description><![CDATA[<controlBar>.refresh()	Refresh the control bar.]]></description>
</item>
<item>
<title>resizeDisclosure</title>
<description><![CDATA[<controlBar>.resizeDisclosure()	Resize the currently shown disclosure. This can be used if the layout of the control bar has changed.]]></description>
</item>
<item>
<title>SetLayout{}</title>
<description><![CDATA[<controlBar>.setLayout()	Sets the ControlBar layout to use. You can specify the type of animation to use when the ControlBar is refreshed.]]></description>
</item>
<item>
<title>showDisclosure()</title>
<description><![CDATA[The <controlBar>.showDisclosure()	Show a disclosure. You can specify where the disclosure is shown by specifying a "type". The "expand" family of types will expand the disclosure over the control bar area. In a horizontal layout "before" is left and "after" is right, in a vertical layout "before" is top and "after" is bottom. The "expand-element" type will expand the disclosure for the optionally passed in element, and "expand-element-cover" will do the same only covering the element. The "extend" family will extend the disclosure away from the "edge" defined in A5.ControlBar.edge. By default "extend" will show the disclosure without occluding the control bar. For instance if the "edge" is "top" then the disclosure will dropdown from the bottom edge of the control bar. The "extend-element" type will extend the disclosure for the optionally passed in element, and "extend-element-cover" will do the same only covering the element. The "cover" type will show the disclosure from the "edge" defined in A5.ControlBar.edge, sized to cover the entire control bar. The "outside" family of types will show the disclosure over the area outside the control bar on the opposite side from the edge of the control bar. The "screen" family of types will show the disclosure from the specified edge of the screen. The "explicit" type will show the disclosure in the passed in custom "rectangle".]]></description>
</item>
<item>
<title>update()</title>
<description><controlBar>.update()	Update values in the data. A single path and value may be passed in, or an array of paths and values.</description>
</item>
 
 


<section>
<title>



<section>


</sections>
</group>



</groups>




</page>
