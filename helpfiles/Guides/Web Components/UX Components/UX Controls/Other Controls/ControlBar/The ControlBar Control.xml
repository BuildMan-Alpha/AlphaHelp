<page>
<topic>The ControlBar</topic>

<groups>
<group>
<title>ControlBar Concepts</title>
<sections>

<section>
<description>In order to understand how ControlBars work you need to understand the following ControlBar concepts, each of which is explained in more detail below.</description>
</section>

<section>
<title>Layouts</title>
<description><p>A ControlBar control can have multiple 'layouts'. In this respect, a ControlBar is similar to a List control, a ViewBox control or a FormView control, all of which also can have multiple layouts.</p>
<p>You can dynamically select which of the ControlBar layouts to display. So, for example, you might use one layout for a phone in portrait mode, another layout for a phone in landscape mode, yet another layout for a tablet in portrait mode, etc. You can use Javascript to choose which ControlBar layout to set as the active layout, or you can use the Responsive Layout Settings genie to select the active layout.</p>
<p>Another example of where having a ControlBar with multiple layouts would be useful is in the case of a PanelNavigator. You could also define a ControlBar for the header section of the PanelNavigator and then dynamically change the layout that was shown depending on which PanelCard was shown in the PanelNavigator.</p></description>
</section>


<section>
<title>Layout Lines</title>
<description>Each layout that you define in a ControBar can have one or more 'lines'. In many cases a layout will only have a single line. In the first image showing a typical Panel header, only a single 'line' would be needed in the ControlBar layout.
Each 'line' in a ControlBar layout is divided into three sections.</description>
</section>

<section>
<list>
<item><description>before</description></item>
<item><description>middle</description></item>
<item><description>after</description></item>


</list>

</section>

<section>
<description>
The 'before' section is for left justified content, and the 'after' section is for right justified content. The reason that these sections are not called 'left', 'center' and 'right' as you might have expected is that a ControlBar can be aligned to any edge of the screen. If a ControlBar is aligned to the top or bottom of the screen, the ControlBar is horizontal and 'before' does correspond to 'left' and 'after' does correspond to 'right'. However, ControlBars can also be aligned to the left or right of the screen. In these cases, the ControlBar will be rendered vertically, and the 'before' section will then correspond to the 'top' of the ControlBar and the 'after' section will correspond to the 'bottom' of the ControlBar.</description>
</section>


<section>
<title>ControlBar Items</title>
<description>The content that you place in each of the Layout line sections are termed 'ControlBar Items'. There are several types of ControlBar items:
html - used to display text
button - used to invoke an action
button-toggle - used to set a state. You can define 'two state' or 'multi-state' toggles.
button-list - used to display a list of buttons, one (or multiple - depending on a setting) of which can be in the 'selected' state.
disclosure-button - used to display a 'disclosure' (see below for definition)
ControlBar items (with the exception of the 'html' item type) can have associated actions. For example, you can define actions for the following events on a ControlBar button:
Click
Downhold
Up
Down
Swipe
 </description>


</section>

<section>
<title>Actions</title>
<description>The code for each of these events is not defined directly in the definition of the ControlBar item. Instead, you define the code in 'actions'.
You can create as many 'actions' as you want. Each 'action' is given an arbitrary name.
Once you have defined an action (say 'myaction1') you associate a ControlBar item event with a particular action. So for example, you might set the 'click' event for a ControlBar button to 'myaction1'.
The advantage of putting your code in named 'actions' rather than directly in a ControlBar item's event (e.g. a button's Click event) is that you might define multiple buttons for display on different ControlBar layouts and each of these buttons can invoke the same action.</description>



</section>
<section>
<title>Data</title>
<description>
ControlBars can have an arbitrary amount of data. The data for a ControlBar is defined as a series of name/value pairs. The values can either be strings, or objects.
For example, you might define a data item called 'name' and give it a value of 'Alpha Anywhere'. You could define another data item called 'address' and give it a value of:</description>

<example><![CDATA[{ address: '123 Main St', city: 'Lexington', state: 'MA'}]]></example>
</section>
<section>
<description>
In this case the data item is an object and to reference the state you would use address.state as the data item name.
The common reason for defining data items in a ControlBar is to bind the text displayed by the ControlBar items to data values.
For example, you might define an 'html' ControlBar item called (say) 'html1'. You could set the text for this ControlBar item to a literal value (e.g. 'My Mobile App') or you might set the text to:</description>
<example><![CDATA[{name}]]></example>
</section>

<section>
<description>
When the ControlBar was displayed if the 'name' item in the ControlBar's data was set to 'Alpha Software' the ControlBar would display this value. To change the text shown in the ControlBar, you simply update the value of the data item (using a method of the ControlBar - see ControlBar Methods below).
Similarly, you might define a 'button' ControlBar item and set the button text to '{name}'.
The curly braces are how you reference values from the ControlBar's data object. You can use the client side templating syntax when defining the text for a ControlBar item. For example:</description>
<example><![CDATA[{*if dataItem1 == 'A'}{dataitem2}{*else}{dataitem3}{*endif}]]></example>
 
<note>NOTE: For more information on client-side templates see the documentation.</note>
</section>
<section>
 <description>Data values can be set to update automatically when a 'watch' event fires. For example, when the value in a control that is being watched changes, a watch event will fire if that particular control is being watched. Watch events also fire when the UX changes 'state'. For example, when the UX goes from 'clean' to 'dirty', all of the watch events will fire.
You can also manually cause watch events to fire using this UX method:</description>
<example><![CDATA[{dialog.Object}.refreshClientSideComputations()]]></example>
</section>
<section>
<description> <p>A common use case for setting data values with watch events is to control the enable/disable or shown/hidden state of ControlBar items. For example, say you have a button in the ControlBar to synchronize data. You would like this button to only be enabled if the List control is dirty.</p>
<p>To do this you would define an entry (call 'SyncDisabled' for example) in the ControlBar's Data collection. Let's assume that the value of the data property will be set to either false or true depending on whether the List has data to synch.
So, the Disabled expression for this button would be:</p></description>
<example><![CDATA[syncDisabled]]></example>
</section>
<section>

 <description>We need to turn the value of the SyncDisabled data value to 'on' when the List has dirty data.
If we look at the enable expression for a standard sync button on the UX (button was created using the List genie), we see that the expression is defined as:</description>
<example><![CDATA[(dialog.list.LIST1.isDirty = true) AND (dialog.listDetailView.LIST1.mode <> 'search')]]></example>
</section>

 <section><description>
The syntax used for client-side enable functions is not Javascript. It is a special Xbasic like syntax that gets converted by AllphaAnywhere into Javascript.
The above enable expression can be expressed as a Javascript expression as follows:</description>
<example><![CDATA[(dialog.list.LIST1.isDirty ) && (dialog.listDetailView.LIST1.mode != 'search')]]></example>
</section>
<section>
 
<description>The watch event for the 'syncDisabled' data value could therefore be defined as:</description>
<example><![CDATA[return !(dialog.list.LIST1.isDirty ) && (dialog.listDetailView.LIST1.mode != 'search');]]></example>
 
</section>
<section>
<description>
Notice that we are returning the inverse of the expression. If the expression (not including the leading ! character, which inverts a logical value) returns true (indicating that the button should be enabled), we want to return false (so that the Disabled expression for the button is false and the button is not disabled).</description>


</section>

<section>
<title>Disclosures</title>

<description>Disclosures are displayed when the user taps on a 'disclosure-button'. A disclosure can be:
any arbitrary html (defined in the Disclosure sections of the ControlBar builder)
another layout defined in the ControlBar
 
The images below show a typical use case for disclosures. The images are taken from the Gmail app running on an iPhone. In the first image the Gmail toolbar is shown with the disclosure in its closed state.</description>
</section>
<section>

<description>In this image the user has tapped on the 'disclosure button' (the down arrow in the above image) and the disclosure is now shown. Notice that the state of the 'disclosure button' has changed and it now displays an up arrow).</description>
</section>

<section>
<description>Building this type of behavior in your own apps is easy with the ControlBar.
When a disclosure is shown you can specify where on the screen it should be displayed and you can also specify if animation should be used when showing and hiding the disclosure.
You have a great deal of control over where the disclosure is shown. For example, the disclosure might extend below the ControlBar (as it does in the Gmail example shown above), it might overlay the ControlBar, or it might be displayed at a specific location on the screen.
You also have control over how a disclosure is hidden after it has been shown. The disclosure can be set to 'auto-hide' which means that as soon as the user taps on any part of the screen that is not part of the disclosure, the disclosure will close. Alternatively, when the user taps the 'disclosure button' a second time, the disclosure will close.
Only one disclosure can be shown at a time. If a button on a disclosure opens another disclosure, the first disclosure will be closed.</description>
</section>
</sections>

</group>




</groups>




</page>
