<page>
  <topic>List Virtualization</topic>
  
  <description>Normally, when a List control is populated, the HTML for all of the rows in the List is rendered. If the list only has a few rows (say 200 rows), then there is no noticeable delay while the List is populated.</description>
  
  <sections>
    
    <section>
      <description>However, if the List has a lot of rows (say several thousand rows), then there will be a noticeable delay while the List is populated and also, a large amount of memory will be consumed by the List. On a mobile device where memory is more limited, the amount of memory consumed by the List could be a problem.
List virtualization allows you to only create HTML elements for a portion of the List - the portion that is currently visible and some additional rows above and below the currently visible portion. The number of rows that are rendered in the List is called the 'page' size.
When the user is scrolling the List and they hit a page boundary, the user can tap on a Next or Previous button (or optionally use a pull/release gesture) to populate the List with the next or previous page of data. It is important to recognize that tapping the Next or Previous button does not trigger an Ajax callback. It is simply rendering the next or previous page of data using the data that has already been loaded into the List and is in memory. Therefore, the time take to populate the next or previous page is practically instantaneous.
The advantage of virtualizing the List is that you can dramatically reduce the time taken to load large Lists and you can reduce the memory footprint of the List.
To turn on List Virtualization, set the Virtualization type property shown below to 'Dynamic'.
</description>
    
    </section>
    <section>
      <videos>
        <video>
          <description>Watch Video</description>
          <link>http://www.ajaxvideotutorials.com/V12Videos/ux_listVirtualizationDemo.swf</link>
        </video>
         <video>
          <description>Download component</description>
          <link>http://www.ajaxvideotutorials.com/V12Videos/listVirtualizationDemo.zip</link>
        </video>
        
        
      </videos>
      
      
    </section>
    <section>
      <description>Once you do this, several additional properties will be shown</description>
      <figure><link>images/listVirtualization.jpg</link></figure>
      
    </section>
    <section>
      <cases>
        <case>
          <title>Virtualization type</title>
          <description>Set to 'None' to turn virtualization off. Set to 'Dynamic' to turn virtualization on.</description>
        </case>
         <case>
          <title>Size</title>
          <description>The size property defines the 'page' size - the number of rows of data that should be rendered. This should typically be a multiple of the number of rows in the viewport. For example, say that your List can display 20 rows of data at a time, you might set the size to (say) 100 so that the user can scroll a fair amount before hitting the page boundary.
When you reach a page boundary (either on top or bottom of the page), there are 'Next' and 'Previous' buttons to get the next logical 'page' of data. The user can either tap on the Next/Previous button, or use a pull/release action to fetch the next page of data. 
</description>
        </case>
         <case>
          <title>Max size</title>
          <description>This is an advanced optional setting that can be used to specify a type of 'hybrid' virtualization. By default, this property is set to 0, which means that the number of rows that the List renders is always equal to the 'page' size. When you hit a page boundary, the current page is memory is replaced by the next page that is loaded.
However, if you set the Max size to -1 (which indicates that the max size is equal to the number of rows in the List), or some positive number that is greater than the size property, then when you are navigating forward and you hit a page boundary, the next page of data is automatically rendered (without requiring the user to tap the Next button). The number of rows in memory continues to grow as the user scrolls down in the List. In other words, the memory consumed by the List is initially very small (as only a single page of data are rendered) and the time taken to render the List is optimized (again, because only a single page of data are rendered), but as the user scrolls, the number of rendered rows in the List continue to grow and more memory is consumed. When the 'max size' is reached, then the user will then have to use the 'Next' button to continue to viewing additional records. 
</description>
        </case>
         <case>
          <title>Offset</title>
          <description>When you hit a page boundary, and click the Next/Previous button, the 'offset' indicates the number of rows from the page that is being discarded that should be included in the new view. If this number is less than the number of rows in the viewport, the List will appear to 'jump' when you navigate to a new page. It is recommended that this value be set to a minimum of the number or records that can be seen in the viewport at one time so that when the user taps the Next/Previous button, the scroll position of the List does not change. It is recommended that this number be no more than half of the 'page size'. The larger the number, the more rows the user can scroll backwards before hitting the Next/Previous buttons.
</description>
        </case>
         <case>
          <title>Navigate on pull </title>
          <description>Allows the user to pull/release to navigate (in addition to tapping on the Next/Previous buttons).</description>
        </case>
          <case>
          <title>Pull size</title>
          <description>Number of pixels before the 'pull/release' gesture is recognized as a 'navigate' action.</description>
        </case>
        
        
      </cases>
      
      
    </section>
    
  </sections>
</page>