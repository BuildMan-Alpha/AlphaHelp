<page>
    <shortlink>ClientSideTemplates</shortlink>
    <topic>Client Side Templates</topic>
    <description>There are a rich set of template directives that make templates both extremely powerful and also easy to use.</description>
    <groups>
        <group>
            <title>Client-side Template Syntax</title>
            <sections>
                <section>
                    <title>The Scope Placeholder</title>
                    <description>
                        <p>If the data passed to the template expand function contains nested objects, or arrays, you can use special {scope} placeholders, where scope is the name of nested object or array.</p>
                        <p>For example, consider the following simple data object:</p>
                    </description>
                    <example><![CDATA[{name: 'John Smith', address: {street: '1 Main', city: 'Boston'}}]]></example>
                </section>
                <section>
                    <description>The template to print this could be:</description>
                    <example><![CDATA[{name}
{address.street}
{address.city}]]></example>
                </section>
                <section>
                    <description>or more conveniently, a {scope} variable could be used:</description>
                    <example><![CDATA[{name}
{address}
    {street}
    {city}
{/address}]]></example>
                </section>
                <section>
                    <description>
                        <p>The {scope} variable acts like an 'with' statement in Xbasic.</p>
                        <p>Within the {scope}, it is not necessary to fully qualify the placeholder names.</p>
                        <p>In the case where the data contains a nested array, the {scope} variable indicates that the template should loop over the rows in the array.</p>
                        <p>For example, consider this data object:</p>
                    </description>
                    <example><![CDATA[[
    {name: 'John Smith', children: [{name: 'Griffin'}, {name: 'Callie'}]},
    {name: 'Toby Mohan, children: [{name: 'Kyle'}, {name: 'Katy', name: 'Luke'}]}
]]]></example>
                </section>
                <section>
                    <description>And the following template:</description>
                    <example><![CDATA[{name}<br>
<ul>
    {children}
        <li>{name}</li>
    {/children}<br>
</ul>]]></example>
                </section>
                <section>
                    <description>Which will produce this output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>John Smith<br/>
<ul>
    <li>Griffin</li>
    <li>Callie</li>
</ul>
Toby Mohan<br/>
<ul>
    <li>Kyle</li>
    <li>Katy</li>
	<li>Luke</li>
</ul>
</div>]]>
                    </content>
                </section>
                <section>
                    <title>The Value Placeholder</title>
                    <description>
                        <p>The value placeholder, <![CDATA[{[value]}]]>, is a special placeholder to use when looping over arrays of values, rather than arrays of objects.</p>
                        <p>In the previous example, the data was specified as:</p>
                    </description>
                    <example><![CDATA[[
    {name: 'John Smith', children: [{name: 'Griffin'}, {name: 'Callie'}]},
    {name: 'Toby Mohan, children: [{name: 'Kyle'}, {name: 'Katy', name: 'Luke'}]}
]]]></example>
                </section>
                <section>
                    <description>
                        <p>The nested array is an array of objects.</p>
                        <p>However, the data could have been specified as:</p></description>
                    <example><![CDATA[[
    {name: 'John Smith', children: 'Griffin','Callie']  },
    {name: 'Toby Mohan, children: ['Kyle', 'Katy','Luke']}
]]]></example>
                </section>
                <section>
                    <description>
                        <p>In this case, the nested array is an array of values, not of objects.</p>
                        <p>To emit the data in the array, the template must use the special {[value]} placeholder. For example:</p>
                    </description>
                    <example><![CDATA[{name}<br>
<ul>
    {children}
        <li>{[value]}</li>
    {/children}<br>
</ul>]]></example>
                    <note>The [value] field can be followed by formatting directives, just like any other field. For example:
<![CDATA[{[value]:number('$#,###.00')}]]></note>
                </section>
                <section>
                    <title>Handling Missing Data</title>
                    <description>
                        <p>In some cases the data you pass in to the template expander will have missing data. The || directive allows you to specify alternative text in the template when a data value is missing.</p>
                        <p>For example, consider the following data object:</p>
                    </description>
                    <example><![CDATA[{
    employees: [
        {firstname: 'Fred', lastname: 'Smith', city: 'Boston'},
        {firstname: 'Laura', lastname: 'Linneker'}
    ]
}]]></example>
                </section>
                <section>
                    <description>The 'city' property has been specified for the first object in the 'employees' array, but not the second.</description>
                    <example><![CDATA[{employees}
    Employee name: <b>{firstname} {lastname}</b> City: {city||Not available}<br>
{/employees}]]></example>
                </section>
                <section>
                    <description>
                        <p>The text to display for a missing value is specified in the placeholder after a || delimiter. In the template shown above, the missing text for the {City} property has been specified as 'Not available'.</p>
                        <p>The template above gives us the following result for our data object:</p>
                    </description>
                </section>
                <section>
                    <content><![CDATA[<div>
Employee name: <b>Fred Smith</b> City: Boston<br/>
Employee name: <b>Laura Linneker</b> City: Not available<br/>
</div>]]></content>
                    <note>The missing data directive can be combined with formatting directives. For example: <![CDATA[{price:number('#.00')||N/A}]]></note>
                </section>
                <section>
                    <title>Headers and Footers</title>
                    <description>
                        <p>Headers and Footer can be added if the data object you pass into to the template expander contains array data. Using the special <![CDATA[{*header}...{/*header}]]> and <![CDATA[{*footer}...{/*footer}]]> directives, you can add a header or footer as part of the template.</p>
                        <p>For example, assume we have the following array of JSON data:</p>
                    </description>
                    <example><![CDATA[{
    employees: [
        {firstname: 'Fred', lastname: 'Smith'},
        {firstname: 'Laura', lastname: 'Linneker'}
    ]
}]]></example>
                </section>
                <section>
                    <description>This data is an array of two employees. We would like to add the text "Ths is the header - it prints before the first item in the array" and "This is the footer - it prints after the last item in the array". This can be done using the {*header} and {*footer} directives. The template to add the header and footer looks like this:</description>
                    <example><![CDATA[{employees}
    {*header}
        This is the header - it prints before the first item in the array<br>
    {/*header}
    Employee name: <b>{firstname} {lastname}</b><br>
    {*footer}
        This is the footer - it prints after the last item in the array
    {/*footer}
{/employees}]]></example>
                </section>
                <section>
                    <description>When the data is processed through the template, this is the resulting output we will see:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
This is the header - it prints before the first item in the array<br/>
Employee name: <b>Fred Smith</b><br/>
Employee name: <b>Laura Linneker</b><br/>
This is the footer - it prints after the last item in the array
</div>]]></content>
                </section>
                <section>
                    <title>Empty Arrays</title>
                    <description>
                        <p>If an array does not contain any entries you can specify alternative text to display. This is done using the <![CDATA[{*empty}...{/*empty}]]> directive. The text inside the {*empty} directives will be displayed in the event that an array contains no data.</p>
                        <p>For example, consider the following sample data:</p></description>
                    <example><![CDATA[{
    employees: [
        {firstname: 'Fred', lastname: 'Smith', skills: [ {name: 'Javascript'},{name: 'CSS'}]},
        {firstname: 'Laura', lastname: 'Linneker', skills: [{name: 'Xbasic'}]},
        {firstname: 'Junior', lastname: 'Programmer', skills: [] }
    ]
}]]></example>
                </section>
                <section>
                    <description>
                        <p>Notice that only the last array instances does not have any rows in the skills array. If the skills array is empty, we would like to print "No skills yet". Otherwise, we would like to display a list of skills and the total number of skills an employee has. The template defined below demonstrates how this is done:</p>
                    </description>
                    <example><![CDATA[{employees}
    Employee name: <b>{firstname} {lastname}</b><br>
    <div style="border:solid 1px green; margin-left:50px;">
        {skills}
            {*empty}
                No skills yet
            {/*empty}
            Skill Name: {name}<br>
            {*footer}
                <i>Count of skills: {@countSkills}</i>
            {/*footer}
        {/skills}
    </div>
{/employees}]]></example>
                </section>
                <section>
                    <description>
                        <p>Using the {*empty} directive, we are able to define what should be displayed if the employee has no skills.</p>
                        <p>Additionally, we are able to provide a count of skills using the {*footer} directive and a javascript function, countSkills (called using the {@countSkills} directive), to do the calculation. The countSkills implementation is below is:</p>
                    </description>
                    <example><![CDATA[function countSkills(data,context) {
    return data[context].length;
}]]></example>
                </section>
                <section>
                    <description>When the employee array is processed by the template, we get the result below:</description>
                </section>
                <section>
                    <content><![CDATA[
<div>Employee name: <b>Fred Smith</b><br/>
<div style="border:solid 1px green; margin-left:50px;">
Skill Name:  Javascript<br/>
Skill Name:  CSS<br/>
<i>Count of skills: 2</i>
</div>
Employee name: <b>Laura Linneker</b><br/>
<div style="border:solid 1px green; margin-left:50px;">
Skill Name:  Xbasic<br/>
<i>Count of skills: 1</i>
</div>
Employee name: <b>Junior Programmer</b><br/>
<div style="border:solid 1px green; margin-left:50px;">
No skills yet	
</div>
</div>]]></content>
                </section>
                <section>
                    <title>Conditional Sections</title>
                    <description>Templates can include conditional sections. Conditionals allow you to choose what to do when specific values, aka conditions, are met. Conditional sections are defined using the following template commands:</description>
                    <cases>
                        <case>
                            <description><![CDATA[{*if logicalExpression}]]></description>
                        </case>
                        <case>
                            <description><![CDATA[{*elseif logicalExpression}]]></description>
                        </case>
                        <case>
                            <description><![CDATA[{*else}]]></description>
                        </case>
                        <case>
                            <description><![CDATA[{*endif}]]></description>
                        </case>
                    </cases>
                </section>
                <section>
                    <description>
                        <p>logicalExpression is any Javascript expression that evaluates to a true/false value. The logicalExpression can refer to data in the current 'row' of data.</p>
                        <p>For example, consider the following data:</p>
                    </description>
                    <example><![CDATA[{
    employees: [
        {firstname: 'Fred', lastname: 'Smith', state: 'MA'},
        {firstname: 'Laura', lastname: 'Linneker', state: 'CA'},
        {firstname: 'Junior', lastname: 'Programmer', state: 'MA'},
        {firstname: 'Bill', lastname: 'Lindsey', state: 'NY'}
    ]
}]]></example>
                </section>
                <section>
                    <description>
                        <p>When an employee's state is "MA" or "CA", we would like to print the text "Employee is based in MA" or "Employee is based in CA", respectively. If they are not in either state, the text "Employee is not based in MA or CA" should be printed instead.</p>
                        <p>Using conditional template commands, we can check the value of state to determine which text should be printed, as shown in the tempalte below:</p>
                    </description>
                    <example><![CDATA[{employees}
    Employee name: {[countOneBased]} <b>{firstname} {lastname}</b><br>
    <div style="border: solid 1px blue; margin-left:20px; margin-bottom: 10px;">
        {*if state=='MA'}
            Employee is based in MA
        {*elseif state=='CA'}
            Employee is based in CA
        {*else}
            Employee is not based in MA or CA
        {*endif}<br>
    </div>
{/employees}]]></example>
                </section>
                <section>
                    <description>When the employees array data is processed, the template produces the result below:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
 Employee name: 1 <b>Fred Smith</b><br/>
<div style="border: solid 1px blue; margin-left:20px; margin-bottom: 10px;">
Employee is based in MA<br/>
</div>
Employee name: 2 <b>Laura Linneker</b><br/>
<div style="border: solid 1px blue; margin-left:20px; margin-bottom: 10px;">
Employee is based in CA<br/>
</div>
Employee name: 3 <b>Junior Programmer</b><br/>
<div style="border: solid 1px blue; margin-left:20px; margin-bottom: 10px;">
Employee is based in MA<br/>
</div>
Employee name: 4 <b>Bill Lindsey</b><br/>
<div style="border: solid 1px blue; margin-left:20px; margin-bottom: 10px;">
Employee is not based in MA or CA<br/>
</div>
</div>]]></content>
                </section>
                <section>
                    <title>Formatting Directives</title>
                    <description>
                        <p>You can include formatting directives in the template placeholder to format numeric values and strings, and to format date values.</p>
                        <p>To format a numeric value, use the <![CDATA[:number(formattingDefinition)]]> directive in your placeholder.</p>
                        <p>For example, assume you have a field called Price, which contains this value: 123456.345.</p>
                        <p>You might define the template to emit this field as follows:</p>
                    </description>
                    <example><![CDATA[{Price:number('$#,###.00')}]]></example>
                </section>
                <section>
                    <description>This will result in the following output:</description>
                    <example><![CDATA[$123,456.35]]></example>
                </section>
                <section>
                    <description>
                        <p>You can also use the <![CDATA[:number()]]> directive to merge strings into templates. For example,, assume that you have a field called Phone, which contains 6715551234.</p>
                        <p>The placeholder for this field in your template could be defined as:</p>
                    </description>
                    <example><![CDATA[{Phone:number('=(###) ###-####')}]]></example>
                </section>
                <section>
                    <description>This will result in the following output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>(617) 555-1234</div>]]></content>
                </section>
                <section>
                    <description>
                        <p>To format a date value, use the :date(formattingDefinition) directive in your placeholder.</p>
                        <p>You can use the following symbols in the formattingDirective.</p>
                    </description>
                    <cases>
                        <case>
                            <description>yy - 2 digit year (e.g. 72)</description>
                        </case>
                        <case>
                            <description>yyyy - 4 digit year (e.g. 1972)</description>
                        </case>
                        <case>
                            <description>dd - day with leading 0 (e.g. 04)</description>
                        </case>
                        <case>
                            <description>d - day (e.g. 4)</description>
                        </case>
                        <case>
                            <description>MM - month with leading 0 (e.g. 03)</description>
                        </case>
                        <case>
                            <description>M - month (e.g. 3)</description>
                        </case>
                        <case>
                            <description>Mon - 3 character month abbreviation with capital first letter (e.g. Dec)</description>
                        </case>
                        <case>
                            <description>mon - 3 character month abbreviation (e.g. dec)</description>
                        </case>
                        <case>
                            <description>Month - month name in full, with capital first letter (e.g. December)</description>
                        </case>
                        <case>
                            <description>month - month name in full (e.g. december)</description>
                        </case>
                    </cases>
                </section>
                <section>
                    <description>
                        <p>You can also use the :uppercase and :lowercase directives to force string values to upper or lower case.</p>
                        <p>For example:</p>
                    </description>
                    <example><![CDATA[{name:uppercase}
{name:lowercase}]]></example>
                    <note>The missing data directive can be combined with formatting directives. For example:  <![CDATA[{price:number('#.00')||N/A}]]></note>
                </section>
                <section>
                    <title>Expressions</title>
                    <description>
                        <p>Placeholders in a template can contain arbitrary Javascript expressions. For example, assume that you have the following data:</p>
                    </description>
                    <example><![CDATA[{product: 'Book', qty: 4, price: 23}]]></example>
                </section>
                <section>
                    <description>Suppose you would like to print product in all caps. Since product is a string data type, the .toUpperCase() javascript method can be used to convert the whole string to upper case. EG:</description>
                    <example><![CDATA[{product.toUpperCase()}]]></example>
                </section>
                <section>
                    <description>Math can also be performed on numeric data. For example, the total price can be calculated and the result formatted to include currency symbols. EG:</description>
                    <example><![CDATA[{price * total:number('$#,###.00')}]]></example>
                </section>
                <section>
                    <description>Combining the two examples above, we can create a template that outputs the product name, the price, quantity, and the total amount:</description>
                    <example><![CDATA[Product: {product.toUpperCase()} - Price: {price}, Quantity: {qty} - Total: {price * total:number('$#,###.00')}]]></example>
                </section>
                <section>
                    <description>Our template gives us the following:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
BOOK - Price 23, Quantity: 4 - Total $92.00
</div>]]></content>
                </section>
                <section>
                    <title>Functions</title>
                    <description>
                        <p>Your template can include calls to Javascript functions that compute values based on data in the current 'row'. To call a function you use the <![CDATA[{@JavascriptFunctionName}]]> placeholder in your template, where JavascriptFunctionName is the name of the Javascript function that you want to call.</p>
                        <p>The value returned by the function is emitted for the placeholder.</p>
                        <p>The Javascript function takes a single parameter, data, which allows you to reference data from the current row.</p>
                        <p>Consider the following simple data object:</p>
                    </description>
                    <example><![CDATA[{firstname: 'John', lastname: 'Smith'}]]></example>
                </section>
                <section>
                    <description>And the following template:</description>
                    <example><![CDATA[Hello {@fullname}]]></example>
                </section>
                <section>
                    <description>The fullname Javascript function might be defined as:</description>
                    <example><![CDATA[function fullname(data) {
    return data.firstname + ' ' + data.lastname.toUpperCase();
}]]></example>
                </section>
                <section>
                    <description>The template result for the above data, template and Javascript function will be:</description>
                    <example><![CDATA[Hello John SMITH]]></example>
                </section>
                <section>
                    <description>
                        <p>Functions can also be used to compute summary data. For example, assume that the data object you define includes an array of data. You might want to output summary data that includes (say) the count of the number of rows in the array and the total of one of the fields in the array.</p>
                        <p>Consider the following sample data object:</p>
                    </description>
                    <example><![CDATA[{
    customer: [
        {name: 'Smith', amountDue: 345.34},
        {name: 'Jones', amountDue: 35.43},
        {name: 'King', amountDue: 45.14}
    ]
}]]></example>
                </section>
                <section>
                    <description>And the following template:</description>
                    <example><![CDATA[{customer}
    {name} - {amountDue}<br>
    {*footer}
        Total amount due: {@amountDue} from {@count} customers.
    {/*footer}
{/customer}]]></example>
                </section>
                <section>
                    <description>And the following definition for the 'amountDue' and 'count'  javascript function:</description>
                    <example><![CDATA[function amountDue(data,scope) {
    var arr = data[scope]
    var tot = 0;
    for(var i = 0; i < arr.length; i++) {
        tot = tot + arr[i].amountDue;
    }
    return $u.n.round(tot,2);
}

function count(data,scope) {
    return data[scope].length;
}]]></example>
                </section>
                <section>
                    <description>The above will produce this output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Smith - 345.34<br/>
Jones - 35.43<br/>
King - 45.14<br/>
Total amount due: 425.91 from 3 customers.
</div>]]></content>
                </section>
                <section>
                    <description>
                        <p>In the above example, notice that the 'amountDue' and 'count' functions are in the {*footer}..{/*footer} block inside the {customer}..{/customer} scope. When the Javascript functions are called from inside a {*header} or {*footer} block the scope ('customer') is passed into the function along with the data. ('data' is the first argument, and 'scope' is the second argument).</p>
                        <p>What's in the 'data' object passed into a Javascript function depends on where the Javascript function is called from.</p>
                        <p>If a Javascript function is called from within a {*header} or {*footer} placeholder the data in the data object will be the same as if the function had been called from outside the scope. In other words, if the template has {@myfunction} after the closing {/customer} placeholder, the data passed to the 'myfunction' Javascript function will be the same as the data that would be passed to the function had it been called from inside a {*header} or {*footer} block inside the scope (e.g. {customer}...{/customer}.</p>
                        <p>On the other had, if the {@myfunction} placeholder is used anywhere within the scope (e.g. inside the {customer} ..{/customer} block), but not inside a {*header} or {*footer} block, the data object only contains data for the current array instance and the 'scope' value is blank.</p>
                        <p>The following example will help make this clear:</p>
                        <p>Data:</p>
                    </description>
                    <example><![CDATA[{
    customer: [
        {name: 'Smith', amountDue: 345.34},
        {name: 'Jones', amountDue: 35.43},
        {name: 'King', amountDue: 45.14}
    ]
}]]></example>
                </section>
                <section>
                    <description>Template:</description>
                    <example><![CDATA[{customer}
    {name} - {amountDue} - {@data}<br>
    {*footer}
        In footer:<br>{@data}
    {/*footer}
{/customer}
<br>
Outside the 'Customer' scope: {@data}]]></example>
                </section>
                <section>
                    <description>Javascript Function:</description>
                    <example><![CDATA[function data(data,scope) {
    if(scope == '') scope = 'BLANK';
    var json = JSON.stringify(data,'\t');
    var msg = '<div style="border: solid 1px red;"><b>scope</b>: ' + scope +       

                '<br><b>data</b>: ' + json + '</div>';
    return msg;
}]]></example>
                </section>
                <section>
                    <description>The above produces this output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Smith - 345.34 - <div style="border: solid 1px red;"><b>scope</b>: BLANK<br/><b>data</b>: {"name":"Smith","amountDue":345.34}</div><br/>Jones - 35.43 - <div style="border: solid 1px red;"><b>scope</b>: BLANK<br/><b>data</b>: {"name":"Jones","amountDue":35.43}</div><br/>
King - 45.14 - <div style="border: solid 1px red;"><b>scope</b>: BLANK<br/><b>data</b>: {"name":"King","amountDue":45.14}</div>
<br/>
In footer:<br/>
<div style="border: solid 1px red;"><b>scope</b>: customer<br/><b>data</b>: {"customer":[{"name":"Smith","amountDue":345.34},{"name":"Jones","amountDue":35.43},{"name":"King","amountDue":45.14}]}</div>
<br/>
Outside the 'Customer' scope: <div style="border: solid 1px red;"><b>scope</b>: BLANK<br/><b>data</b>: {"customer":[{"name":"Smith","amountDue":345.34},{"name":"Jones","amountDue":35.43},{"name":"King","amountDue":45.14}]}</div>
</div>]]></content>
                </section>
                <section>
                    <description>
                        <p>Note that the 'data' Javascript function simply shows the data that is passed into the function (as a JSON string) and also shows the value of the 'scope' argument.</p>
                        <p>The 'data' function is called in 3 different places:</p>
                    </description>
                    <cases>
                        <case>
                            <description>Inside the {customer} scope - (i.e. once for each customer in the array)</description>
                        </case>
                        <case>
                            <description>Inside the {*footer} block (inside the {customer} scope</description>
                        </case>
                        <case>
                            <description>Outside the {customer} scope</description>
                        </case>
                    </cases>
                </section>
                <section>
                    <description>
                        <p>As show, inside the {customer} scope, the data passed into the function is just the data for the current array instance and the 'scope' passed into the function is blank.</p>
                        <p>However, when the Javascript function is called from inside the {*footer} block, the data and scope passed into the function are the same as if the function had been called from outside the {customer} scope. In this case the data passed into the function includes all of the data in the scope.</p>
                        <p>With the above understanding of the what's passed into the Javascript function, let's re-examine the 'amountDue' and 'count' functions from the previous example. Here is the function definition again:</p>
                    </description>
                    <example><![CDATA[function amountDue(data,scope) {

    var arr = data[scope]
    var tot = 0;
    for(var i = 0; i < arr.length; i++) {
        tot = tot + arr[i].amountDue;
    }
    return $u.n.round(tot,2);
}]]></example>
                </section>
                <section>
                    <description>The amountDue function has been called from inside a {*footer} construct. Therefore the data passed into the function looks like this (in JSON format)</description>
                    <example><![CDATA[{"customer":[{"name":"Smith","amountDue":345.34},{"name":"Jones","amountDue":35.43},{"name":"King","amountDue":45.14}]}]]></example>
                </section>
                <section>
                    <description>Therefore we can get the array of data shown in the {customer} scope by using this Javascript statement:</description>
                    <example><![CDATA[data['customer']]]></example>
                </section>
                <section>
                    <description>However, the 'scope' variable that was also passed into the function contains 'customer', so we can get the array of data as follows:</description>
                    <example><![CDATA[data[scope]]]></example>
                </section>
                <section>
                    <description>
                        <p>Once we have the array of data, it is a simple matter of writing a Javascript loop to sum up the value in the 'amountDue' property for each row in the array.</p>
                        <p>Note that before we return the number we use the $u.n.round() function from the Alpha Anywhere Javascript library to round the result to 2 decimal places.</p>
                        <p>The 'count' function is even simpler. We simply return the length of the array.</p>
                    </description>
                    <example><![CDATA[function count(data,scope) {
    return data[scope].length;
}]]></example>
                </section>
                <section>
                    <description>
                        <p>Here is a more complex example that shows an object with two arrays of data - 'charges' and 'payments'. Our template shows the total charges, total payments, and the net amount due (total charges - total payments)</p>
                        <p>Here is the data:</p>
                    </description>
                    <example><![CDATA[{
    charges: [
        {name: 'Smith', amount: 345.34},
        {name: 'Jones', amount: 35.43},
        {name: 'King', amount: 45.14}
      ],
    payments: [
        {name: 'Smith', amount: 123.34},
        {name: 'Jones', amount: 45.45}
        ]
}]]></example>
                </section>
                <section>
                    <description>Here is the template:</description>
                    <example><![CDATA[<b>Charges</b><br>
{charges}
    {name}<br>
    {*footer}
        Total charges: {@totaldue}
    {/*footer}
{/charges}<br>

<br>
<b>Payments</b><br>
{payments}
    {name}<br>
    {*footer}
        Total payments: {@totaldue}
    {/*footer}
{/payments}<br>
<br>
Net amount due: {@netdue}]]></example>
                </section>
                <section>
                    <description>Here is the Javascript:</description>
                    <example><![CDATA[function totaldue(data,context) {
    var tot = 0;
    var arr = data[context];
    for(var i = 0; i < arr.length; i++) {
        tot = tot + arr[i].amount;
    }
    return tot.toFormat('$#,###.00');
}

function netdue(data,context) {
    var arr = data['charges'];
    var totDue = 0;
    for(var i = 0; i < arr.length; i++) {
        totDue = totDue + arr[i].amount;
    }

    arr = data['payments'];
    var totPay = 0;
    for(var i = 0; i < arr.length; i++) {
        totPay = totPay + arr[i].amount;
    }

    var netDue = totDue - totPay;
    return netDue.toFormat('$#,###.00');

}]]></example>
                </section>
                <section>
                    <description>And here is output produced by this template:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
<b>Charges</b><br/>
Smith<br/> 
Jones<br/> 
King<br/> 
Total charges: $425.91 
<br/>
<br/>
<b>Payments</b><br/>
Smith<br/> 
Jones<br/> 
Total charges: $168.79 
<br/>
<br/>
Net amount due: $257.12 
</div>]]></content>
                </section>
                <section>
                    <description>
                        <p>Notice in the above example that the same 'totalDue' function can be used to return both the total charges and the total payments (because in the first case the 'scope' passed into the function will be 'charges' and in the second case, the 'scope' passed into the function will be 'payments'.</p>
                        <p>The 'netDue' function that called from outside both the 'charges' and 'payments' scope gets called with the data for both arrays. This function gets the charges array using this syntax:</p>
                    </description>
                    <example><![CDATA[data['charges']]]></example>
                </section>
                <section>
                    <description>
                        <p>and then computes the total charges.</p>
                        <p>Then it gets the payments array, using this syntax:</p>
                    </description>
                    <example><![CDATA[data['payments']]]></example>
                </section>
                <section>
                    <description>
                        <p>and then computes the total payments.</p>
                        <p>Once the total charges and total payments are computed, the net amount due can be computed.</p>
                    </description>
                </section>
                <section>
                    <title>Emitting Array Instance Data</title>
                    <description>
                        <p>When you are outside a scope that references array data, you can use a special syntax in the scope placeholder to display values from the scoped array.</p>
                        <p>For example, consider the following output from a template:</p>
                    </description>
                </section>
                <section>
                    <content><![CDATA[<div>
<b>Showing employees from: 'Smith' to 'Programmer' <br/>
Employees</b><br/>
Employee name: 1 <b>Fred Smith</b><br/>
<div style="border:solid 1px green; margin-left:50px;">
skillName: 1 Javascript<br/>
skillName: 2 CSS<br/>
<i>Count of skills: 2</i>
</div>
Employee name: 2 <b>Laura Linneker</b><br/>
<div style="border:solid 1px green; margin-left:50px;">
skillName: 1 Xbasic<br/>
<i>Count of skills: 1</i>
</div>
Employee name: 3 <b>Junior Programmer</b><br/>
<div style="border:solid 1px green; margin-left:50px;">
No skills yet	
</div>
</div>]]></content>
                </section>
                <section>
                    <description>Notice that before the Employees are shown, the template shows:</description>
                </section>
                <section>
                    <content><![CDATA[<div><b>Showing employees from: 'Smith' to 'Programmer'</b></div>]]></content>
                </section>
                <section>
                    <description>
                        <p>Where 'Smith' is a value from the first row in the array, and 'Programmer' is a value from the last row in the array.</p>
                        <p>In the above example, the following template was defined:</p>
                    </description>
                    <example><![CDATA[Showing employees from: '{employees[0].lastname}' to '{employees[-1].lastname}' <br>
{employees}
    {*header}
        <b>Employees</b><br>
    {/*header}
    Employee name: {[countOneBased]} <b>{firstname} {lastname}</b><br>
    <div style="border:solid 1px green; margin-left:50px;">
        {skills}
            {*empty}
                No skills yet
            {/*empty}
            skillName: {[countOneBased]} {name}<br>
            {*footer}
                <i>Count of skills: {@countSkills}</i>
            {/*footer}
        {/skills}
    </div>
{/employees}]]></example>
                </section>
                <section>
                    <description>
                        <p>Notice that outside the {employees} scope, the following template directives can be used to emit data from the employees array:</p>
                        <p>{employees[0].lastname} - 'lastname' property from the 1st array instance.</p>
                        <p>{employees[-1].lastname} - 'lastname' property from the last array instance.</p>
                    </description>
                </section>
                <section>
                    <title>Partial Templates</title>
                    <description>Partial templates are named sub-templates. A template can reference these partial templates using the {*partial partialName} command. This is useful if a template has text that is repeated. For example, consider the following Javascript code:</description>
                    <example><![CDATA[//define the data
var _d = {firstname: 'Fred', lastname: 'Smith'}

//define the template
var arr = [];
arr.push('Welcome<br>');
arr.push('Hello {firstname} {lastname}<br>');
arr.push('{*partial partial1}');

var _t = arr.join('\n');

//define the settings object (template and partials)
var settings = {
    template: _t,
    partials: {
        partial1: 'from partial1: {firstname} {lastname}<br>'
    }
}

//merge the data into the template
var html = A5.u.template.expand(_d,settings);]]></example>
                </section>
                <section>
                    <description>This will produce the following output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Welcome<br/>
Hello Fred Smith<br/>
from partial1: Fred Smith<br/>
</div>]]></content>
                </section>
            </sections>
        </group>
        <group>
            <title>New Features Added in Alpha Anywhere V3</title>
            <sections>
                <section>
                    <description>The following features require Alpha Anywhere V3</description>
                </section>
                <section>
                    <title>Root Placeholder for Array Data</title>
                    <description>
                        <p>Previously if the data you passed into the  A5.u.template.expand() function was an array (as opposed to an object with an array as property of the object), you could not use the {*header} and {*footer} directives in your template to generate a header or footer for the array data.</p>
                        <p>Now, you don't have to artificially structure your data as a top level object with an array as a property of the object. The {*root} tag is now supported when the data passed in is an array.</p>
                        <p>Consider the following sample data:</p>
                    </description>
                    <example><![CDATA[var data = [
    {firstname: 'Fred', lastname: 'Smith'},
    {firstname: 'John', lastname: 'Jones'}
]]]></example>
                </section>
                <section>
                    <description>and the following template:</description>
                    <example><![CDATA[ var template = [
                            '{*root}',
                            '{*header}There are {root.length} people<br />{/*header}',
                            '{firstname} {lastname}<br />',
                            '{*footer}Count: {root.length} {/*footer}',
                            '{/*root}'
                        ].join('');]]></example>
                </section>
                <section>
                    <description>This data and template will product this output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
There are 2 people<br/>
Fred Smith<br/>
John Jones<br/>
Count: 2
</div>]]></content>
                </section>
                <section>
                    <description>Because the template uses the {*root} tag, the data that is passed in is implicitly restructured as:</description>
                    <example><![CDATA[ var data = {
    root: [
            {firstname: 'Fred', lastname: 'Smith'},
            {firstname: 'John', lastname: 'Jones'}
           ]
    }]]></example>
                </section>
                <section>
                    <title>Escaping the { and } Characters in a Template</title>
                    <description>
                        <p>The { and } characters in a template indicate placeholders for merged data. If you want to explicitly output either of these characters you can escape them using a leading backslash.</p>
                        <p>Assume that the data you pass to the template expander is:</p>
                    </description>
                    <example><![CDATA[ {firstname: 'Fred'}]]></example>
                </section>
                <section>
                    <description>Assume that you want the output from the template to be</description>
                </section>
                <section>
                    <content><![CDATA[<div>{Fred}</div>]]></content>
                </section>
                <section>
                    <description>You would define your template as:</description>
                    <example><![CDATA[\{{firstname}\}]]></example>
                </section>
                <section>
                    <title>Pre-processing Array Data</title>
                    <description>
                        <p>You can now pre-process arrays before they are expanded.</p>
                        <p>For example, assume you have the following data:</p>
                    </description>
                    <example><![CDATA[ var data = {
    company: [
        {firstname: 'Fred', lastname: 'Smith'},
        {firstname: 'John', lastname: 'Jones'},
        {firstname: 'Andrea', lastname: 'Jones'},
        {firstname: 'Margo', lastname: 'Jones'}
    ]
}]]></example>
                </section>
                <section>
                    <description>And the following template:</description>
                    <example><![CDATA[ var template = [
    '{company}',
    '{firstname} {lastname}<br>',
    '{/company}'
].join('');]]></example>
                </section>
                <section>
                    <description>This template and data combination will result in this output:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Fred Smith<br/>
John Jones<br/>
Andrea Jones<br/>
Margo Jones<br/>
</div>]]></content>
                </section>
                <section>
                    <description>
                        <p>But, say you only wanted to output the top two customers. To do this you would need to pre-process the company array before it was expanded. You can specify the name of a function to call before an array is expanded using the @functionName directive in the placeholder for the array.</p>
                        <p>For example, notice in the template below, the placeholder for the company array specifies that the processCompany function should be called before the data are expanded:</p></description>
                    <example><![CDATA[ var template = [
    '{company@processCompany}',
    '{firstname} {lastname}<br>',
    '{/company}'
].join('');]]></example>
                </section>
                <section>
                    <description>The array pre-processor function gets called with three arguments</description>
                    <cases>
                        <case>
                            <description>data - the array that is being expanded</description>
                        </case>
                        <case>
                            <description>temp - a global storage object that will exist for the entire length of time that the template is being expanded. You can use this object to capture information to be output later in the template.</description>
                        </case>
                        <case>
                            <description>root - the root data object (i.e. all of the data)</description>
                        </case>
                    </cases>
                </section>
                <section>
                    <description>
                        <p>Your array pre-processor function must return the array that you want to render.</p>
                        <p>Here is how the processCompany array pre-processor function could be defined:</p>
                    </description>
                    <example><![CDATA[ function processCompany(data,temp,root) {
    //limit to first two items in the array
    data = data.slice(0,2);
    return data;
}]]></example>
                </section>
                <section>
                    <description>The resulting output is now:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Fred Smith<br/>
John Jones<br/>
</div>]]></content>
                </section>
                <section>
                    <description>Now assume you want to first sort the data by the 'firstname' property, then return the top two entries. In this case, the array pre-processor function would be defined as:</description>
                    <example><![CDATA[ function processCompany(data,temp,root) {
    //sort on the 'firstname' property
    data.sort( function(a,b) {
        if (a.firstname < b.firstname) return -1;
        if (a.firstname > b.firstname) return 1;
        return 0;
        }
    )

    //limit to first two items in the array
    data = data.slice(0,2);
    return data;
}]]></example>
                </section>
                <section>
                    <description>The resulting output is now:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Andrea Jones<br/>
Fred Smith<br/>
</div>]]></content>
                </section>
                <section>
                    <description>An important use for the array pre-processor function is to compute summary data for the array. See Using the Special "root" and "temp" Variables in Templates below. You can compute all of the summary values your template needs in a single function, rather than defining separate functions for each summary value your template outputs.</description>
                </section>
                <section>
                    <title>Using the temp and root Template Variables</title>
                    <description>
                        <p>You can use the special "root" and "temp" variables in a template by enclosing them in [ and ].</p>
                        <p>The example below demonstrates the use of both [root] and [temp] in the template.</p>
                        <p>TIP: To watch a video of how the template used in this example was developed, watch these videos:</p>
                    </description>
                    <videos>
                        <video>
                            <name>Watch Video - Part 1</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_1.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 2</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_2.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 3</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_3.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 4</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_4.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 5</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_5.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 6</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_6.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 7</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_7.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 8</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_8.swf</link>
                        </video>
                        <video>
                            <name>Watch Video - Part 9</name>
                            <link>http://www.ajaxvideotutorials.com/V12Videos/ux_client_side_template_tutorial_9.swf</link>
                        </video>
                    </videos>
                </section>
                <section>
                    <description>
                        <p>For example, consider the following data set:</p>
                    </description>
                    <example><![CDATA[ var data = [
    {
        orderId: 1,
        date: '1/1/2014',
        orderItems: [
                {itemId: 1, qty: 3, price: 23.4},
                {itemId: 23, qty: 2, price: 3.3},
                {itemId: 7, qty: 5, price: 5.3}
            ]
    },
    {
        orderId: 2,
        date: '1/2/2014',
        orderItems: [
            {itemId: 31, qty: 7, price: 3.8},
            {itemId: 17, qty: 4, price: 9.2}
        ]
    },
    {
        orderId: 3,
        date: '1/5/2014',
        orderItems: [
            {itemId: 11, qty: 9, price: 13.3},
            {itemId: 27, qty: 2, price: 19.2},
            {itemId: 6, qty: 19, price: 3.6},
            {itemId: 7, qty: 22, price: 9.1}
        ]
    }
]]]></example>
                </section>
                <section>
                    <description>
                        <p>The data are an array of order objects. Each order has a nested array called 'orderItems' that have the order items for that order.</p>
                        <p>Assume that you would like the template to render as shown below:</p>
                    </description>
                </section>
                <section>
                    <content><![CDATA[<div>
Order Id: 1 (Order number 1 of 3 orders - for orders placed between <b>1/1/2014</b> and <b>1/5/2014</b>)<br/>
Order Date: 1/1/2014<br/>
<table style="border-collapse: collapse;" border="1" cellpadding="3" cellspacing="1"><tr>
    <th>#</th>
    <th>Item Id</th>
    <th>Quantity</th>
    <th>Price</th>
    <th>Extended Total</th>
</tr>
<tr>
	<td>1</td>
	<td>1</td>
	<td style="text-align:right;">3</td>
	<td style="text-align:right;">$23.40</td>
	<td style="text-align:right;">$70.20</td>
</tr>
<tr>
	<td>2</td>
	<td>23</td>
	<td style="text-align:right;">2</td>
	<td style="text-align:right;">$3.30</td>
	<td style="text-align:right;">$6.60</td>
</tr>
<tr>
	<td>3</td>
	<td>7</td>
	<td style="text-align:right;">5</td>
	<td style="text-align:right;">$5.30</td>
	<td style="text-align:right;">$26.50</td>
</tr>
<tr>
	<td>Count: 3</td>
	<td></td>
	<td>Avg Quantity: 3.33</td>
	<td>Avg Price $10.67</td>
	<td style="text-align:right;">Total: $103.30 </td>
</tr>
</table>
<br/>
Order Id: 2 (Order number 2 of 3 orders - for orders placed between <b>1/1/2014</b> and <b>1/5/2014</b>)<br/>
Order Date: 1/2/2014<br/>
<table style="border-collapse: collapse;" border="1" cellpadding="3" cellspacing="1"><tr>
    <th>#</th>
    <th>Item Id</th>
    <th>Quantity</th>
    <th>Price</th>
    <th>Extended Total</th>
</tr>
<tr>
    <td>1</td>
	<td>31</td>
	<td style="text-align:right;">7</td>
	<td style="text-align:right;">$3.80</td>
	<td style="text-align:right;">$26.60</td>
</tr>
<tr>
	<td>2</td>
	<td>17</td>
	<td style="text-align:right;">4</td>
	<td style="text-align:right;">$9.20</td>
	<td style="text-align:right;">$36.80</td>
</tr>
<tr>
	<td>Count: 2</td>
	<td></td>
	<td>Avg Quantity: 5.50</td>
	<td>Avg Price $6.50</td>
	<td style="text-align:right;">Total: $63.40 </td>
</tr>
</table>
<br/>
Order Id: 3 (Order number 3 of 3 orders - for orders placed between <b>1/1/2014</b> and <b>1/5/2014</b>)<br/>
Order Date: 1/5/2014<br/>
<table style="border-collapse: collapse;" border="1" cellpadding="3" cellspacing="1"><tr>
    <th>#</th>
    <th>Item Id</th>
    <th>Quantity</th>
    <th>Price</th>
    <th>Extended Total</th>
</tr>
<tr>
	<td>1</td>
	<td>11</td>
	<td style="text-align:right;">9</td>
	<td style="text-align:right;">$13.30</td>
	<td style="text-align:right;">$119.70</td>
</tr>
<tr>
	<td>2</td>
	<td>27</td>
	<td style="text-align:right;">2</td>
	<td style="text-align:right;">$19.20</td>
	<td style="text-align:right;">$38.40</td>
</tr>
<tr>
	<td>3</td>
	<td>6</td>
	<td style="text-align:right;">19</td>
	<td style="text-align:right;">$3.60</td>
	<td style="text-align:right;">$68.40</td>
</tr>
<tr>
	<td>4</td>
	<td>7</td>
	<td style="text-align:right;">22</td>
	<td style="text-align:right;">$9.10</td>
	<td style="text-align:right;">$200.20</td>
</tr>
<tr>
	<td>Count: 4</td>
	<td></td>
	<td>Avg Quantity: 13.00</td>
	<td>Avg Price $11.30</td>
	<td style="text-align:right;">Total: $426.70 </td>
</tr>
</table>
<br/>
Grand total for all 3 orders is: $593.40<br/>
</div>]]></content>
                </section>
                <section>
                    <description>
                        <p>There is a lot going on in this example. The template for this example is shown below.</p>
                        <p>Items of note in this example include:</p>
                    </description>
                    <cases>
                        <case>
                            <title>Extended Total for All Items</title>
                            <description>
                                <p>While the data for each orderItem does not contain an extendedPrice property, the extended price is shown for each item and it is formatted with a $ and two decimal places.</p>
                                <p>If you look at the template below you will notice that the template for the 'Extended Total' column is defined as:</p>
                            </description><example><![CDATA[{qty*price:number(\'$#,###.00\')}]]></example>
                        </case>
                        <case>
                            <description>
                                <p>The template defines the expression qty * price and then uses the :number() directive to format is with a $ and two decimal places (and a comma for the thousands separator - not shown in the output because none of the extended totals are above $999.99).</p>
                            </description>
                        </case>
                        <case>
                            <title>Order Items in Tables</title>
                            <description>
                                <p>The Order Items are displayed in a table. The <table> HTML tag is output in the {*header} section for the OrderItems array and the </table> HTML tag is output in the {*footer} section for the OrderItems array.</p>
                            </description>
                        </case>
                        <case>
                            <title>Summary Data in Table Footer</title>
                            <description>
                                <p>The footer row for the Order Items table displays the count of the number of items, the average quantity, the average price and the total for the order. All of these summary values are computed in the array pre-processor function (orderItemsPreprocessor). Notice that the tag for the orderItems array {orderItems@orderItemsPreProcessor} specifies the name of the pre-processor function.</p>
                                <p>The array pre-processor function puts these summary values in the special 'temp' variable. The function adds the following properties to the 'temp' variable:</p>
                            </description>
                            <cases>
                                <case>
                                    <description>temp.grandTotal - the grand total for all of the orders</description>
                                </case>
                                <case>
                                    <description>temp.averagePrice - the average price for each order</description>
                                </case>
                                <case>
                                    <description>temp.averageQuantity - the average quantity for each order</description>
                                </case>
                                <case>
                                    <description>temp.totalExtendedPrice - the order total for each order</description>
                                </case>
                                <case>
                                    <description>temp.itemCount - the number of items in each order</description>
                                </case>
                            </cases>
                        </case>
                        <case>
                            <description>
                                <p>In order to output these computed values in the template, the special [temp] variable is used. For example, to show the average price (formatted with $ and two decimal places), the template includes:</p>
                            </description>
                            <example><![CDATA[{[temp].averagePrice:number(\'$#,###.00\')}]]></example>
                        </case>
                        <case>
                            <title>Numbered Rows</title>
                            <description>
                                <p>The rows in the Order Items table are numbered. The special {[countOneBased]} tag is used to number the rows.</p>
                            </description>
                            </case>
                        <case>
                            <title>Order Number and Total Orders</title>
                            <description>
                                <p>Each order specifies the order number and the number of orders (e.g. Order number 2 of 3 orders). The template looks like this:</p>
                            </description>
                            <example><![CDATA[(Order number {[countOneBased]} of {[root].length} orders]]></example>
                        </case>
                        <case>
                            <description>
                                <p>In order to output the order number  (i.e. 1 for the first order, 2 for the 2nd order, etc.), the special {[countOneBased]} tag is used.</p>
                                <p>In order to output the total number of orders, the length property of the special [root] variable is used. Because the data passed into the template expand function is an array, the 'root' object is implicitly created (see section above 'The {*root} Tag ')</p>
                            </description>
                        </case>
                        <case>
                            <title>Order Date</title>
                            <description>
                                <p>Each order also indicates the date for the first order and last order displayed. For example:</p>
                                <p>(Order number 2 of 3 orders - for orders placed between 1/1/2014 and 1/5/2014)</p>
                                <p>The template the date range is:</p>
                            </description>
                            <example><![CDATA[- for orders placed between <b>{[root][0].date}</b> and <b>{[root][-1].date}</b>]]></example>
                        </case>
                        <case>
                            <description>
                                <p>To get the date of the first order the special [root] variable is used with an index of 0. So [root][0] has the data for the first order and [root][0].date is the date for the first order.</p>
                                <p>To get the date for the last order, we again use the special [root] variable, but this time with an index of -1. So [root][-1].date is the date for the last order.</p>
                            </description>
                        </case>
                        <case>
                            <title>Grand Total Template</title>
                            <description>
                                <p>To print the grand total of all of the orders, the template is:</p>
                            </description>
                            <example><![CDATA[Grand total for all {[root].length} orders is: {[temp].grandTotal:number(\'$#,###.00\')}]]></example>
                        </case>
                        <case>
                            <description>
                                <p>The count of the number of orders can be obtained using the length property of the special [root] variable. The grand total of all orders is output using the grandTotal property that was added to the 'temp' variable by the 'orderItems' array pre-processor function. To output a value in the special 'temp' variable, we use [temp].</p>
                                <p>The 'temp' variable is not scoped to each invocation of the array pre-processor function. It it therefore ideal for accumulating aggregate values for all of the data. You will notice that in the pre-processor function, when the first order is processed, the temp.grandTotal variable does not yet exist. It is therefore initialized to 0. Then, the order total for the current order being processed is added into the temp.grandTotal variable.</p>
                            </description>
                        </case>
                    </cases>
                </section>
                <section>
                    <description> Here is the template for this example:</description>
                    <example><![CDATA[var template = [
    '{*root}',
        'Order Id: {orderId} (Order number {[countOneBased]} of {[root].length} orders - for orders placed between <b>{[root][0].date}</b> and <b>{[root][-1].date}</b>) <br>',
        'Order Date: {date}<br>',
        '{orderItems@orderItemsPreProcessor}',
            '{*header}',
                '<table border="1" cellspacing="1" cellpadding="3" style="border-collapse: collapse;" >',
                '<tr>',
                    '<th>#</th>',
                    '<th>Item Id</th>',
                    '<th>Quantity</th>',
                    '<th>Price</th>',
                    '<th>Extended Total</th>',
                '</tr>',
            '{/*header}',
            '<tr>',
                '<td>{[countOneBased]}</td>',
                '<td>{itemId}</td>',

                '<td style="text-align:right;">{qty}</td>',
                '<td style="text-align:right;">{price:number(\'$#,###.00\')}</td>',
                '<td style="text-align:right;">{qty*price:number(\'$#,###.00\')}</td>',
            '</tr>',
            '{*footer}',
                '<tr>',
                    '<td>Count: {[temp].itemCount}</td>',
                    '<td></td>',
                    '<td>Avg Quantity: {[temp].averageQuantity:number(\'#.00\')}</td>',
                    '<td>Avg Price {[temp].averagePrice:number(\'$#,###.00\')}</td>',
                    '<td style="text-align:right;">Total: {[temp].totalExtendedPrice:number(\'$#,###.00\')} </td>',
                '</tr>',
                '</table><br>',
            '{/*footer}',
        '{/orderItems}',
        '{*footer}',
            'Grand total for all {[root].length} orders is: {[temp].grandTotal:number(\'$#,###.00\')}<br>',
        '{/*footer}',
    '{/*root}'
].join('');]]></example>
                </section>
                <section>
                    <description> The array pre-processor function for the 'orderItems' array is defined as follows:</description>
                    <example><![CDATA[ function orderItemsPreProcessor(data,temp,root) {
    var totalQuantity = 0;
    var totalPrice = 0;
    var totalExtendedPrice = 0;
    var extendedPrice = 0;
    var _d = '';
    for(var i = 0; i < data.length; i++) {
        _d = data[i];
        extendedPrice = _d.qty * _d.price;
        totalExtendedPrice = totalExtendedPrice + extendedPrice;
        totalPrice = totalPrice + _d.price;
        totalQuantity = totalQuantity + _d.qty;
    }

    //the first time this function is called temp.grandTotal will be undefined

    //so we initialize it to 0
    if(typeof temp.grandTotal == 'undefined') temp.grandTotal = 0;

 

    //we can then accumulate the grand total for all orders
    temp.grandTotal = temp.grandTotal + totalExtendedPrice;
 

    temp.averagePrice = (totalPrice / data.length);
    temp.averageQuantity = (totalQuantity / data.length);
    temp.totalExtendedPrice = totalExtendedPrice;
    temp.itemCount = data.length;
    //it is CRITICAL that the pre-processor function return an array to be expanded
    //even though this function has not modified the data in the 'data' array,

    //it must still return the 'data' array
    return data;
} ]]></example>
                </section>
                <section>
                    <title>Templates Can Reference Functions in Any Namespace and Can Take Arguments</title>
                    <description>
                        <p>Previously, when a template referenced a function, the function needed to be defined as a global function. Now, templates can reference functions an arbitrary namespaces.</p>
                        <p>Consider the following simple example:</p>
                        <p>Data:</p>
                    </description>
                    <example><![CDATA[var data = [
    {firstname: 'Fred', lastname: 'Smith'},
    {firstname: 'John', lastname: 'Jones'}
]]]></example>
                </section>
                <section>
                    <description>
                        <p>Javascript function definition (Notice that the function takes two arguments and is in the 'obj' namespace.):</p>
                    </description>
                    <example><![CDATA[var obj = {
    fullname: function(fn,ln) { return 'Hello <b>' + fn + ' ' + ln + '</b>'}
}]]></example>
                </section>
                <section>
                    <description>Template (Notice that the template calls the function in the 'obj' namespace and passes in argument values from the current row.):</description>
                    <example><![CDATA[var template = '{firstname} {lastname} Function call is output here: {@obj.fullname(firstname,lastname)}<br>']]></example>
                </section>
                <section>
                    <description>The output HTML produced is:</description>
                </section>
                <section>
                    <content><![CDATA[<div>
Fred Smith Function call is output here: Hello <b>Fred Smith</b><br/>
John Jones Function call is output here: Hello <b>John Jones</b><br/>
</div>]]></content>
                </section>
                <section>
                    <title>Defining Custom Formatters</title>
                    <description> Templates can format data before it is output using the built-in format directives. For example, you can format a number so that it has $ and two decimal places by using the :number() format directive. For example:</description>
                    <example><![CDATA[ {price:number(\'$#,###.00\')}]]></example>
                </section>
                <section>
                    <description>
                        <p>However, you can also define your own custom format directives. This is done by adding functions to the A5.u.template.formats object.</p>
                        <p>Consider the following example:</p>
                        <p>Data:</p>
                    </description>
                    <example><![CDATA[ var data = {
    company: [
        {firstname: 'Fred', lastname: 'Smith', phone: 7815551234},
        {firstname: 'John', lastname: 'Jones', phone: 2125551234},
        {firstname: 'Jane', lastname: 'Jones', phone: 4155551234},
        {firstname: 'Margo', lastname: 'Jones', phone: 4325551234}
    ]
}]]></example>
                </section>
                <section>
                    <description>Template:</description>
                    <example><![CDATA[ var template = [
    '{company}',
    '{firstname:formatName(\'l\')} {lastname:formatName(\'u\')} {phone:phoneNumber}<br>',
    '{/company}'

].join('');]]></example>
                </section>
                <section>
                    <description>
                        <p>Notice the template uses custom formatters for the each of the fields. Both 'firstname' and 'lastname' use a custom formatter called 'formatName' and in one case an argument value of 'l' is passed in (to format the data as lower case) and in the second case, an argument value of 'u' is passed in (to format the data as upper case).</p>
                        <p>The 'phone' field uses a custom formatter called 'phoneNumber'. This formatter does not take any arguments.</p>
                        <p>To define these two custom formatters, the following Javascript is used to add the format functions to the A5.u.template.formats object:</p>
                    </description>
                    <example><![CDATA[ A5.u.template.formats.formatName = function(value,flag) {
    if(flag == 'u') return value.toUpperCase();
    else if(flag == 'l') return value.toLowerCase();
    else return value;
}

A5.u.template.formats.phoneNumber = function(value) {
    return value.toFormat('=(###)-###-#####');
}]]></example>
                </section>
                <section>
                    <description>Notice that the custom format functions all get passed 'value' - the value to be formatted.</description>
                </section>
                <section>
                    <title>Arguments Passed to Template Functions</title>
                    <description>
                        <p>If a template function does not explicitly specify arguments, the implicit arguments passed to the function now include the special 'temp' and 'root' variables.</p>
                        <p>For example, consider the following template snippet:</p>
                    </description>
                    <example><![CDATA[{@myCustomFunction}]]></example>
                </section>
                <section>
                    <description>This template function does not specify any arguments. Therefore the 'implicit' arguments for the function called are:</description>
                    <cases>
                        <case>
                            <description>data</description>
                        </case>
                        <case>
                            <description>context</description>
                        </case>
                        <case>
                            <description>temp</description>
                        </case>
                        <case>
                            <description>root</description>
                        </case>
                    </cases>
                </section>
                <section>
                    <description>
                        <p>Previously, only 'data' and 'context' were passed to the function.</p>
                        <p>Where context is a string with the name of the variable that the function was being called in the context of. For example, in a {*header} or {*footer} directive for an array called 'company' the 'context' would be 'company'. However in an individual item in the company array, the context would be blank (as the context is implicit). </p>
                    </description>
                </section>
            </sections>
        </group>
        <group>
            <title>New Features Added in Alpha Anywhere Build 3826</title>
            <sections>
                <section>
                    <title>Comments</title>
                    <description>Comments can be added to client-side templates using the *[js:{/* ... */}]* directive.</description>
                    <example>{/* this is a comment */}</example>
                    <note>Comments must have white space after the first "*" and before the last "*".</note>
                </section>
                <section>
                    <description>
                        <p> When the template is expanded, any space taken by comments is ignored. Comments are useful for the obvious use case of adding explanations to your templates.</p>
                        <p>But another less obvious use case for comments is to make templates more readable. For example, in certain cases your templates should not include any line breaks because the space taken by the line break will affect how the expanded template appears. However, this makes the template difficult to read. In the example below, an empty comment that spans two lines is used to insert a line break into the template for readability. This line break is ignored, however, when the template is expanded.</p>
                    </description>
                    <example><![CDATA[{/* this is the firstname field */}
<div class="item">{/*
*/}<div class="label">Firstname</div>{/*
*/}<div class="field">{firstname}</div>{/*
*/}</div>]]></example>
                </section>
                <section>
                    <title>Arbitrary iterator</title>
                    <description>The arbitrary iterator allows you to iterate over dynamically created data.</description>
                    <example><![CDATA[{*@functionName}
...
{/*}]]></example>
                </section>
                <section>
                    <description>The iterator is useful for inserting external data into the template when it is expanded.</description>
                    <example><![CDATA[{orders}
{id} {total} {date}<br />
{*if !delivered}
{*@tracking}
{location} at {date}
{/*}
{*endif}
{/orders}]]></example>
                </section>
                <section>
                    <description>Where tracking is a Javascript function that might be defined as follows:</description>
                    <example><![CDATA[function tracking(data,temp,root,parent,path){
    /*
    data is the current parent data context - in this case the current order
    assume code here that goes to a separately stored tracking array and
    returns an array of locations and dates
    */

    return [
        {location: 'Boston MA', date: '9/4/2016'},
        {location: 'Albany NY', date: '9/5/2016'}
    ];
}]]></example>
                </section>
                <section>
                    <title>Escape</title>
                    <description>You can escape long strings of template characters using the escape directive:</description>
                    <example><![CDATA[<escape<{some template code'}>>]]></example>
                </section>
                <section>
                    <description>In some cases you need to include special functions in a template (such as A5.map.staticMap() - a function that generates a static HTML map). The function call may include characters such as a colon, which must be escaped because they have special meaning in a template.</description>
                    <example><![CDATA[{A5.map.staticMap(<escape<{
width: 400,
height: 300,
center: 'Boston MA'
}>>)}]]></example>
                </section>
                <section>
                    <description>Before the escape directive was available, this above template would have had to be written as:</description>
                    <example><![CDATA[{A5.map.staticMap(\{width\: 400,height\: 300,center\: 'Boston MA'\})}]]></example>
                </section>
                <section>
                    <title>Ensure</title>
                    <description>The ensure directive allows you to ensure certain properties exist in the Data.</description>
                    <example><![CDATA[{*ensure a,b,c}]]></example>
                </section>
                <section>
                    <description>
                        <p>Where *[js:a]*, *[js:b]* and *[js:c]* are data variables that you want to define so that if they are referenced in an *[js:{*if}]* block, the *[js:{*if}]* block will evaluate correctly.</p>
                        <p>For example, assume the data passsed to a template is:</p>
                    </description>
                    <example><![CDATA[{bar: 'world'}]]></example>
                </section>
                <section>
                    <description>And the template is defined as:</description>
                    <example><![CDATA[{*if foo == 'hello'}
...
{*elseif bar == 'world'}
...
{*else}
...
{*endif}]]></example>
                </section>
                <section>
                    <description>
                        <p>Without *[js:{*ensure foo}]*, the *[js:{*if}]* block will not execute correctly,  as *[js:foo]* doesn't exist.</p>
                        <p>Here is how the template could be rewritten to ensure that it works as expected:</p>
                    </description>
                    <example><![CDATA[{*ensure foo}
{*if foo == 'hello'}
...
{*elseif bar == 'world'}
...
{*else}
...
{*endif}]]></example>
                </section>
                <section>
                    <title>Defined/Undefined</title>
                    <description>
                        <p>The defined and undefined directives provde a shorthand syntax for checking if a list of variables are or are not defined.</p>
                        <p> It is common in the logical expressions in a *[js:{*if}]* block to check that certain variables are defined or undefined. The code to do this can be cumbersome and the *[js:<![CDATA[<defined<variableList>>]]>]* and *[js:<![CDATA[<undefined<variableList>>]]>]* directives make your template more readable.</p>
                        <p>For example, imagine you had the following template:</p>
                    </description>
                    <example><![CDATA[ {*if typeof variableName1 == 'undefined' || typeof variableName2 == 'undefined'}
...
{*endif}]]></example>
                </section>
                <section>
                    <description> The syntax in the template is cumbersome and can be simplified as:</description>
                    <example><![CDATA[ {*if <undefined<variableName1,variableName1>>}
...
{*endif}]]></example>
                </section>
                <section>
                    <description> Similarly, an expression that tests if variables are all defined might previously have been written as:</description>
                    <example><![CDATA[ {*if typeof variableName1 != 'undefined' && typeof variableName2 != 'undefined'}
...
{*endif}]]></example>
                </section>
                <section>
                    <description> can now be written as</description>
                    <example><![CDATA[{*if <defined<variableName1,variableName2>>}
...
{*endif}]]></example>
                </section>
                <section>
                    <title>Expression Escapement</title>
                    <description>
                        <p>The ":" and "|" characters have special meaning in a template. If they are used in an expression, they must be escaped.</p>
                        <p>If a logical expression in an immediate if expression is enclosed in *[js:( ... )]*, the special *[js::]* and *[js:|]* characters do not need to be escaped.</p>
                    </description>
                    <note>The *[js::]* character in a template is how a formatter is defined and the *[js:||]* character sequence is used to define default text for null values.</note>
                </section>
                <section>
                    <description>For example consider the following template code:</description>
                    <example><![CDATA[{a ? b \: c:uppercase}]]></example>
                </section>
                <section>
                    <description>
                        <p>If *[js:a]* is true, then the expression will return *[js:b]*. However, if *[js:a]* is false, the expression will return *[js:c]*. The result of the expression *[js:a ? b \: c]* will then be converted to uppercase (expressed as *[js::uppercase]*.)</p>
                        <p>The above template can now be rewritten as:</p>
                    </description>
                    <example><![CDATA[{(a ? b : c):uppercase}]]></example>
                </section>
                <section>
                    <description>Expression escapement is not limited to logical expressions. For example, the following template expression concatenates strings, one of which is a string containing a *[js::]* character.</description>
                    <example><![CDATA[{(a + ':' + b):uppercase}]]></example>
                </section>
            </sections>
        </group>
    </groups>
</page>