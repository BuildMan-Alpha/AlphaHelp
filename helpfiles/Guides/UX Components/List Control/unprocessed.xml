
h2 (already converted to title) - group
h3 - section
h4 - case or step




<h3>Persisting Variables</h3>
<description>
    <p>Variables are persisted whenever a 'trigger' event occurs. For some controls (e.g. Radiobutton,. Checkbox, Slider, etc.), the 'trigger' is when the value in the control is changed. For textbox and textarea controls, the 'trigger' is when the control is blurred (i.e. loses focus) and the value in
    the field has changed.</p>
    <p>You can also manually trigger the event by calling the UX component's {dialog.object}.persistVariablesToLocalStorage() method.</p>
    <p>When variables are persisted to Local Storage various client-side events are fired. </p>
    <p>The onBeforePersistControlValuesToLocalStorage event fires first. This event fires before the variables are persisted. Its purpose is to allow you to specify any additional data that you want to persist along with the variable values. Your code can set the e.userData property. Thevalue you set in this property will be available when the onRestoreVariablesFromLocalStorage fires.</p>
    <p>The localStorageEncryption event fires next. The event allows you to add your own encrypting to the JSON data that is about to be stored to Local Storage. The event handler gets the JSON data in the e.data property and the event handler can set e.data to the encrypted string.</p>
    <p>When the component is loaded if the 'Restore variables from Local Storage' setting is true (see [Local Storage Settings] below), then the previously persisted variable values (if any) will be restored.</p>
    <p>The onRestoreVariablesFromLocalStorage event will fire after the data has been restored. This event handler can access the e.userData property which was optionally defined when the onBeforePersistControlValuesToLocalStorage event was fired.</p>
    <p>If the 'Restore variables from Local Storage' property is set of false, you can still manually restore persisted variables by calling the UX component's {dialog.object}._restoreVariablesFromLocalStorage() method.</p>
</description>

<h3>Local Storage Settings</h3>

<p>You can control what gets persisted to Local Storage by setting 
properties in the UX component as shown below.</p>

<figure><link>images/LOCALSTORAGE_PROPS2.gif</link></figure>

<ul>
<li>Namespace - In order to manage the keys in Local Storage, you specify a 'namespace'. All keys for this component will use the namespace as a prefix. If you specify <Default> or leave the namespace blank, a system generated namespace will be used. In addition to the namespace specified here, all keys will also include 'ALPHA_' in the namespace. This allows for easy identification of keys in Local Storage that are tied to any UX application. For example, if you set the 'namespace' property to 'orderApp', the key that stores the data for a List called 'Orders' will be 'ALPHA_orderAPP.LIST.ORDERS'. <br>
<br>
You can specify an optional 'friendly name' and 'description' for the namespace. The friendly name, description, version and a datestamp are automatically persisted to a key called 'ALPHA_namespace._INFO' any time any UX data are persisted to Local Storage.</li>
<li>Persist variable values - Check this property to persist to Local Storage the value of all variables on the UX. (A 'variable' is associated with each data entry control on the UX. For example, a textbox, radiobutton, checkbox, slider, etc. all have an associated 'variable' that contains the current 'value' for the control.)</li>
<li>Persist component state - (Not currently implemented) Stores in Local Storage information such as what Panel in a Panel Navigator currently has focus, what Panels in a Panel Layout are currently visible, etc.</li>
<li>Working Preview testing mode - When you are in Working Preview you can specify that the local file system on your computer should be used for storing data that would otherwise be put in the browser's Local Storage. The benefit of this is to allow you to easily see what's being stored in Local Storage because you can simply examine the contents of the files in the specified folder on your computer.</li>
</ul>
<note> Using the 'Filesystem' option for Local Storage is significantly slower than using the browser Local Storage.</p>
<ul>
<li>
Restore variables from Local Storage - If this property is checked, then when the component is re-loaded, any variable whose value was persisted to Local Storage will be restored. </li>
<li>Restore data in List controls from Local Storage - If this property is checked the data in the List controls are restored when the component is reloaded. (Only the Lists that you indicated should be persisted to Local Storage are restored. Each List has its own setting to indicate if it is persistable. See below for more information.)</li>
</ul>


<title>Managing Local Storage</title>
<p>Local Storage is a shared resource and it is limited. The exact 
limitation is a function of your device. In order to free up storage space 
for an application on a device, it might be necessary to delete storage 
being used by some other application that you are no longer using.</p>
<p>You can add a pre-defined control to your UX to manage Local Storage. 
This control is primarily intended for use by developers while they are 
designing the application. It is not ideal for the users of your 
application.</p>
<p>To insert the 'Local Storage Manager' into your component, select the 
control from the 'Defined Controls' section in the UX toolbox.</p>

<figure><link>images/localstoragemgr1.jpg</link></figure>


<p>
<br>
This will insert a List control into the component that will allow you to see 
all of the keys in Local Storage, the keys for this component (i.e. app), all 
keys (excluding keys for this app), etc. You can see how much space each key is 
consuming and you can peek at the data in the key. You can also delete keys.</p>
<p>
</p>
<p>
The image below is showing the keys in Local Storage for an component where the 
'Namespace' property has been set to 'app1'</p>
<p>
</p>
<p>
<figure><link>images/localstoragemgr2.gif</link></figure>

<p>If you tap on the Show button you can see up to the first 1,000 bytes of data 
in the key:</p>
<figure><link>images/localstoragemgr3.jpg</link></figure>

<h3>Methods for Managing Local Storage</h3>
<p>The UX component has several methods that make it easy for developers to add 
functionality to their components to manage the data in Local Storage.</p>
<note> These methods cannot be used in Working Preview if
you have configured your component to use the file system for Local Storage.</p>
<p>The {dialog.object}._ls_getData() 
function returns an object with information about the keys stored in Local 
Storage.  The method takes a flag to indicate which keys in Local Storage 
to return information on.</p>
<p>The object that is returned has these properties</p>
<ul>
<li>data - an array with information about each key found. The array 
has an object for each key found. The object has a key and size 
property indicating the key name of the item and the size in bytes of the 
item.</li>
<li>size - the total size in bytes of all keys found</li>
<li>keyCount - the number of keys that were found.</li>
</ul>
<p>Example:</p>

<p>//pass in the 'a' flag to get info on All keys</p>
<p>var obj = {dialog.object}._ls_getData('a')</p>
<p>console.log('Number of keys: ' + obj.keyCount);</p>
<p>console.log('Number of bytes: ' + obj.size);</p>
<p>var data = JSON.stringify(obj.data);</p>
<p>console.log('Data: ' + data);</p>

<p>The following flags can be used:</p>

<table>



<tr>
<td>
Flag</td>
<td>
Meaning</td>
</tr>



<tr>
<td>
a</td>
<td>
All keys in Local Storage </td>
</tr>



<tr>
<td>
aa</td>
<td>
All keys created by UX components. Keys that are
added to Local Storage all have 'ALPHA_' as a
prefix. Only keys that have this prefix are
returned.</td>
</tr>



<tr>
<td>
t</td>
<td>
All keys for this UX component. These
keys all start with 'ALPHA_' followed by the
namespace for the component (e.g. ALPHA_NS1).
<br>
NOTE: The namespace for the component is
specified in the UX component properties - Local
Storage section.</td>
</tr>



<tr>
<td>
o</td>
<td>
All other keys  (i.e.excluding keys
for this UX component). (Same as using the 'a'
flag, then removing keys returned for the 't'
flag).</td>
</tr>



<tr>
<td>
oa</td>
<td>
All UX component keys, but excluding keys for
this component. (Same as using the 'aa' flag,
then removing keys returned for the 't' flag).</td>
</tr>



<tr>
<td>
</td>
<td>
</td>
</tr>



<tr>
<td>
v:t</td>
<td>
Key used to persist variables for this UX
component.<br>
NOTE: The UX component allows you to
specify that variables in a component should be
persisted to Local Storage (See Local Storage
section in UX properties).</td>
</tr>



<tr>
<td>
v:a</td>
<td>
All UX component keys that store persisted
variables (for any UX component, not just this
component). </td>
</tr>



<tr>
<td>
v:o</td>
<td>
All UX components keys that store persisted
variables, excluding this UX component
(Same as using 'va' and then removing 'vt').</td>
</tr>



<tr>
<td>
</td>
<td>
</td>
</tr>



<tr>
<td>
lists:t</td>
<td>
All of the List components in this component
that are persisted to Local Storage.<br>
NOTE: Not every List in a UX component is
persisted to Local Storage. Each List in a UX
has its own setting (defined in the List
Builder) to control whether it is persisted.</td>
</tr>



<tr>
<td>
lists:a</td>
<td>
All of the List components (from any UX
component) that are persisted to Local Storage.</td>
</tr>



<tr>
<td>
lists:o</td>
<td>
All of the List components, excluding the Lists
in this component. (Same as using 'lists:a'
and then removing 'lists:t')</td>
</tr>



<tr>
<td>
</td>
<td>
</td>
</tr>



</table>


<p>Once you have retried the array of information using the
{dialog.object}._ls_getData() method, you might want to delete the keys
listed in the array. You can pass in the object returned by the
{dialog.object}._ls_getData()
method to the {dialog.object}._ls_deleteKeys()
method.</p>
<p>For example:</p>
<p>            </p>
<p>//delete all keys in local storage for other UX components</p>
<p>var obj = {dialog.object}._ls_getData('o');</p>
<p>{dialog.object}._ls_deleteKeys(obj);</p>


<p>Namepsace Information Key</p>
<p>Each UX component that persists data to Local Storage automatically stores a
key in Local Storage with information about the UX component every time the UX
component persists data to Local Storage.</p>
<p>The special key is name:</p>
<p>ALPHA_<your component namespace>._INFO</p>
<p>The data in the key contains these properties:</p>
<ul>
<li>lastUsed - the last date that information for this namespace was
written to Local Storage. This will allow you to write routines that delete
keys for infrequently used applications.</li>
<li>friendlyName - the component 'friendly name' - specified in the
UX builder - Local Storage section.</li>
<li>description - the component 'description' - specified in the UX
builder - Local Storage section.</li>
<li>version - the component 'version' - specified in the UX builder -
Local Storage section.</li>
</ul>

<p>For example, here is some data that might be stored in the ._INFO key for a
particular UX component:</p>

<p>{<br>
"lastUsed": "2014-07-26T14:27:41.122Z",<br>
"friendlyName": "Expense Reporting",<br>
"description": "An application to capture expenses.",<br>
"version": 1<br>
}</p>

<title>Client-side Events</title>
<h3>Client-side Events for Lists with a Detail View</h3>
<p>If a List has a Detail View, there are a large number of client-side events
that are exposed.</p>
<p>To define these client-side events, click the smart field for the Events
property (on the Detail View pane in the List Builder) to open a builder for
client-side List Detail View events. <br>
</p>
<figure><link>images/client_side_dv_events_smartfield.jpg</link></figure>
<p>The builder shows all of the client-side events for Lists with Detail Views.</p>

<figure><link>images/list_dv_props6.jpg</link></figure>

<p>The key client-side events are summarized below:</p>

<ul>
<li>canUpdateList - Fires when the user tries to update the List with
edits that have been ade to the List Detail View. If function returns false,
action is cancelled. The data object is passed in as a member of the e
object. If you set properties in e.data, you can overrride the values that
the user entered.</li>
<li>canSynchronizeList - Fires when the user tries to synchronize the
data in the List (by making an Ajax callback). If function returns false,
action is cancelled. The data object is passed in as a member of the e
object. If you set properties in e.data, you can override the values from
the List that will be submitted to the server. You can prevent the data in a
particular row in the List from being synchronized by setting the ._isDirty
property of the row data to false. For example to prevent the data in row 2
(zero based) from being synchronized, use this code:<br>
<br>
e.data[2]._isDirty = false;<br>
<br>
The data passed into the e object 
includes batchSize, totalDirtyRows and startingRow. If
all data is not being submitted in batches, batchSize is 0. To test
if this is the first batch in a job test for batchSize > 0 and 
startingRow = 1<br>
</li>
</ul>

<ul>
<li>afterSynchronizeList - Fires after the data in the List has been
synchronized. Data passed into the event handler includes: hasErrors,
recordsWithErrors, recordsSubmitted, recordsUpdate, recordsInserted,
recordsDeleted, recordsWithServerSideValidationErrors,
recordsWithWriteConflictErrors, recordsWithDatabaseErrors,l istId</li>
<li>afterRefreshListIncremental - Fires after an incremental refresh
is performed on a List (to retrieve records from the server that were
added/updated/deleted after the List control was initially populated). Data
passed into the event handler includes: rowsUpdated, rowsInserted,
rowsDeleted,l istId.</li>
<li>canResetRow - Fires when the user tries to undo edits to a row of
data in the List. If function returns false, action is cancelled.</li>
<li>canUndoEdits - Fires when the user tries to undo edits to the
List Detail View form. If function returns false, action is cancelled.</li>
<li>afterResetRow - Fires after the user has undone edits to a row of
data in the List.</li>
<li>afterUndoEdits - Fires after the user has undone edits to the
List Detail View.</li>
<li>canNewRecord - Fires when the user tries to go to a new Detail
View record. If function returns false, action is cancelled.</li>
<li>afterNewRecord - Fires after the new record has been displayed in
the DetailView form</li>
<li>afterListRowSelectCancelled - Fires when user tries to select a
new row in a List and the action is cancelled because the Detail View for
the current List, or any child List, is dirty.  If your event
handler sets e.handled = true, the system message will be suppressed. A
typical use for this event is to give focus to the dirty Detail View. For
example, say you have hierarchical data with customers, orders and
orderDetails. If the user has edited the Detail View for the orderDetail
list and then clicks on a different row in the customer List, the action
will be cancelled and this event will fire. If the Detail View for the
orderDetail List is in another Panel, this event can give focus to the Panel
so that the user can save the dirty Detail View record.</li>
<li>afterSynchronizeListBatch - If the List is being synchronized in
batches, fires when a batch is completed. If the function returns false, the
next batch (if any) will not be sent. The data in the e object that is
passed in will allow you to create your own progress counter. The e object
includes these properties: totalDirtyRows, batchSize, 
startingRow and pctComplete. NOTE: If you want to execute code at
the start of the batched job, see the canListSynchronize event.</li>
<li>beforeSynchronizeListBatchStart  - If the List is being
synchronized in batches, fires before the first batch is send to the server.</li>
<li>afterSynchronizeListBatchEnd  - If the List is being
synchronized in batches, fires after the last batch in the job has
completed.</li>
<li>canCancelBatch - If the List is being synchronized in batches,
fires if the user clicks the 'Cancel' button to stop sending batches of
records to the server to synchronize. If the function returns false, then
the synchronization is not cancelled.</li>
<li>afterCancelBatch - If the List is being synchronized in batches,
fires after the user has clicked the 'Cancel' button to stop sending batches
of records to the server to synchronize.</li>
<li>modeChanged - Fires when the List mode changes. Modes are
'enter', 'edit' and 'search'. 'search' applies only if the List has a Search
Part and the Search Part is set to QueryByForm mode.</li>
</ul>

<p>The following two events are defined in Fields pane of the List Builder
(because the events are defined at the individual field level):</p>
<p>
</p>
<ul>
<li>
onDetailView Populate Javascript</li>
<li>
onListUpdate Javascript</li>
</ul>
<p>
These properties allow you to transform the data before
it is displayed in the Detail View and before the Detail
View is saved back to the List. The code you you specify
in these two properties must 'return' the transformed
value. For example:
return
this._value.toUpperCase()</p>
<p>
The Javascript for both of these properties can refer to</p>
<p>
this._value</p>
<p>
</p>
<p>
to get the default value that the Detail View control
should be populated with when the user clicks on a
Detail View row and to get the default value that the
List should be updated with when the user clicks the
Save button to save the Detail View back to the List.</p>
<p>
</p>

<h3>Client-side Events for Lists with a Search Part</h3>
<p>The following client-side events are specific to Lists with a Search Part.
These events are defined on the 'List Properties' pane in the List builder (by
clicking the 'More events...' property)</p>

<ul>
<li>afterSearchComplete - Fires after the user submits the List's
Search Part to execute a search of the records in the List. The 'searchMode'
parameter is either 'search ' or 'clear' - user cleared existing Search Part
filter. 'searchWhere' indicates where the search will be performed.
It is either 'clientSide', or 'serverSide'</li>
<li>beforeSearch - Fires before the user submits the List's Search
Part to execute a search of the records in the List. The 'searchMode'
parameter is either 'search ' or 'clear' - user cleared existing Search Part
filter. 'searchWhere' indicates where the search will be performed. It is
either 'clientside', or 'serverside'. The 'listIsDirty' property indicates
if the List is dirty (has unsynchronized edits). If the 'listIsDirty'
property is true and the 'searchWhere' property is true, you can display a
message telling the user that server-side searches are not permitted. If
your event returns false, the system error message will then be suppressed.</li>
<li>onSearchResultTooLarge - Typically used in mobile applications
when you want to ensure that the user is not trying to retrieve too much
data from the server. Fires if the user executes a server-side search that
returns too many records. Allows you to display UI telling the user to enter
more restrictive search criteria. The maximum allowed search size is set in
the List builder, but can be overwritten by properties set in the <listObject>.searchList()
method.</li>
<li>onSearchResultTooLargeForLocalStorage - If the List is set to
persist to Local Storage this event will fire if the user peformed a
server-side search that retrieved more records than could be stored in Local
Storage. You can use this event to instruct the user to enter more
restictive search criteria.</li>
</ul>
<h3>Client-side Events for Lists that Persist Data to Local Storage</h3>
<p>The following client-side events are specific to Lists that have been set to
store their data to Local Storage. These events are defined on the 'List
Properties' pane in the List builder (by clicking the 'More events...' property)</p>
<ul>
<li>onBeforePersistToLocalStorage - Fires before the List is
persisted to Local Storage. You can optionally set the e.userData property
to any object and the data in e.userData will be persisted along with the
List data. </li>
<li>onPersistToLocalStorage - Fires after the List is persisted to
Local Storage. The 'success' parameter (logical value - true/false)
indicates if the data was successfully saved to Local Storage, or not. The
'mode' parameter indicates what List action (e.g. 'populate', 'append', 'udate',
etc.) triggered the event.</li>
<li>onRestoreFromLocalStorage - Fires after the List data has been
restored from Local Storage. The e.userData property contains any data that
was set in the onBeforePersistToLocalStorage event. </li>
</ul>




<title>Client-side Expressions</title>
<p>There are several system fields that can be used in client-side expressions
(show/hide, enable, etc.)
For example</p>
<p>dialog.listDetailView.LIST1.mode = 'enter'</p>
<p>The 'mode' system field can be 'enter', 'edit' or 'search'.</p>
<p>In the above example, 'LIST1' is the name (i.e. variablename) for the List.</p>
<p>Other system fields specific to Lists with a Detail View or Search Part are:</p>

<table>



<tr>
<td>
Name</td>
<td>
Description</td>
</tr>



<tr>
<td>

dialog.listDetailView.SPECIFY_LIST_NAME.isDirty</td>
<td>
Indicates whether any field in the List's Detail
View has been edited. After the edits in the
current List row are saved back to the List,
this flag will be reset to false.</td>
</tr>



<tr>
<td>

dialog.listRow.SPECIFY_LIST_NAME.isDirty</td>
<td>
Indicates if the current row in the List has
been edited. This flag is set to true after
edits in a Detail View have been saved back to
the List.</td>
</tr>



<tr>
<td>

dialog.list.SPECIFY_LIST_NAME.isDirty</td>
<td>
Indicates if any row in the List has been
edited. When this flag is true, it indicates
that the List has data that needs to be
synchronized.</td>
</tr>



<tr>
<td>

dialog.hasDirtyLists</td>
<td>
Indicates if the UX component has any Lists that
have been edited. When this flag is true, it
indicates that the UX has one or more Lists with
data that needs to be synchronized.</td>
</tr>



<tr>
<td>

dialog.listDetailView.SPECIFY_LIST_NAME.mode</td>
<td>
Indicates the Detail View mode. Can be 'enter' -
entering a new record, 'edit' - editing an
existing record, or 'search' - (Only applies if
the List has a Search Part which has been
configured as 'Query by Form') indicates that
the Detail View is being used to enter search
criteria rather than editing field values.</td>
</tr>



</table>
<p><br>
</p>

<title>Deleting Records</title>
<p>When records are delete in a List's Detail View, the record is initially
simply marked as deleted. It is not physically deleted until the List is
synchronized. At any time before the List is synchronized you can undelete the
record by calling the List object's .resetRow()
method.</p>
<p>Two types of 'deletes' are supported - 'hard' and 'soft'. A 'hard' delete
will physically delete the record from the database. A 'soft' delete will simply
set the value is a special field to 1 to indicate that the record has been
'deleted' (actually it would be more accurate to say that the record has been
'marked as deleted').</p>
<p>When you configure the Table Properties for the Detail View, you can specify
if you want to perform 'hard' or 'soft' deletes.</p>
<p>A common use case for 'soft' deletes is when working with a tables that have
relationships. For example consider a database that has tables for 'customers',
'orders' and 'orderDetails'. If you attempt to delete a customer record without
first deleting all orders for that customer, the delete will fail (assuming the
database has been configured with foreign keys).  Rather
than having to worry about implementing logic to first delete all customer
orders, it is simpler to just set a flag field in the customer record.</p>
<p>When the List is displayed, it will automatically filter our records that
have been marked as deleted.</p>


<title>Contrasting Defining Data Binding for a UX with Lists/Detail View</title>
<p>Prior to this version of Alpha Anywhere, when you wanted to perform CRUD
(create, read, update, delete) operations on a SQL database you would typically
set the Data Binding properties of the UX (as shown in the image below). </p>
<p>Setting the Data Binding properties for a UX involved specifying which table
or tables the UX was 'bound' to, and then mapping control on the UX to fields in
the bound tables.</p>
<p>Having done that you would then define a Save Submitted Data to Table(s)
action in the UX's AfterDialogValidate
server-side event. (See image below). You would also (optionally) define a Load
Primary Keys for Parent Table action in the
onDialogInitialize event.</p>

<figure><link>images/databindingUXLevel.jpg</link></figure>


<figure><link>images/server-side_actions_saverecord.jpg</link></figure>

<p>Alternatively, you could use Action Javascript actions to perform CRUD
operations on 'unbound' tables. These action (shown below) can be thought of as
using 'ad-hoc' data binding.</p>
<figure><link>images/unboundcrudactions.jpg</link></figure>

<p>A List with an updateable Detail View also allows you to perform CRUD
operations against a SQL database, and therefore represents an alternative
to the above techniques. </p>
<note>It is possible to continue to use Data Binding
along with Lists with updateable Detail Views.</p>

<p>If you define Data Binding using the Data Binding pane in the UX builder (see
image at top of section), you are said to be defining the data binding at the 'UX
level'. When you define the data binding at the UX level your UX can only perform CRUD
actions against a single set of linked tables (i.e. the tables that the UX is
data bound to).</p>
<p>However, if you use Lists with Detail View to perform your CRUD actions, then
you can update multiple independent sets of tables. That's because you can have
multiple Lists on the UX, each with its own 'data binding' definition (i.e. the
data binding is done at the 'List' level)</p>
<p>Choosing whether to create a UX that does CRUD operations against a SQL
database by defining data binding at the UX level, or by creating a List with an
updateable Detail View is a matter of personal preference. Both methods have
their advantages.</p>
<p>However, if you want to build an application that can be used while
disconnected, then you must use the List with Detail View method.</p>

<title>Configuring a List Control for Disconnected Applications</title>
<p>When you are building an application for disconnected usage there are certain
List control properties that must be carefully considered. These are:</p>

<p>Pagination - The 'pagination' option for the List should not be
checked. With pagination turned on, you only load one 'page' of data into the
List at a time. You then go back to the server each time a new 'page' of data is
requested. Since the application is designed for disconnected usage, you will
not be able to go back to the server to get more data. </p>
<p>For a disconnected application, you want to load all of the 'relevant data'
into the List while you have a connection (i.e. before you go offline).
If all of the 'relevant' data turns out to be a large number of rows, then you
will want to turn on the 'list virtualization' feature to improve the List
performance (see below). </p>
<p>You can add a Search Part to the List to allow the user to search for the
'relevant data' that they want to have available when they are disconnected (see
below).</p>

<p>List virtualization - If your List has a large number of rows in it,
turn on virtualization (on the List Properties pane in the List Builder). With
List virtualization, the List performance is substantially improved because only
a subset of the List rows are rendered.</p>

<figure><link>images/listvirtualizationsetting.gif</link></figure>

<p>Search Part - By adding a Search Part to the List and checking the
'Delay populate till active search' property, you allow the user to search for
'relevant' data while they have a connection (i.e. before they go offline). 
</p>
<p>If the user enters search criteria that are not sufficiently restrictive and
tries to load too much data into a List your application should display an error
and inform the user to enter more restrictive search criteria. See 
<link href="Setting Search Result Maximums">Setting
Search Result Maximums</link> for information on how to specify the maximum search
size and what events can be used to display  feedback to the user should
they try to load too many records onto their mobile device.</p>


<title>Miscellaneous Topics</title>


<h3>Preventing Duplicate Synchronization Commands</h3>


<p>When you are working
with disconnected data in a List control there is a small possibility of
a synchronization request being submitted to the server more than once -
resulting in the possibility of duplicate records in the database.</p>
<p>To understand how this might happen, consider what happens when the
user clicks the 'Synchronize' button on a device to synchronize edits
that were made while offline.</p>
<ol>
<li>
A JSON packet containing all of the edits that were made to the List
(including any child Lists) is sent to the server.</li>
<li>
The server processes the updates.</li>
<li>
After the server has completed processing the updates, the server
sends a response back to the client indicating which rows were
successfully synchronized and which rows have errors. This response
will set the 'dirty' state of each row in the List that had been
edited back to 'clean'.</li>
</ol>
<p>Obviously, in order for the server to receive the synchronization
request, the user must have a connection. But suppose that AFTER
the user sends a synchronization request to the server, but BEFORE
the server completes the work and can send a response back to the client
looses connectivity.</p>
<p>The server will continue processing the updates to the server and
will do all of the synchronization requests contained in the package
sent from the client. The server does not know that the client is now
offline and so, after it completes all of the work, it will send a
response to client indicating which rows were successfully synchronized.
However, since the client is now offline, the client will not receive
this message from the server. This means that all of the rows on the
client that were edited are still marked as 'dirty' (even though the
server has successfully applied all of the edits).</p>
<p>Now assume that the client gets its connection back and the user
clicks the 'Synchronize' button again. The client will send a JSON
package to the server and this package will include all of the updates
that were previously sent to the server.</p>
<p>In order to protect against this possibility, a special server-side
log can be used to prevent synchronization commands from being executed
more than once.</p>
<p>In order to turn on the server-side synchronization log, edit the
List control and on the Detail View pane, check the
Use server-side synchronization
log table property.</p>


<figure><link>images/synclog.jpg</link></figure>

<p>Before you can check this property however, you must first define the
setting for the Synchronization Log Table. To define these settings,
click the Project Properties button when the Web Projects Control Panel
has focus.</p>
<p>Scroll to the Offline Data Synchronization Log Table Settings section
and set the properties for the table. You can map this table to an
existing table in your SQL database or Alpha Anywhere can create a new
table for you with the correct table structure.</p>

<figure><link>images/offlinesynctableproperties.jpg</link></figure>
<p>




<title>METHODS</title>
<h3>UX Component Methods</h3>
<p>The following are new methods for the UX component. These methods apply to UX
components that contain Lists which have Detail Views.</p>


<p>{dialog.object}.countRecordsToSynch(listId) - Returns an
object with properties showing the number of records that have not yet been
synchronized with the server. The object has these properties: count,
updatedRecords, newRecords, deletedRecords. 'count' is all dirty records
(edits, inserts and deletes), 'updatedRecords' is all records that were
edited, 'newRecords' is records that were added and 'deletedRecords' is
records that were deleted.</p>
<note> If the listId is a child List of a
parent List that has pre-fetched data, the counts from the top-level List
are returned. For example, if your UX as a List for 'Customers' and 'Orders'
and the data for 'Orders' has been pre-fetched in the 'Customer' List,
requesting the count of records to be synched for the 'Orders' list will
return the count for the 'Customer' list since data for pre-fetched child
Lists are synchronized at the parent List level.</p>
<p><br>
var o = {dialog.object}.countRecordsToSynch(listOrders)</p>
<p>alert('You have ' +  o.count + ' records to
synchronize')


<p>{dialog.object}._getDirtyLists() - Returns an array of the Lists that
are dirty. See also ._hasDirtyLists().</p>

<p>{dialog.object}._getListForDetailViewControl(colName) - If the
specified colName is in the Detail View of any List control on the UX,
returns the name of the List control.</p>
<p>var listName =
{dialog.object}._getListForDetailViewControl('state');</p>

<p>{dialog.object}._hasDirtyLists() - Returns true if any List on the UX
is dirty. See also ._getDirtyLists().</p>

<p>{dialog.object}._isControlInListDetailView(colName) - Returns
true if the colName is inside the Detail View of any List control on the
UX</p>

<p>var flag = {dialog.object}._isControlInListDetailView('firstname');</p>

<p>{dialog.object}.persistListToLocalStorage(ListId) - Manually persist List data and state to Local Storage
(assuming the List properties have been set to allow persistence to Local
Storage). Normally this method is not needed because the List is
automatically persisted to Local Storage any time the List contents is
changed (by adding, deleting or editing data in the List).</p>

<p>{dialog.object}.refreshListData() Method - Incremental Refresh Option
- The .refreshListData() method makes an Ajax callback to refresh the data shown
in a List control. By default, the Ajax callback computes a new set of data to
show in the List, sends that data back to the client, completely repopulating
the List.</p>
<note> If the List has any unsynchronized edits you cannot
execute the .refreshListData()
method.</p>
<p>You can specify that you want to perform an 'incremental' refresh, rather
than a 'full' refresh. The
syntax is:</p>

<p>{dialog.object}.refreshListData(listId,{mode:
'incremental'});</p>
<p>{dialog.object}.refreshListData(listId,{mode: 'full'});</p>

<p>If the optional second argument is omitted, a full refresh is assumed.</p>
<p>In the case of an 'incremental' refresh, only data for rows that have been
edited or added to the the database since the time the List was initially
populated are sent to the client. In addition, a list of keys that have been
deleted is also sent to the client. This may result in a substantially smaller
payload being sent back to the client - especially if only a few rows have been
edited or added. The size of the payload is important in mobile applications.</p>
<p>The main benefit of this option is the reduction on the response payload.
There is a small cost in terms of the load placed on the server, as the server
has to determine which records have changed. </p>
<p>Also, the payload of the initial request from the client to the server to
request a refresh is slightly larger because a list of primary keys and their
CRC values has to be sent to the server.</p>
<p>IMPORTANT: In order to use the 'incremental' refresh option, you must
set the Include CRC in List data property to true. </p>


<p>{dialog.object}.refreshListsIncremental() - Performs an incremental
refresh on all Lists. This method simply executes the standard
{dialog.object}.refreshListData() 
method, passing in the optional {mode: "incremental"} parameter to the method.</p>
<p>An incremental refresh differs from a full refresh in that only rows that
were edited on the server after the List was initially populated are sent to the
client. An incremental refresh can only be done if the List's
Include CRC in List data
property has been checked.</p>

<figure><link>images/listcrcproperty.jpg</link></figure>

<p>{dialog.object}.saveListEdits(listId [,options] ) - Synchronizes edits
that have been made to the List (and any of its child Lists). By default, edits
from all dirty rows in the List are submitted to the server. You can optionally
specify that just the edits for the currently selected row should be submitted
to the server (by passing in {rows:
'current'} in the optional 
options parameter.</p>
<p>If the List is based on a SQL data source, the data are automatically saved
to the table(s) on which the List is based. Alpha Anywhere automatically
generates the necessary SQL CRUD statements from the submitted data.</p>
<p>If the List is not based on a SQL data source (for example the
Data Source property of the List is set to 'Custom', 'Static',
'Javascript', etc.), then you must write your own synchronization handler to
persist the submitted data. See 
<link href="Custom Handlers for Synchronization Tasks">Custom Handlers for Synchronization Tasks</link>
for more information.</p>
<p>When you submit multiple dirty rows of data you can choose to submit all rows
at once, or you can submit data in batches. The batch size can be specified in
the List properties, or you can override the setting in List properties by
specifying an option in the JSON options passed in as the second parameter to
the method. For example:</p>
<p>{dialog.object}.saveListEdits('LISTCUSTOMERS',{rows: 'allRows',
batchSize: 10});<br>
</p>
<p>When you submit data in batches, the first batch is submitted, then once that
batch is synchronized a subsequent callback is triggered to submit the next
batch, and so on, until all of the dirty rows have been submitted. The user can
cancel before all batches have been submitted. If the user does cancel, the
current batch that is being processed will continue to process, but once this
batch completes, no further batches will be sent to the server. For more
information on synchronizing in batches, see the section 
<link href="Synchronizing Data in Batches">Synchronizing Data
in Batches</link>.</p>

<p>Behind the scenes, this method does this:</p>
<ol>
<li>calls the List's .harvestList() method to get all of the dirty data to
submit to the server</li>
<li>makes an Ajax callback and submits the List data</li>
<li>performs server-side validation of the submitted data.</li>
<li>if server-side errors are found, compute the necessary Javascript to
return information about the errors to the List so that the Detail View
controls can be decorated with the appropriate error messages.</li>
<li>if any write conflicts were found on the server (because another user
had edited any of the records that were edited in the List), compute the
necessary Javascript to return information about the conflicts to the user
so that she may resolve them.</li>
<li>computes an Ajax response to refresh the rows in the List that were
updated and remove the 'dirty' flags from List rows that were previously
marked as 'dirty'.</li>
</ol>
<p>When the List edits are pushed to the server, you can optionally specify that
any edits that were made on the server (presumably, by other users) should be
pushed back to the List.</p>
<p>When you configure the List control you can set the synchronization policy to
control whether 'server-to-client' synching should take place.</p>
<p>Since 'server-to-client' synching is a more expensive operation than
'client-to-server' synching, you might want to turn this option off and instead
provide a menu choice to the client to explicitly do a 'server-to-client' synch.
To do an explicit 'server-to-client' synch, you can all this method:</p>

<p>{dialog.object}.refreshListData(listId,{mode:
'incremental'}); </p>

<note> When you specify the 'incremental' mode any rows in the List that are
dirty will not be refreshed.</p>


<p>Lists with Hierarchical Data </p>
<p>If you have Lists with hierarchical data, when you synchronize any List in
the hierarchy, all of the Lists in the hierarchy are synchronized. The
data sent back to the server by default includes the top level parent record and
only the dirty child records. However, when synchronizing hierarchical data you
can optionally submit all child records to the server (including records that
were not edited).</p>
<p>To indicate that you want to submit all child records, not just dirty child
records, set the 'allChildRecords' flag in optional arguments, as shown below:</p>

<p>{dialog.object}.saveListEdits('LIST',{rows: 'allRows',
allChildRecords: true});</p>

<note> It only makes sense to submit all child records to
the server if you have defined a custom synchronization handler. The option to
define a custom synchronization handler is only available if the List data
source is set to Custom or Static.</p>

<p>For example, say you have this hierarchy:</p>
<p>Customer List</p>
<p>    Orders List</p>
<p>        OrderDetails List</p>

<p>In other words, the OrderDetails List specifies that the Orders List is its
parent, and the Orders List specifies that the Customer List is its parent, and
the two child Lists (Orders and OrderDetails) specify that their data is
pre-loaded.</p>
<p>In this example, the Customer List will contain all of the data for its child
Lists.</p>
<p>When you synchronize edits at any level in the hierarchy, the 'logical'
record is submitted to the server. The 'logical' record is the top-level
parent record, and all of the child records. As mentioned above, by default, the
'logical' record only includes leaf node child records that are dirty.
However, if you set the allChildRecords flag to true then the composite record
that is submitted to the server is the complete record (including clean child
records).</p>

<p>{dialog.object}.synchronizeLists([options]) - Synchronizes all Lists.
This method just calls the .saveListEdits()
method for each List on the
component. See .saveListEdits() for more information.</p>
<p>The options options object is described in the section covering the
.saveListEdits()
method.</p>

<h3>List Methods - Detail View Part</h3>
<p>The following List methods can be used for Lists that have a Detail View
part:</p>

<note>In order to invoke any of these methods, your
Javsascript code must first get a pointer to the List object. For example:<br>
<br>
var listObj = {dialog.object}.getControl('LIST1');<br>
listObj.nameOfListMethodToInvoke();</p>

<p><listObj>.addTableRow(data [,options]) - Adds a new row of data to a
List that has a Detail View. By default, the new row is added at the end of the
List, but you can add the new row (i.e. insert the row) at any position by
setting options.</p>
<p>Where:</p>
<ul>
<li>
data - an object with the values in the List that you want to set.
</li>
<li>
options - an object with optional settings.</li>
</ul>
<p>The options object can contain these properties:</p>
<p>options.setFocusToTargetRow - true/false - If true, then focus will be
given to the target row. The default for this property is false.</p>
<p>options.insertRow - true/false -- default false. Set to true if you
want to insert at a specified position in the List rather than at the end.
(Requires build 4444 or above)</p>
<p>options.insertPosition - if options.insertRow is true, specify
where in the List the new row should be inserted. options.insertPosition can
either be a number or a string. If it is a number, it represents a zero based
row number in the List where the new record will be inserted. If it is a string
it represents the List value where the new row will be inserted.</p>

<p>Example:</p>

<p>//create a data object with values for the columns in the List
you want to edit</p>
<p>var data = {};</p>
<p>data.FIRSTNAME = 'Cecelia';</p>
<p>data.LASTNAME = 'Longwood';</p>

<p>//define optional settings<br>
var ops = {};</p>
<p>ops.setFocusToTargetRow = true;</p>

<p>//get a pointer to the List control and then call the .addTableRow()
method</p>
<p>var lObj = {dialog.object}.getControl('CUSTOMERLIST')</p>
<p>lObj.addTableRow(data,ops);</p>

<p>//insert the new row at position 3 (zero based)</p>
<p>var ops = {};</p>
<p>ops.setFocusToTargetRow = true;</p>
<p>ops.insertRow = true;</p>
<p>ops.insertPosition = 3;</p>
<p>lObj.addTableRow(data,ops);</p>




<p>Contrast the .addTableRow() method with the List object's
.appendRows()
method.</p>
<p>The .addTableRow() method is the programmatic equivalent of the user entering
some values into the List Detail view controls and then clicking on the Save
button to save their changes back to the List. When the user does this, the List
becomes dirty and the edits that have been made to the list can be synchronized
with the server.</p>
<p>The .appendRows() method is a low level method that adds the data to the
List, but this method does not add the necessary information to the List to
cause the List row that was added to become dirty. The new row cannot be
synchronized with the server.</p>
<note> To programmatically update a table row see the .updateTableRow() 
method.</p>
<p><listObj>.deleteRow(options) - Marks the current row in the List
as deleted. The row is not physically removed from the List until the data are
synchronized. If the current row is a new record, then the row is immediately
removed from the List.</p>
<p>options - a JSON object with these properties:</p>
<p>prompt - true/false - prompt for confirmation. Default is true.</p>
<p><listObj>.detailViewIsDirty() - Returns true/false if the controls
that show the Detail View are dirty or not.</p>
<p><listObj>.disableDetailView([flag]) - disables all of the controls in
the Detail View. If flag is false, enables all controls.</p>
<p><listObj>.fieldIsDirty(field [, rowNumber]) - Returns true if the
specified field is dirty. If the rowNumber is not passed in the currently
selected row is used. For new records, the field is considered dirty if it is
not blank.</p>
<p><listObj>.harvestListRow([zeroBasedRowNum]) - gets a JSON object of
the data in the row. If row is an existing row, the object includes an _oldData
object with the original values in the row. If the optional row number is not
passed in, the current row is harvested.</p>
<p><listObj>.harvestList([flagPrimaryKeysOnly]) - gets an array of JSON objects for each row
in the list that is either dirty, or a new row;</p>
<p>You can optionally pass in a flag (true/false) to indicate that you want an
array of primary keys for the dirty rows.</p>
<p><listObj>.listIsDirty() - Returns true if the List control has any
dirty rows. A 'dirty' row is an edited row, or new row that has not yet been
committed on the serever side. See also {dialog.object}._hasDirtyLists()</p>
<p><listObj>.listRowIsDirty([zeroBasedRowNum]) - Returns true if the
current row in the List is dirty. You can optionally specify a zero based row
number.</p>
<p><listObj>.listRowIsNew([zeroBasedRowNum]) - Returns true if the
current row in the List is a new row. You can optionally specify a zero based
row number.</p>
<p><listObj>.newDetailViewRecord() - Sets all of the controls in the List
Detail view to their 'new record' value and unselects the current row in the
List.</p>
<p><listObj>.populateUXControls() - populates UX
controls with data from the List. This method is internal - it is called
automatically when the onSelect event fires if the List has a Detail View.</p>
<p><listObj>.resetForm([options]) - Resets the Detail View form. Options
is an optional JSON object with these properties:</p>
<p>prompt - true/false - if true, prompts for confirmation before
resetting the form</p>
<p><listObj>.resetRow([options]) - Resets a List row that has been edited
to its original values. If the row has been marked as deleted, then 'un-deletes'
the row. Options is an optional JSON object with these
properties:</p>
<p>prompt - true/false - if true, prompts for confirmation before
resetting the form.</p>
<p><listObj>.setRowClean([zeroBasedRowNum]) - sets the row state to
clear. If row num is not specified, current row.</p>
<p>var lObj = {dialog.object}.getControl('list1');<br>
lObj.setRowClean();</p>
<p><listObj>.setServerSideError(flag [, zeroBasedRowNum [, errorObject]])
- Used internally to put information about server side errors into the List's
data object. </p>
<p>Sets the data object ._hasServerSideError flag to true or false;</p>
<p>If flag is true then also sets the data object's .serverSideErrors object to
the passed in errorObject</p>
<p><listObj>.updateListFromUXControls() - Updates the data in the List
with edits made in the List's Detail View controls.</p>
<p>var lObj = {dialog.object}.getControl('list1');<br>
lObj.updateListFromUXControls();</p>

<p><listObj>.updateTableRow(primaryKeyOrRowNumber,data [,options]) -
Updates data in a row in a List that has a Detail View.</p>
<p>Where:</p>
<ul>
<li>primaryKeyOrRowNumber - The primary key value or row number (zero
based) of the row you want to update. If this argument is a string then it
is assumed to be a primary key value. If it is a number, then it is assumed
to be a row number. The primary key of the List is specified in the List
builder.</li>
<li>data - an object with the values in the List that you want to
set. </li>
<li>options - an object with optional settings.</li>
</ul>
<p>The options object can contain these properties:</p>
<p>options.setFocusToTargetRow - true/false - If true, then focus will be
given to the target row. The default for this property is false.</p>
<p>Example:</p>

<p>//create a data object with values for the columns in the List
you want to edit</p>
<p>var data = {};</p>
<p>data.FIRSTNAME = 'Cecelia';</p>
<p>data.LASTNAME = 'Longwood';</p>

<p>//specify the primary key of the row to update</p>
<p>var primaryKey = '1234';</p>

<p>//define optional settings<br>
var ops = {};</p>
<p>ops.setFocusToTargetRow = true;</p>

<p>//get a pointer to the List control and then call the .updateTableRow()
method</p>
<p>var lObj = {dialog.object}.getControl('CUSTOMERLIST')</p>
<p>lObj.updateTableRow(primaryKey,data,ops);</p>

<p>Contrast the .updateTableRow() method with the List object's .updateRow()
method.</p>
<p>The .updateTableRow() method is the programmatic equivalent of the user
entering some values into the List Detail view controls and then clicking on the
Save button to save their changes back to the List. When the user does this, the
List becomes dirty and the edits that have been made to the List can be
synchronized with the server.</p>
<p>The .updateRow() method is a low level method that updates the data in a
row, but this method does not add the necessary information to the List to cause
the List row that was edited to become dirty. It does also not add the
._oldData
object to the List to store the original values that were in the List row before
it was edited. The changes that were made to the List cannot be synchronized
with the server.</p>
<note> To programmatically add a table row see the .addTableRow() 
method.</p>


<p><listObj>._ClearServerSideErrors([zeroBasedRowNum]) - Used internally.
Clears error messages from the Detail View controls.</p>
<p><listObj>._debugListData() - shows the contents of the data object for
the current row in the List. You must have specified a placeholder for the debug
information.</p>
<p><listObj>._getControlsInDv() - Returns an array of all of the controls
in the Detail View. Only controls that actually exit are returned. For example,
say you specified that the Detail View is all of the controls in a container
called 'CONTAINER_1' and one of the controls in this container is called 'SHIPPING_ADDRESS',
but the List does not have a field called 'SHIPPING_ADRESS'. The array of
controls returned by this function will not include the 'SHIPPING_ADDRESS'
control.</p>
<p><listObj>._getListFieldFromControl() - Takes the name of a Detail View
control and returns the field name in the List that the control is mapped to.</p>
<p><listObj>._getRoute() - For use with Lists that contain hierarchical
data. Gets an array of objects with the current row primary key value (default)
or row number in all Lists in the hierarchy. Each object in the array has two
properties: list an row. 'list' is the name of the List, and row is the current
(zero based) row number that is selected. </p>
<p>For example, say you have three Lists - CUSTOMERS, ORDERS, ORDERDETAILS. </p>
<p>var lObj = {dialog.object}.getControl('CUSTOMERS');</p>
<p>var route = lObj._getRoute()</p>

<p>This will return an array that might look like this:</p>
<p>[</p>
<p>    {list: 'CUSTOMERS', row: 'ALFKI'},</p>
<p>    {list: 'ORDERS', row: '11063',</p>
<p>    {list: 'ORDERDETAILS', row: '11063|||27'}</p>
<p>]</p>

<p>To use row numbers:</p>
<p>var route = lObj._getRoute('rowNumber');</p>

<p><listObj>._hasClientSideError() - returns true if any control in the
List Deail View has a client-side validation error.</p>
<note> The placeholders that you specify for the Global Error Message and the
Fade-out Message will consume space in the Layout. You can wrap then in a NoFloat container and set the float property of the container iself to .f. so
that they don't consume space.</p>
<p><listObj>._logicalRow2PhysicalRow() - Takes the logical row number
(the value of the *key property in the data object - also the same as the row
number in the data when it is loaded - before any client side sorting/filtering)
and converts to a physical row number in the current sorted/filtered client side
view of the data.</p>
<p><listObj>._setRoute(routeArray) - For use with Lists that contain
hierarchical data. Sets the selected row on each List in the routeArray. See
._getRoute()
method for more details.</p>
<note> If you don't pass in a routeArray to the
method, the method will look for a value in the <listObj> '__currentRoute'
property. This property is automatically set when you call the {dialog.object}.saveListEdits()
method.</p>
<p><listObj>._showServerSideErrors([zeroBasedRowNum]) - Used internally.
Paints error messages on the Detail View controls using information stored in
the List data .serverSideErrors object.</p>

<h3>List Methods - Search Part</h3>
<p>The following List methods can be used for Lists that have a integrated Search
part:</p>

<note>In order to invoke any of these methods, your
Javsascript code must first get a pointer to the List object. For example:<br>
<br>
var listObj = {dialog.object}.getControl('LIST1');<br>
listObj.nameOfListMethodToInvoke();</p>


<p><listObj>.searchModeOn() - If the List Search Part is set to 'QueryByForm'
then turns search mode on.</p>
<p>Example: </p>
<p>var lobj = {dialog.object}.getControl('LIST1')<br>
lobj.searchModeOn();</p>

<note> The search mode can be displayed by adding a Label control to the UX and
setting the control's client-side calculated expression to:<br>
dialog.listDetailView.LISTNAME.mode<br>
<br>
where 'LISTNAME' would be replaced by the actual List name (in capitals).</p>
<p><listObj>.searchModeOff() - If the List Search Part is set to 'QueryByForm'
then turns search mode off.</p>
<p>Example: </p>

<p><listObj>.searchList([options]) - Submits the Search Part to
search the List.  You can specify if the search should be performed
client-side, server-side or 'auto'.</p>
<ul>
<li>options - an optional JSON format string that indicates where the
search should be performed (client-side or server-side). In the case of
server-side search, you can set additional optional properties. </li>
</ul>
<p>The JSON options object has the following optional properties:</p>

<ul>
<li>
searchMode - can
be set to clientSide,
serverSide or
auto. The 'auto' option performs a server-side search if the List is not 'dirty'
(i.e. does not have any unsynchronized edits). Otherwise, it performs a
client-side search.</li>
</ul>
<ul>
<li>
maxRows - in the case of a
server-side search, indicates the maximum number of rows that the search is
allowed to return. This property overrides the property that is set in the
List Builder on the Search Part pane.</li>
</ul>
<ul>
<li>
maxPayload - in the case of
a server-side search, indicates the maximum payload that the search is
allowed to return. This property overrides the property that is set in the
List Builder on the Search Part pane.</li>
</ul>
<p>Example:</p>
<p>
{dialog.object}.getControl('LIST1').searchList({searchMode : 'auto', maxRows:
30});</p>

<note> The 
beforeSearch client-side event fires before the search is performed. This
event exposes the searchWhere property that tells you where the search will be
performed.</p>

<p><listObj>.clearSearchList([options]) - Removes any filter previously
applied by submitting the Search Part.</p>
<p>See .searchList() method for information about options.</p>

<p><listObj>.queryByFormClearControls() - Removes the search criteria
from the Detail View form when the List is in 'search' mode.</p>
<p>Events</p>
<ul>
<li>beforeSearch - Fires before the search is executed. The 'e'
object passed into the event has these properties:
searchMode - 'search' (user
is performing a search) or 'clear' - user is clearing a previously applied
search and searchWhere - 'clientSide'
or 'serverSide'.</li>
<li>afterSearchComplete - Fires after the search has executed. The
'e' object passed into the event has these properties:
searchMode - 'search' (user
is performing a search) or 'clear' - user is clearing a previously applied
search and recordsInQuery -
a count of the number of records found by the search.</li>
</ul>

<title>Videos</title>


<table>



<tr>
<td>
UX Component - List Control</td>
<td>
Introduction to the List Control Detail View</td>
<td>
The List control can have an associated Detail
View. The Detail View allows you to see details
for the currently selected row in the List. The
Detail View can be updateable, allowing you to
update data that is in the List.<br>
<br>
In this video we show how you can add a Detail
View to a List. We show two different genies
that you can use - one for setting up a List
with a Detail View, and another for adding a
Detail View to an existing List.<br>
<br>
IMPORTANT: Lists with Detail Views are
the essential building block for applications
that can work while you are disconnected. For
more information about the features of Lists
with Detail Views, see the videos in the 'UX
Component - Disconnected Applications' category.
<u>Even if you do not need to build mobile
applications that work while disconnected, the
information regarding Lists and Detail Views in
these videos will be relevant.</u><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_detailView1.swf">Watch Video - Part
1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_detailView2.swf">Watch Video - Part 2</link><br>
<br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - List Control</td>
<td>
Contrasting Data Binding at the UX Level with
Data Binding at the List Level to Update a SQL
Database</td>
<td>
When you want to update data in a SQL database
using a UX component you previously could define
Data Binding properties for the UX component,
then define a server-side action that loaded the
primary keys of the records you wanted to edit
and another server-side action to save the edits
back to the SQL database.<br>
<br>
Now, using a List control with an updateable
Detail View, you can perform edits on a SQL
database using the List and its associated
Detail View.<br>
<br>
In this video we contrast the two methods of
performing CRUD (create, read, update, delete)
operations on a SQL database using Data Binding
and List controls.<br>
<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_crud_1.swf">Watch Video - Part
1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_crud_2.swf">Watch Video - Part 2</link><br>
<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_crud_compare.zip">Download Components</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - List Control</td>
<td>
List Control Search Part </td>
<td>
The List control has a built-in Search Part that
allows you to perform searches on the database
that is used to populate the List. (This is very
much like the Search Part in a Grid component).<br>
<br>
The Search Part in the List can be configured in
three different ways:<br>
- individual fields for the Search Part
(allowing the user for example to enter criteria
in a Name, City or Country field)<br>
- a single keyword field (allowing the user to
enter criteria in a single field then then
searching for matches in multiple fields)<br>
- query by form (allowing the List's Detail View
to be used to enter the search criteria)<br>
<br>
In this video we show how the various options
can be used to search a List. <br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_searchPart_1.swf">Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_searchPart_2.swf">
Watch Video - Part 2</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_searchPart_3.swf">
Watch Video - Part 3</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_searchPart_4.swf">
Watch Video - Part 4</link><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/list_searchPart.zip">
Download Components</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Introduction</td>
<td>
You can build applications that are designed to
work when you are disconnected. The UX component
and the List control are the fundamental
building blocks of these types of applications.<br>
<br>
In this video overview we show how a UX
component is built using a List control with an
associated Detail View to display and edit data,
how the data in the List is persisted to Local
Storage and then how the edits made to the List
data are synchronized with the server. We also
show how your disconnected data can be
'hierarchical' - i.e. a list of customers, with
orders for each customer and order details for
each order.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_disconnected_introduction_1.swf">Watch Video 1 - Setting up a List with a Detail
View using the Quick Setup Genie</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_disconnected_introduction_2.swf">Watch Video 2 -
Editing Data and Persisting Data to Local Storage</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_disconnected_introduction_3.swf">Watch Video 3 - Introduction to Hierarchical
Data Structures</link><br>

<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Editing Data While Offline and then
Synchronizing the Data</td>
<td>
When you build an application for disconnected
operation, the List control is the basic
building block for the application. The List
control is used as the 'offline' data storage.
The data in the List control can be thought of
as an in-memory table. Edits to this data are
persisted to Local Storage and then are pushed
to the server to synchronize with the server
database when a connection is available.<br>
<br>
In this video we look at how data in the List
are edited and then synchronized with the server
database.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_editing_data_whileOffline.swf">Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Editing Data While Offline - Behind the Scenes -
What Data are Stored in the List</td>
<td>
In order to get a better understanding of how
the data in a List control are stored to support
disconnected operation, this video shows how you
can debug into the internal data that is stored
in the List when the user edits, enters and
deletes records.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_dataObjectForEachRow.swf">Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Synchronization Errors - Validation Errors</td>
<td>
When a user synchronizes edits to data that were
made while they were offline, there is the
possibility of synchronization errors.<br>
<br>
These errors can typically result because the
user entered a value in a field that was
rejected by some server-side validation logic, because of a write conflict,
or because the database rejected the edit.<br>
<br>
In this video we show how synchronization errors
that result from server-side validation errors
and database errors
are handled.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_serversidevalidation_1.swf">
Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_serversidevalidation_2.swf">
Watch Video - Part 2</link><br>
<br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Synchronization Errors - Write Conflicts</td>
<td>
When a user synchronizes edits that were made
while they were offline, there is the
possibility that some other user edited and then
synchronized the same data before the user had a
chance to synchronize his/her edits.<br>
<br>
If this happens a write conflict will occur and
the user will be notified that the synchronize
operation could not be completed. The user will
have to choose how to resolve the conflict. The
developer also has the option of handling write
conflict errors programmatically.<br>
<br>
In this video we show how write-conflict errors
are handled.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_write_conflict1.swf">
Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_write_conflict2.swf">
Watch Video - Part 2</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_write_conflict3.swf">
Watch Video - Part 3</link><br>
<br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Synchronization Events</td>
<td>
When data in a List control is synchronized with
the server database there are a number of events
that fire (on both the client-side and the
server-side) that give you a lot of control over
the process and allow you to inject custom code
to be executed.<br>
<br>
In this video we discuss some of the events that
fire when data are synchronized.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_synch_events.swf">Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Custom Synchronization Handlers</td>
<td>
When the user synchronizes a List that is based
on a SQL database, Alpha Anywhere automatically
generates the SQL statements to perform the
various CRUD (create, read, update, delete)
operations.<br>
<br>
However, if your List is based on a custom
datasource (for example, a web service), then
you must write your own functions to handle
synchronization of the data.<br>
<br>
In this video we show an example of how custom
handlers can be written to synchronize data.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/xb_customSync_1.swf">Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/xb_customSync_2.swf">Watch Video - Part
2</link><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_customHandlers_list_synchronization.zip">
Download Component</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Incremental Refresh</td>
<td>
After a List has been populated with data from
the server you can perform incremental refreshes
on the List data to retrieve any edits that have
been made to server data. Unlike a full refresh,
only rows that have been edited are sent to the
client, resulting in a much smaller payload
being sent to the client compared to a full
refresh of the List data.<br>
<br>
You can also set a 'synchronization policy' in
the List definition to specify that every time
edits to the List data are synchronized with a
server an incremental refresh of the List should
also be performed.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_incrementalRefresh.swf">Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Geographic Data - Capturing Location Information
when the User Edits Data</td>
<td>
You can configure a List so that every time the
user enters a new record, or edits a record, the
user's location will be stored. This allows you
to create applications where you capture the
location of the device at the time a record was
edited or entered.<br>
<br>
In this video we show how this is done.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_captureLocation.swf">
Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_captureLocation2.swf">
Watch Video - Part 2</link><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_geography.zip">
Download Component</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/mysql_schema_geogTable.zip">
Schema for MySQL Table Used in Component</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Geographic Data - Capturing Location Information
when the User Synchronizes Data</td>
<td>
In a  previous video we show how location
information can be captured at the time the user
edits a record in the List. But you can also
capture location information at the time the
user synchronizes the data.<br>
<br>
In this video who show how to configure the List
to submit location information at the time the
user synchronizes the List.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_list_captureLocationAtSynchTime.swf">
Watch Video</link><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_captureLocationOnSynch.zip">
Download Component</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/mysql_schema_geogTable.zip">
Schema for MySQL Table Used in Component</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
</td>
<td>
</td>
<td>
</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Geographic Data - Geocoding Data</td>
<td>
In order to perform geography searches on your
data (for example, find all records that are
within 5 miles of my current location), you need
to geocode the data in your table. For example,
if you have captured the address for the record,
when the record is synchronized, you can make a
call to a geocoding service to get the
latitude/longitude for the record. Then when the
record is written to the database you can also
compute the location field value so that
geography searches are possible.<br>
<br>
In this video we discuss the features that the
List control exposes to support working with
geographic data.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_geocodedataonsynch.swf">
Watch Video</link><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_geocode.zip">
Download Component</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/mysql_schema_geocodeexample.zip">
Schema for MySQL Table Used in Component</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Setting Default Values for Fields in New Records</td>
<td>
When you enter a new record in a List with a
Detail View you might want to set default values
for certain of the fields in the Detail View.<br>
<br>
The List builder allows you to execute
Javascript code to compute the default value for
each field in the List. This allows for
sophisticated computations for the default
value, including setting the default value for a
field to the value that was just entered into
the previously entered record.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_definingDefaultValueForNewRecord.swf">
Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Synchronizing Data in Batches</td>
<td>
If the user has made a large number of edits
while they were offline you might want to
synchronize the data in batches, rather than
sending all of the edits to the server at once.
<br>
<br>
In this video we show how you can configure the
synchronization process so that data are sent to
the server in batches.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_batchSynch.swf">
Watch Video</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_synch_in_batches.zip">
Download Component</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Delaying Populate List Till Active Search</td>
<td>
In an application designed for disconnected
usage, the user will typically load a subset of
the database onto their mobile device while they
have connection.<br>
<br>
This is usually done by adding a Search Part to
the primary List control in the component and
specifying the the List should not be populated
until the user has performed a search to
retrieve the 'records of interest'. <br>
<br>
TIP: For more information on how to set up the
Search Part for a List control see the video
titled 'List Control Search Part'.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_search_delayPopulate.swf">
Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Settings Maximum Number of Records that a Search
Can Return</td>
<td>
In an application designed for disconnected
usage, the List controls in the UX component
hold the data that will be available while the
user is offline. These Lists are populated when
the user does a search to retrieve the 'records
of interest' that they want to have available to
them while they are on-line.<br>
<br>
Since the amount of data that can be held on a
mobile device is limited, you will typically
want to ensure that the user does not enter
search criteria that retrieve too many records.<br>
<br>
In this video we show how you can set limits on
how large a result a user search is permitted to
return.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_search_settingMaxSize.swf">
Watch Video</link><br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Persisting Data to Local Storage</td>
<td>
When you build an application for disconnected
operation you need to be sure that the data in
the application is persisted to Local Storage so
that edits that are made to any data are not
lost if the application is restarted before the
user has had a chance to synchronize the data
with the server.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/UX_LocalStorage_1.swf">Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/UX_LocalStorage_2.swf">Watch Video - Part 2</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/UX_LocalStorage_3.swf">Watch Video - Part
3</link><br>
<br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Working with Hierarchical Data</td>
<td>
The data for disconnected applications are
stored in List controls. In many types of
applications the data you need to work with is
hierarchical. For example, you might have a list
of customers. Each customer has orders and each
order has order details.<br>
<br>
In a connected application, you can make an Ajax
callback to the server when a user selects a
different customer to fetch to orders for that
customer. However, in a disconnected application
you cannot make callbacks to the server, so when
the user selects a customer, the orders for that
customer must already have been retrieved from
the server so that the data can be shown without
making an Ajax callback.<br>
<br>
The List control can easily be populated with
hierarchical data. In this video we explain how
a List control is populated with a customers,
each customers' orders, and each order's
details.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_hierarchicaldata_1.swf">
Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_hierarchicaldata_2.swf">
Watch Video - Part 2</link><br>
<br>
In this follow on video we show how new records
can be added to child tables and how the new
records are automatically linked to their
parent. In the video we show how a new order is
added for the selected Customer record and then
how new order detail records are added for the
new order. When the data are synchronized, the
linking fields are automatically filled in - the
customer Id is filled into the new order record
and the order id is filled into the new order
detail records.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_hierarchicaldata_3.swf">
Watch Video - Part 3</link><br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_cust_order_details.zip">
Download Component</link><br>
<br>
<br>
Date Added: 2014-09-07</td>
</tr>



<tr>
<td>
UX Component - Disconnected Applications</td>
<td>
Managing Local Storage</td>
<td>
When you build an application that is designed
for offline use (i.e. a disconnected application), the data in
the List controls, and the variables in the UX
component are persisted to Local Storage.<br>
<br>
In this video we show how you can manage the
data in Local Storage using the built-in Local
Storage manager and using methods of the UX
component.<br>
<br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_manage_localStorage_1.swf">Watch Video - Part 1</link><br>
<a href="http://www.ajaxvideotutorials.com/V12Videos/ux_manage_localStorage_2.swf">Watch Video - Part 2</link><br>
<br>
<br>
Date Added: 2014-09-07</td>
</tr>



</table>
