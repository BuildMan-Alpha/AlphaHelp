<page>
	<topic>Learning Xbasic - Using Xbasic with SQL Tables
</topic>
<sections>
	
	<section>
		<title>Before you start</title>
		<description>To follow the examples in this tutorial, create a named connection called "AlphaSportsXbasic". The connection type is 'Access' and the target .MDB file for the connection is the sample Alphasports.MDB file that is installed in the MDBFiles folder under your Alpha Anywhere installation.
</description>
	</section>
	
	<section>
		<title>Videos
</title>
		<description>The videos for this training course are at:
</description>
		<videos>
			<video>
				<name>Video - Part 1</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_1.swf</link>
			</video>
			
			<video>
				<name>Video - Part 2</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_2.swf</link>
			</video>
			
			<video>
				<name>Video - Part 3</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_3.swf</link>
			</video>
			
			<video>
				<name>Video - Part 4</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_4.swf</link>
			</video>
			
			<video>
				<name>Video - Part 5</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_5.swf</link>
			</video>
			
			<video>
				<name>Video - Part 6</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_6.swf</link>
			</video>
			
			<video>
				<name>Video - Part 7</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_7.swf</link>
			</video>
			
			<video>
				<name>Video - Part 8</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_8.swf</link>
			</video>
			
			<video>
				<name>Video - Part 9</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_9.swf</link>
			</video>
			
			<video>
				<name>Video - Part 10</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_10.swf</link>
			</video>
			
			<video>
				<name>Video - Part 11</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_11.swf</link>
			</video>
			
			<video>
				<name>Video - Part 12</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_12.swf</link>
			</video>
			
			<video>
				<name>Video - Part 13</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_13.swf</link>
			</video>
			
			<video>
				<name>Video - Part 14</name>
				<link>http://www.ajaxvideotutorials.com/Training/XbasicAlphaDAO_14.swf</link>
			</video>
			
			
		</videos>
	</section>
	
	<section>
		<title>Working with SQL Tables using Xbasic
</title>
		<cases>
			<case>
				<description>Powerful ways to read and update SQL data from within Alpha Anywhere 
</description>
			</case>
			<case>
				<description>Xbasic provides powerful commands to work with data in SQL tables. 
</description>
			</case>
			
		</cases>
		
		
		
	</section>
	<section>
		<title>Active Link Tables vs. Direct SQL Commands
</title>
		<cases>
			<case>
				<description>Two ways to work with data in SQL. 
</description>
			</case>
			<case>
				<description>1. Active-link tables are an indirect way of working with SQL data. An active-link table is really a native Alpha Anywhere .dbf table that gets populated on the fly with data from the SQL table. When you make any edits to the active-link table, the edits are really being made to the temporary local .dbf table, and then behind the scenes, Alpha Anywhere translates the changes that you made into SQL commands and executes those commands on the SQL table. 
</description>
			</case>
				<case>
				<description>2. Direct SQL allows you to pass SQL commands directly to the SQL database. 
</description>
			</case>
		</cases>
		
		
		
	</section>
	<section>
		<cases>
			<case>
				<title>Pros</title>
				<description>Can use your existing knowledge of using Xbasic to manipulate native tables 
</description>
			</case>
			<case>
				<description>Updating an active-link table is identical to a native Alpha Anywhere table. 
</description>
			</case>
			<case>
				<description>Don't have to know any SQL! 
</description>
<example><![CDATA[dim tbl as p
tbl = table.open("customer")
tbl.change_begin()
tbl.firstname = "Fred"
tbl.change_end(.t.)
tbl.close() ]]></example>
			</case>
			<case>
				<title>Cons</title>
				<description>Can be slow compared to direct SQL </description>
			</case>
		</cases>
		
		
	</section>
	<section>
		<title>Advantage of Direct SQL Commands
</title>
		<description>Very fast and exposes all the power of the SQL backend 
</description>
	</section>
	
	<section>
		<title>AlphaDAO
</title>
<cases>
	<case>
		<description>A set of Xbasic classes that enable you to work with SQL Databases 
</description>
	</case>
	<case>
		<description>Contrast with ADO 
</description>
	</case>
	<case>
			<note> ADO is Microsoft technology. It stands for ActiveX Data Objects and you can use ADO in Xbasic to work with SQL databases, just as you can use AlphaDAO. However, AlphaDAO is significantly easier to work with, and to understand, than ADO.</note>

	</case>
</cases>


		</section>
<section>
	<title>The AlphaDAO Objects - (the ones you need to know about)
</title>
<cases>
	<case>
		<title>Connection Object </title>
		<description>The connection object allows you to connect to a SQL database and then, once you are connected, to send commands to the SQL database. The 'commands' that you send to the SQL database are typically SQL (Structured Query Language) commands.
</description>
	</case>
	<case>
		<title>ResultSet Object </title>
		<description>The ResultSet object contains the data that is retrieved from the SQL database after you execute a command that selects data.
</description>
	</case>
	<case>
		<title>Arguments Object </title>
		<description>The arguments object is used to pass values to SQL commands. An argument is like a variable. You can use arguments in SQL commands rather than explicit values. For example:
</description>
	</case>
	<case>
		<example><![CDATA[Select * from customer where bill_state_region = 'MA'

Select * from customer where bill_state_region = :whatState
 ]]></example>
 <note>You should always use arguments when constructing SQL commands in Xbasic. 
</note>
	</case>
	
	
</cases>	
	
</section>	
	
<section>
	
	<title>The Connection Object
</title>
<cases>
	<case>
		<title>Dimming a Connection Object </title>
		<example><![CDATA[Dim cn as sql::connection]]></example>
	</case>
	
	<case>
		<title>Opening a Connection </title>
		<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")]]></example>
	</case>
	
	<case>
		<title>Executing a Command </title>
		<example><![CDATA[dim sqlCommand as c
sqlCommand = "Select * from customer"
flag = cn.execute(sqlCommand)
?flag
= .T. ]]></example>
	</case>
	
	<case>
		<title>Checking for errors - CallResult.Text </title>
		<description>You can always see if a SQL command executed successfully by checking the connection object's callResult property
</description>
		<example><![CDATA[?cn.callResult.text
= "Success"

'Now, make an intentional error - there is no table called MyCustomers
dim sqlCommand as c
sqlCommand = "Select * from mycustomer"
flag = cn.execute(sqlCommand)
?flag
= .f.
?cn.callResult.text
= Database API specific error ]]></example>
	</case>
	<case>
		<description>Your database has returned the following error code and description to Alpha Anywhere.
Consult your database documentation for further information.</description>
	<example><![CDATA[208 - '[Microsoft][SQL Server Native Client 10.0][SQL Server]Invalid object name 'mycustomers'.
SQL State is: 42S02' ]]></example>	
	</case>
</cases>	
	
</section>	
<section>
	<title>Connecting to a Database</title>
<cases>
	<case>
		<title>Connection string </title>
	<description>The connection string tells the connection object how to connect to the SQL database. The connection string has information about the database type you are connecting to, the address of the SQL database, the name of the database you want to use, the user name, the password etc.
Here is an example connection string:
</description>
<example><![CDATA[{A5API='SQLServer',A5Syntax='SQLServer',A5DBVersion='2008',A5ANSINullPadWarn='Default',
Database='AlphaSports',Server='selwyndell\sqlexpress',Trusted_connection='yes'}
 ]]></example>	
		
	</case>
	<case>
		<description>To build a connection string, you use the built-in Connection String builder.
</description>
		<figure><link>http://www.downloads.alphasoftware.com/Tutorials/ConnStringBuilder.jpg</link></figure>
	</case>
	<case>
		<description>You can give a connection string a name so that it can be easily reused.
To manage your connection strings, go to Tools, External Databases, AlphaDAO Connection Strings
Notice the Trace SQL checkbox. It allows you to turn on SQL tracing so that you can go to the Trace Window and see all of the SQL commands that get executed.
</description>
	</case>
	
	<case>
		<title>Named connections vs. ad-hoc connections 
</title>
		<description>An ad-hoc connection is an explicit connection string - not a named connection.
A named connection is a connection string that has a name.
You should always try to use named connection strings when developing applications. Then if you have to change the location or type of the SQL database after you have built the application, you just change the definition of the named connection string that you are using and then your entire applications points to a new database.
</description>
	</case>
	
	<case>
		<title>Checking for connection errors 
</title>
		<description>Every time you execute a SQL you should always check to see if the command was successful.
</description>
	</case>
	
</cases>	
	
</section>
<section>
	<title>Executing a Select Command
</title>
	<cases>
		<case>
			<title>Simple Select </title>
			
			<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select * from customer where bill_state_region = 'MA'"
flag = cn.execute(sqlCommand)
?flag
= .t. ]]></example>
			<note>Note that literal stings in SQL are single quoted, not double quoted!
</note>
		</case>
		<case>
			<title>Using Arguments </title>
			<description>In the next slide we will use an argument instead of hard coding the where clause value into the SQL statements
</description>
		</case>
	</cases>
	
</section>
	
	<section>
		
<title>Using Arguments in a Select Command
</title>		
<cases>
	<case>
		<title>Dimming a SQL::Arguments object </title>
		<description>Before you can use the Arguments object, you have to dim a variable as an Argument object.
</description>
		<example><![CDATA[Dim args as SQL::Arguments
 ]]></example>
	</case>
	<case>
		<title>Setting Argument Values 
</title>
		<description>Once you have an Arguments object, you can call its methods to set argument values. The .Add() and .SetNull() methods of the Arguments object are used to set the value of arguments. .SetNull() is a special method to create arguments that have a value of NULL.
</description>
		<example><![CDATA['create an argument called 'WhatState' and give it a value of 'MA'
args.add("WhatState","MA")

'Create a character argument called CompanyName and give it a value of NULL
args.SetNull("CompanyName","C")
'Create a numeric, NULL valued argument
args.SetNull("Salary","N")
 ]]></example>
	</case>
	<case>
	
		<description>Arguments have a data type. The standard Xbasic data types are supported. These are character, date, time, numeric, logical. To create an argument of a particular type, you just set its value to a value of that type. For example:
</description>
		<example><![CDATA[args.add("whatTime",now())
args.add("whatNumber",23)
args.add("whatDate",date())
args.add("isMarried",.t.) ]]></example>
	</case>
	<case>
		<title>Passing in the Arguments object to the .Execute() Method 
</title>
		<description>Note how you can pass in the arguments object to the .execute() method as the second argument.
</description>
		<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select * from customer where bill_state_region = :whatstate"

flag = cn.execute(sqlCommand,args)
?flag
=.t. ]]></example>
	</case>
	<case>
		<title>Persisting to and from XML </title>
		<description>You can save argument values in an XML string and you can recreate an argument object from an XML string.
</description>
		<example><![CDATA[dim string as c
string = args.XML
?string
<SQLArguments>
<SQLArgument>
<Name>companyname</Name>
<Data Type="C"></Data>
<IsNull Type="L">1</IsNull>
<Usage>Input</Usage>
</SQLArgument>
<SQLArgument>
<Name>whatstate</Name>
<Data Type="C">MA</Data>
<IsNull Type="L">0</IsNull>
<Usage>Input</Usage>
</SQLArgument>
</SQLArguments>

'Now, populate a new arguments object from this XML string
dim args2 as sql::arguments
args2.xml = string

'prove that args2 has been populated
?args2.ArgumentNumber("whatstate")
= 2

?args2[2].data
= "MA" ]]></example>
	</case>
	
</cases>		
		
	</section>
	
	
	
<section>
	
	<title>The ResultSet Object
</title>
<cases>
	<case>
		<title>Getting a ResultSet 
</title>
	<description>After a SELECT command has been successfully executed, you can get a ResultSet object.
The ResultSet is a property of the connection object.</description>	
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select * from customer where bill_state_region = 'MA'"
flag = cn.execute(sqlCommand)
dim rs as sql::ResultSet
rs = cn.ResultSet]]></example>	
	</case>
	
	<case>
		<title>SQL_ResultSet_Preview() Function </title>
	<description>The sql_ResultSet_preview() function is a built-in Xbasic function for getting a quick view of a ResultSet.</description>	
	<example><![CDATA[sql_ResultSet_preview(rs)
 ]]></example>	
	</case>

	<case>
		
	<description>Here is the result of executing this command.
</description>	
<figure><link>http://www.downloads.alphasoftware.com/Tutorials/ResultsetPreview.jpg</link></figure>

	</case>
	
	<case>
		
	<description>And here is the result of executing the command immediately again.

Notice that there is no data shown. That's because after the first sql_ResultSet_preview() command was executed, the record pointer was at the last row of the ResultSet. A ResultSet is 'forward only'. You would have to re-execute the query and then get a new ResultSet if you wanted to see the results a second time.
</description>	
	<figure><link>http://www.downloads.alphasoftware.com/Tutorials/resultsetpreview_2ndtime.jpg</link></figure>
	</case>
	<case>
		<title>Read only - can't update like a .dbf table </title>
	<description>The ResultSet is read-only. Unlike a native table pointer which you get by executing a table.open("tablename") command, a ResultSet cannot be updated, and you can only move through it in the forward direction. With a .dbf table you can do this:</description>	
	<example><![CDATA[dim tbl as p
tbl = table.open("customer")
tbl.change_begin()
tbl.firstname = "Jay"
tbl.change_end(.t.)
tbl.fetch_next()
tbl.fetch_next()
tbl.fetch_first() ]]></example>	
	</case>
<case>
	<description>If you want to update a SQL table, you execute SQL commands. You don't try to modify values in the ResultSet!</description>
</case>	
</cases>	
	
	
	
</section>	
	
<section>
<title>ResultSet Object Methods</title>	
<description>The ResultSet object has many methods. If does NOT have a reliable way of finding out how many records are in the ResultSet though. You must use a COUNT query to find out how many rows are in a SELECT statement.</description>	
<cases>
	<case>
		<title>.NextRow() </title>
	<description>Use to find out if there are records in the ResultSet. This is an easy way to find out if the ResultSet has any records in it without having to first execute a COUNT query.
</description>
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select * from customer where 1=2"
flag = cn.execute(sqlCommand)
dim rs as sql::ResultSet
rs = cn.ResultSet
flag = rs.NextRow()
?flag
= .f. ]]></example>	
	</case>
	
	
	<case>
	
	<description>When you first get a pointer to a ResultSet, the current row pointer in the ResultSet is positioned BEFORE the first records in the ResultSet. So, the first time you execute .NextRow(), it will position the pointer on the FIRST records in the ResultSet.
NOTE: If you read data (using the ResultSet's .Data(), or .DataIsNull() method) from a ResultSet - WITHOUT FIRST USING .NextRow() to position the pointer on the first row in the Resultset - then Alpha Anywhere automatically does a .NextRow() to position the pointer on the first record in the Resultset. Therefore, the following two sets of commands are equivalent:</description>
	<example><![CDATA[cn.execute("Select * from customer")
rs = cn.resultset
rs.nextRow()
?rs.data("Lastname")
= "Graham" ]]></example>	
	</case>
	
	<case>
	
	<description>And</description>
	<example><![CDATA[cn.execute("Select * from customer")
rs = cn.resultset
?rs.data("Lastname")
= "Graham" ]]></example>	
	</case>
	
	<case>
		<title>Forward only - unlike a .dbf table </title>
	<description>No .PrevRow() command!
Looping through a ResultSet</description>
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select * from customer where bill_state_region = :whatstate"
dim args as sql::arguments
args.add("whatstate","CA")
flag = cn.execute(sqlCommand,args)
dim rs as sql::ResultSet
rs = cn.ResultSet

'This actually moves to the first row in the ResultSet, NOT the second row as you would excpect
flag = rs.nextRow()

'We are now positioned on the first row
dim txt as c
while flag
    txt = txt + "Lastname: " + rs.data("Lastname") + crlf()
    'when there are no more records in the ResultSet, executing .nextRow()
    'will return .f., so flag will be .fl and the while loop will end
    flag = rs.nextRow()
end while ]]></example>	
	</case>
	
	<case>
		<title>How many records are in the ResultSet? </title>
	<description>There is no way of knowing. You have to do a COUNT query.</description>
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select count(*) from customer where bill_state_region = :whatstate"
dim args as sql::arguments
args.add("whatstate","CA")
flag = cn.execute(sqlCommand,args)
dim rs as sql::ResultSet
rs = cn.ResultSet
count = rs.data(1)
?count
= 6]]></example>	
	</case>
	
</cases>	
	
</section>	
	
<section>
	<title>.Data(number) or .Data("columnname") (tbl.Data() for Native tables) </title>
<description>To read the data for a particular column in the ResultSet, use the .data() method. You can pass in a column number, or a column name.
</description>	
<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
dim sqlCommand as c
sqlCommand = "Select count(*) from customer where bill_state_region = :whatstate"
dim args as sql::arguments
args.add("whatstate","CA")
flag = cn.execute(sqlCommand,args)
dim rs as sql::ResultSet
rs = cn.ResultSet
?rs.data(2)
= "Michael"
?rs.data("Firstname")
= "Michael" ]]></example>	
	
</section>

<section>
	
<description>You can use a similar approach to reading data from a .dbf table.
Notice that the 'traditional' method for reading a field from a .dbf table returns trailing spaces!
</description>	
<example><![CDATA[dim tbl as p
tbl = table.open("customer")
?tbl.data("Firstname")
= "Michael"
?tbl.Firstname
= "Michael        "]]></example>	
	
</section>

<section>
	<title>.DataIsNull() </title>
<description>To test whether data is NULL, use the DataIsNull() method.</description>	
<example><![CDATA[?rs.DataIsNull("Firstname")
= .f. ]]></example>	
	
</section>
	
<section>
	<title>ResultSet Object Methods - continued 2</title>
<description>Here are some useful methods of the ResultSet object.</description>	
<cases>
	<case>
		<title>.ToString() </title>
		
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
cn.Execute("select firstname, lastname, bill_city from customer where bill_state_region = 'ca'")
rs = cn.ResultSet
?rs.toString()
= Willy Winka Los Angeles
Yvonne Harrington Los Angeles
Joan McAndrews Los Angeles
Leonard Burtonski Santa Clarita
Peter Harrison Los Angeles
James Mahoney Long Beach ]]></example>	
	</case>
	
	<case>
		<title>.ToDBF() </title>
		<description>Create a .dbf table from a Resultset</description>
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
cn.Execute("select firstname, lastname, bill_city from customer where bill_state_region = 'ca'")
rs = cn.ResultSet
?rs.ToDBF("c:\myfiles\testtable.dbf")
= .T.
file_add_to_db("c:\myfiles\testtable.dbf") ]]></example>	
<figure><link>http://www.downloads.alphasoftware.com/Tutorials/ExportToDBF.jpg</link></figure>
	</case>
	
	<case>
		<title>.ToExcel() 
</title>
		<description>Create an Excel file from a Resultset</description>
	
	</case>
	
	<case>
		<title>.ToJSONObjectSyntax() </title>
		<description>JSON is very useful in Web applications. Create a JSON object from the data in a resultset.</description>
	<example><![CDATA[flag = cn.open("::Name::AlphasportsXbasic")
cn.Execute("select firstname, lastname, bill_city from customer where bill_state_region = 'ca'")
rs = cn.ResultSet
?rs.ToJSONObjectSyntax()
{FIRSTNAME : 'Willy', LASTNAME : 'Winka', BILL_CITY : 'Los Angeles'}
{FIRSTNAME : 'Yvonne', LASTNAME : 'Harrington', BILL_CITY : 'Los Angeles'}
{FIRSTNAME : 'Joan', LASTNAME : 'McAndrews', BILL_CITY : 'Los Angeles'}
{FIRSTNAME : 'Leonard', LASTNAME : 'Burtonski', BILL_CITY : 'Santa Clarita'}
{FIRSTNAME : 'Peter', LASTNAME : 'Harrison', BILL_CITY : 'Los Angeles'}
{FIRSTNAME : 'James', LASTNAME : 'Mahoney', BILL_CITY : 'Long Beach'} ]]></example>	
	</case>
	
	
</cases>	
	
</section>

<section>
	<title>Executing Insert, Updates and Deletes</title>

<cases>
	<case>
		<title>Syntax of an Update Statement 
</title>
	<description>Be sure to put in a WHERE clause or else you will update every record in the table!
</description>	
	<example><![CDATA[Update customer set lastname = 'Rabins', firstname = 'Selwyn' where customer_id = 1 ]]></example>	
	</case>
	<case>
		<description>Same command, this time using arguments.</description>	
	<example><![CDATA[Update customer set lastname = :newLastname, firstname = :newFirstname where customer_id = :oldCustomer_Id ]]></example>
	</case>
	
	<case>
		<title>Syntax of an Insert Statement 
</title>

	<example><![CDATA[Insert into customer (firstname, lastname, company) Values ('Jay', 'Talbot', 'Alpha Software') ]]></example>	
	</case>
	<case>
		<description>Same command, this time using arguments.
</description>	
	<example><![CDATA[Insert into customer (firstname, lastname, company) Values (:newFirstname, :newLastname, :NewCompany)]]></example>
	</case>
	
	<case>
		<title>Syntax of a Delete Statement 
</title>
	<description>Be sure to put in a WHERE clause or else you will delete every record in the table!</description>	
	<example><![CDATA[Delete from Customer where customer_id = 23 ]]></example>	
	</case>
	<case>
		<description>Same command, this time using arguments.</description>	
	<example><![CDATA[Delete from Customer where customer_id = :whatCustomerId ]]></example>
	</case>
	
	<case>
		<title>Did it work? 
</title>
	<description>To see if an Insert, Update or Delete worked, you check the callResult.RowsAffected property. (After first making sure that the .execute() method did not return .f.)
If the .execute() method returns .f., then the SQL command had a syntax error.
If the .execute() method returns .t., then the SQL command executed, but might have done nothing.</description>	
	
	</case>
	<case>
		<title>How many rows were affected? </title>
		<description>The callResult has a .RowsAffected property that tells you how many records were updated, deleted, or inserted by the last SQL command.
</description>	
	<example><![CDATA[sqlUpdate = "Update customer set lastname = :newLastname, firstname = :newFirstname where customer_id = :oldCustomer_Id"
dim args as sql::arguments
args.add("newFirstname","Selwyn")
args.add("newLastname","Rabins")
args.add("oldCustomer_id",1)
?cn.Execute(sqlUpdate,args)
= .T.
?cn.CallResult.RowsAffected
= 1 ]]></example>
	</case>
	
	<case>
		<title>What was the value of the auto-increment field? </title>
	<description>The callResult has a .LastInsertedIdentity that tells you the value of the auto-increment field for the new record created by the last INSERT statement.
</description>	
	<example><![CDATA[sqlInsert = "Insert into customer (firstname, lastname, company) Values (:newFirstname, :newLastname, :NewCompany)"
dim args as sql::arguments
args.add("newFirstname","Jay")
args.add("newLastname","Talbott")
args.add("newCompany","Alpha")
?cn.Execute(sqlInsert,args)
=.T.
?cn.CallResult.RowsAffected
= 1
?cn.CallResult.LastInsertedIdentity
= 61 ]]></example>	
	</case>
	<case>
		<title>Using the Grid Component to Show SQL Statements 
</title>
		<description>An easy way to get the syntax for a SQL statement is to let the Grid component show you what SQL it generated.
</description>	
	<figure><link>http://www.downloads.alphasoftware.com/Tutorials/gridcomponent.jpg</link></figure>
	</case>
	
	<case>
		<figure><link>http://www.downloads.alphasoftware.com/Tutorials/queryecho.jpg</link></figure>
	</case>
	
	<case>
		<figure><link>http://www.downloads.alphasoftware.com/Tutorials/gridshowsquery.jpg</link></figure>
	</case>
	
	<case>
		<figure><link>http://www.downloads.alphasoftware.com/Tutorials/updatecommands.jpg</link></figure>
	</case>
	
	
	
	
	
</cases>	
	
</section>

<section>
	
	<title>Getting your Data into a SQL Database</title>
<cases>
	
	<case>
		<title>Export Operation </title>
		<description>You can export tables from Alpha Anywhere to a SQL database. You can export multiple tables at once.</description>
	</case>
	<case>
		<title>Upsize Genie </title>
		<description>The Upsize Genie does much more than just export tables - it prepares the tables before exporting. e.g. make sure that all auto-increment fields are numeric, etc.


</description>
	</case>
	
</cases>	
	
</section>

<section>
	<title>Built-in Tools</title>
	<cases>
		<case>
			<title>SQL Query Genie 
</title>
			<description>Allows you to build SQL Select commands</description>
		</case>
		<case>
			<title>Command Window 
</title>
			<description>Allows you to execute SQL commands directly against the SQL database much like we have been doing in the Interactive window</description>
		</case>
		<case>
			<title>Database Explorer 
</title>
			<description>Allows you to see what's in a SQL database</description>
		</case>
		<case>
			<title>Action Scripting 
</title>
			<description>Can write simple Xbasic script to manipulate SQL databases</description>
		</case>
		
		
	</cases>
	
	
</section>

<section>
<title>Portable SQL vs. Native SQL</title>	
<description>Unfortunately, SQL is not standard across all different Database vendors. There are different conventions for qualifying object names (e.g. [first name] in SQL Server/Access, `first name` in MySQL, "first name" in Oracle), different command syntaxes, etc.

Alpha Anywhere defines a special 'Portable SQL' syntax so that you can write you SQL without worrying about the differences between SQL databases. When Alpha Anywhere executes a Portable SQL command it automatically translates the SQL to the correct 'native' SQL just before sending the command to the SQL database.</description>	
<cases>
	<case>
		<title>Portable Functions </title>
		<description>When you write Portable SQL, you can use Portable Functions (e.g. concat() ) in your commands.
To get a list of portable sql functions:
</description>
		<example><![CDATA[dim cn as sql::connection
? cn.ListPortableSQLFunctions() ]]></example>
	</case>
	<case>
		<description>Currently there are about 90 portable SQL functions in Alpha Anywhere.</description>
	</case>
	<case>
		<title>Portable Syntax 
</title>
		<description>When you use the Query Builder, Alpha Anywhere generates Portable SQL syntax.
The SQL Query Genie will show you the Native SQL for a given Portable SQL query.</description>
<figure><link>http://www.downloads.alphasoftware.com/Tutorials/sowingNativesyntax.jpg</link></figure>
	</case>
	
	
<case>
	<title>Telling Alpha Anywhere which type of SQL to use 
</title>
<description>When you execute a SQL command you can tell Alpha Anywhere if your command is native or portable SQL
Here we are connected to a MySQL database. In MySQL object names are quotes using a backtick.
</description>	
<example><![CDATA['a Native sql select statement
sqlNative = "select `firstname`, `lastname` from customer"
cn.PortableSQLEnabled = .f.
?cn.Execute(sqlNative)
= .T.

'Now, turn on portable sql and see the command fail
cn.PortableSQLEnabled = .t.
?cn.Execute(sqlNative)
= .F.
?cn.CallResult.text
= Error parsing SQL statement

Your database has returned the following error code and description to Alpha Anywhere.
Consult your database documentation for further information.

8 - 'line 1:8: unexpected char: '`''

'Now, write the SQL as a portable SQL statement
sqlPortable = "select [firstname], [lastname] from [customer]"
cn.PortableSQLEnabled = .f.
?cn.Execute(sqlPortable)
= .f.
?cn.CallResult.text
= Database API specific error

Your database has returned the following error code and description to Alpha Anywhere.
Consult your database documentation for further information.

1064 - 'You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '[firstname], [lastname] from [customer]' at line 1'

'Now, turn portable SQL on
cn.PortableSQLEnabled = .t.
?cn.Execute(sqlPortable)
= .t. ]]></example>	
</case>	
<case>
	<description>Portable SQL Conventions - Use [ ] for object names</description>
</case>	
	
	<case>
		<title>Using the Query Genie to Generate Native Syntax 
</title>
	<description>If you want to generate Native syntax, use the Query Builder and then go to the Native Syntax window.</description>	
		
	</case>
	
</cases>	
	
</section>
<section>
	
	<title>The TableInfo Object</title>
<cases>
	<case>
		<title>What is a TableInfo Object? 
</title>
		<description>TableInfo object contains information about a SQL table.</description>
	</case>
	<case>
		<title>Getting a Table Info Object 
</title>
		<example><![CDATA[Dim ti as sql::tableInfo
Dim cn as sql::connection
flag = cn.open("::Name::AlphasportsXbasic")
?cn.getTableInfo(ti,"Customer")
= .t.


'There is a lot of information about the table in the tableInfo.
'Let's poke around in the Interactive window
?ti.Column.Count
= 21

?ti.Column[1].name
= "CUSTOMER_ID"

?ti.Column[1].nativetypename
= "numeric"
?ti.Column[1].dbftype
= "N"

'Let's see all of the properties in the tableInfo.
?ti
= L AddColumn(Column as SQL::DataTypeInfo) 'Add a Column.
L AddIndex(Index as SQL::IndexInfo) 'Add a Index.
V Clear() 'Reset the contents of the TableInfo as if it had just been declared.
P Clone() 'Create a copy of an object instance.
L ColumnIsInPrimaryKey(N Index) 'Returns true if the column matching the index requested is part of the table's primary key
N ColumnNumber(Name as C) 'Get the index of a Column from the name.
L DeleteColumn(Index as N) 'Delete a Column.
L DeleteIndex(Index as N) 'Delete a Index.
N IndexNumber(Name as C) 'Get the index of a Index from the name.
L InsertColumn(Column as SQL::DataTypeInfo , InsertBefore as N = 1) 'Insert a new Column.
L InsertIndex(Index as SQL::IndexInfo , InsertBefore as N = 1) 'Insert a new Index.
C ListColumns(L IncludeTypes = .f.) 'Create a list of the table columns (optionally including types).
L MoveColumn(MoveTo as N, MoveFrom as N ItemsToCopy as N = 1) 'Move a block of Column items.
L MoveIndex(MoveTo as N, MoveFrom as N ItemsToCopy as N = 1) 'Move a block of Index items.
P NewInstance() 'Create a new object instance of the same type.
L UpdateStatistics(P Connection) 'Gather statistical information about the actual table.
ActiveLinkDBFRowSyntax = CUSTOMER_ID,N,9,0,"notnullable,constant,setnull,showautonumber"
FIRSTNAME,C,20,0,"nullable,updateable,setnull,shownull"
LASTNAME,C,20,0,"nullable,updateable,setnull,shownull"
COMPANY,C,32,0,"nullable,updateable,setnull,shownull"
PHONE,C,20,0,"nullable,updateable,setnull,shownull"
FAX,C,20,0,"nullable,updateable,setnull,shownull"
BILL_ADDRESS_1,C,40,0,"nullable,updateable,setnull,shownull"
BILL_ADDRESS_2,C,40,0,"nullable,updateable,setnull,shownull"
BILL_CITY,C,20,0,"nullable,updateable,setnull,shownull"
BILL_STATE_REGION,C,20,0,"nullable,updateable,setnull,shownull"
BILL_POSTAL_CODE,C,10,0,"nullable,updateable,setnull,shownull"
BILL_COUNTRY,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_ADDRESS_1,C,40,0,"nullable,updateable,setnull,shownull"
SHIP_ADDRESS_2,C,40,0,"nullable,updateable,setnull,shownull"
SHIP_CITY,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_STATE_REGION,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_POSTAL_CODE,C,10,0,"nullable,updateable,setnull,shownull"
SHIP_COUNTRY,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_SAME,L,1,0,"nullable,updateable,setnull,shownull"
EMAIL,C,60,0,"nullable,updateable,setnull,shownull"
CREDITRATING,N,3,0,"nullable,updateable,setnull,shownull"

Alias = "
CanUpdateInTransaction = .T.
Catalog = "
+Column. Comment = "
DBFRowSyntax = CUSTOMER_ID,N,9,0,"notnullable,constant,generate"
FIRSTNAME,C,20,0,"nullable,updateable,setnull,shownull"
LASTNAME,C,20,0,"nullable,updateable,setnull,shownull"
COMPANY,C,32,0,"nullable,updateable,setnull,shownull"
PHONE,C,20,0,"nullable,updateable,setnull,shownull"
FAX,C,20,0,"nullable,updateable,setnull,shownull"
BILL_ADDRESS_1,C,40,0,"nullable,updateable,setnull,shownull"
BILL_ADDRESS_2,C,40,0,"nullable,updateable,setnull,shownull"
BILL_CITY,C,20,0,"nullable,updateable,setnull,shownull"
BILL_STATE_REGION,C,20,0,"nullable,updateable,setnull,shownull"
BILL_POSTAL_CODE,C,10,0,"nullable,updateable,setnull,shownull"
BILL_COUNTRY,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_ADDRESS_1,C,40,0,"nullable,updateable,setnull,shownull"
SHIP_ADDRESS_2,C,40,0,"nullable,updateable,setnull,shownull"
SHIP_CITY,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_STATE_REGION,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_POSTAL_CODE,C,10,0,"nullable,updateable,setnull,shownull"
SHIP_COUNTRY,C,20,0,"nullable,updateable,setnull,shownull"
SHIP_SAME,L,1,0,"nullable,updateable,setnull,shownull"
EMAIL,C,60,0,"nullable,updateable,setnull,shownull"
CREDITRATING,N,3,0,"nullable,updateable,setnull,shownull"

IdentityColumnSubscript = 1
IdentitySequenceName = "
+Index. LastKnownRowCount = -1
Name = "dbo.customer"
NativeAPI = "SQLServer"
NativeSyntax = "SQLServer"
Owner = "dbo"
PrimaryKeyExpression = "CUSTOMER_ID"
PrimaryKeySubscript = 1
QueryAlias = "
Schema = "
SelectRowLimit = -1
SizeToFit = .F.
TableName = "customer"
TableType = 0
TableTypeName = "Table"
UniqueName = "dbo.customer"
Updateable = .T. ]]></example>
	</case>
	
</cases>	
	
</section>
<section>
	<title>Using the Connection Object to Generate SQL Commands</title>
<description>Example:</description>	
<example><![CDATA[cn.GenerateUpdateStatement(tableInfo) ]]></example>	
</section>

</sections>	
	
	
</page>